[{"cord_uid":"e0c2f8f4","source_x":"PMC","title":"Monotonicity properties for a ratio of finite many gamma functions","doi":"10.1186\/s13662-020-02655-4","abstract":"In the paper, the authors consider a ratio of finite many gamma functions and find its monotonicity properties such as complete monotonicity, the Bernstein function property, and logarithmically complete monotonicity.","publish_time":1588291200000,"author_summary":" Qi, Feng; Lim, Dongkyu","abstract_summary":" In the paper, the authors consider a ratio of<br>finite many gamma functions and find its monotonicity<br>properties such as complete monotonicity, the Bernstein<br>function property, and logarithmically complete<br>monotonicity.","title_summary":" Monotonicity properties for a ratio of finite<br>many gamma functions","x":-20.8685398102,"y":46.4642868042,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-20.8685398102,"tsne_y":46.4642868042,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"h21hesgf","source_x":"PMC","title":"Comparing Integer Linear Programming to SAT-Solving for Hard Problems in Computational and Systems Biology","doi":"10.1007\/978-3-030-42266-0_6","abstract":"It is useful to have general-purpose solution methods that can be applied to a wide range of problems, rather than relying on the development of clever, intricate algorithms for each specific problem. Integer Linear Programming is the most widely-used such general-purpose solution method. It is successful in a wide range of problems. However, there are some problems in computational biology where integer linear programming has had only limited success. In this paper, we explore an alternate, general-purpose solution method: SAT-solving, i.e., constructing Boolean formulas in conjunctive normal form (CNF) that encode a problem instance, and using a SAT-solver to determine if the CNF formula is satisfiable or not. In three hard problems examined, we were very surprised to find the SAT-solving approach was dramatically better than the ILP approach in two problems; and a little slower, but more robust, in the third problem. We also re-examined and confirmed an earlier result on a fourth problem, using current ILP and SAT-solvers. These results should encourage further efforts to exploit SAT-solving in computational biology.","publish_time":1580515200000,"author_summary":" Brown, Hannah; Zuo, Lei; Gusfield, Dan","abstract_summary":" It is useful to have general-purpose solution<br>methods that can be applied to a wide range of problems,<br>rather than relying on the development of clever,<br>intricate algorithms for each specific problem. Integer<br>Linear Programming is the most widely-used such<br>general-purpose solution method. It is successful in a wide<br>range of problems. However, there are some problems<br>in computational biology where integer linear<br>programming has had only limited success. In this paper, we<br>explore an alternate, general-purpose solution<br>method: SAT-solving, i.e., constructing Boolean<br>formulas in conjunctive normal form (CNF) that encode a<br>problem instance, and using a SAT-solver to determine...","title_summary":" Comparing Integer Linear Programming to<br>SAT-Solving for Hard Problems in Computational and Systems<br>Biology","x":-24.6544685364,"y":42.5763511658,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.6544685364,"tsne_y":42.5763511658,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"5sbflghq","source_x":"PMC","title":"Parallel Generalized Suffix Tree Construction for Genomic Data","doi":"10.1007\/978-3-030-42266-0_1","abstract":"After a decade of digitization and technological advancements, we have an abundance of usable genomic data, which provide unique insights into our well-being. However, such datasets are large in volume, and retrieving meaningful information from them is often challenging. Hence, different indexing techniques and data structures have been proposed to handle such a massive scale of data. We utilize one such technique: Generalized Suffix Tree (GST). In this paper, we introduce an efficient parallel generalized suffix tree construction algorithm that is scalable for arbitrary genomic datasets. Our construction mechanism employs shared and distributed memory architecture collectively while not posing any fixed, prior memory requirement as it uses external memory (disks). Our experimental results show that our proposed architecture offers around 4-times speedup with respect to the sequential algorithm with only 16 parallel processors. The experiments on different datasets and parameters also exhibit the scalability of the execution time. In addition, we utilize different string queries and demonstrate their execution time on such tree structure, illustrating the efficacy and usability of GST for genomic data.","publish_time":1580515200000,"author_summary":" Aziz, Md Momin Al; Thulasiraman, Parimala;<br>Mohammed, Noman","abstract_summary":" After a decade of digitization and<br>technological advancements, we have an abundance of usable<br>genomic data, which provide unique insights into our<br>well-being. However, such datasets are large in volume, and<br>retrieving meaningful information from them is often<br>challenging. Hence, different indexing techniques and data<br>structures have been proposed to handle such a massive<br>scale of data. We utilize one such technique:<br>Generalized Suffix Tree (GST). In this paper, we introduce<br>an efficient parallel generalized suffix tree<br>construction algorithm that is scalable for arbitrary<br>genomic datasets. Our construction mechanism employs<br>shared and distributed memory architecture<br>collectively while not posing any...","title_summary":" Parallel Generalized Suffix Tree<br>Construction for Genomic Data","x":-26.1627788544,"y":39.722454071,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.1627788544,"tsne_y":39.722454071,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"rn5wohgv","source_x":"PMC","title":"MegaM@Rt2 EU Project: Open Source Tools for Mega-Modelling at Runtime of CPSs","doi":"10.1007\/978-3-030-47240-5_18","abstract":"In this paper, we overview our experiences of developing large set of open source tools in ECSEL JU European project called MegaM@Rt2 whose main objective is to propose a scalable model-based framework incorporating methods and tools for the continuous development and runtime support of complex software-intensive Cyber-Physical Systems (CPSs). We briefly present the MegaM@Rt2 concepts, discuss our approach for open source, enumerate tools and give an example of a tools selection for a specific industrial context. Our goal is to introduce the reader with open source tools for the model-based engineering of CPSs suitable for diverse industrial applications.","publish_time":1588636800000,"author_summary":" Cruz, Jesus Gorro\u00f1ogoitia; Sadovykh, Andrey;<br>Truscan, Dragos; Bruneliere, Hugo; Pierini,<br>Pierluigi; Mu\u00f1iz, Lara Lopez","abstract_summary":" In this paper, we overview our experiences of<br>developing large set of open source tools in ECSEL JU<br>European project called MegaM@Rt2 whose main objective<br>is to propose a scalable model-based framework<br>incorporating methods and tools for the continuous<br>development and runtime support of complex<br>software-intensive Cyber-Physical Systems (CPSs). We briefly<br>present the MegaM@Rt2 concepts, discuss our approach<br>for open source, enumerate tools and give an<br>example of a tools selection for a specific industrial<br>context. Our goal is to introduce the reader with open<br>source tools for the model-based engineering of CPSs<br>suitable for diverse industrial applications.","title_summary":" MegaM@Rt2 EU Project: Open Source Tools for<br>Mega-Modelling at Runtime of CPSs","x":-28.5038757324,"y":43.2433853149,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.5038757324,"tsne_y":43.2433853149,"subcluster":12,"subcluster_description":"Automotive Light System","shape":"p"},{"cord_uid":"l7uq92n2","source_x":"PMC","title":".NET Runtime and Tools for Tizen Operating System","doi":"10.1007\/978-3-030-47240-5_19","abstract":"Samsung Electronics and Microsoft Corporation have been developing open source implementation of .NET platform called .NET Core since 2016. This platform is usually used for implementation of server-side and desktop applications, and Samsung has also adopted .NET Core virtual machine and libraries for Tizen OS. This solution was integrated into various ARM CPU based devices e.g. smart watches, TVs and other electronic devices. Tizen has always supported variety of languages and SDKs for developers. .NET has greatly expanded this variety by supporting new tools and new languages. This paper describes major challenges that we have encountered during integration of .NET to Tizen OS as well as optimizations, which were applied to .NET Core to make applications startup and memory consumption better on variety of devices.","publish_time":1588636800000,"author_summary":" Soldatov, Alexander; Balykov, Gleb; Zhukov,<br>Anton; Shapovalova, Elena; Pavlov, Evgeny","abstract_summary":" Samsung Electronics and Microsoft<br>Corporation have been developing open source<br>implementation of .NET platform called .NET Core since 2016.<br>This platform is usually used for implementation of<br>server-side and desktop applications, and Samsung has also<br>adopted .NET Core virtual machine and libraries for<br>Tizen OS. This solution was integrated into various<br>ARM CPU based devices e.g. smart watches, TVs and<br>other electronic devices. Tizen has always<br>supported variety of languages and SDKs for developers.<br>.NET has greatly expanded this variety by<br>supporting new tools and new languages. This paper<br>describes major challenges that we have encountered<br>during integration of .NET...","title_summary":" .NET Runtime and Tools for Tizen Operating<br>System","x":-27.1438102722,"y":40.6104774475,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.1438102722,"tsne_y":40.6104774475,"subcluster":5,"subcluster_description":"Tizen Operating Systemsemi-Automatic Assessment","shape":"p"},{"cord_uid":"pkgh1dsk","source_x":"PMC","title":"Inferring Restricted Regular Expressions with Interleaving from Positive and Negative Samples","doi":"10.1007\/978-3-030-47436-2_58","abstract":"The presence of a schema for XML documents has numerous advantages. Unfortunately, many XML documents in practice are not accompanied by a schema or a valid schema. Therefore, it is essential to devise algorithms to infer schemas. The fundamental task in XML schema inference is to learn regular expressions. In this paper, we focus on learning the subclass of RE(&) called SIREs (the subclass of regular expressions with interleaving). Previous work in this direction lacks inference algorithms that support inference from positive and negative examples. We provide an algorithm to learn SIREs from positive and negative examples based on genetic algorithms and parallel techniques. Our algorithm also has better expansibility, which means that our algorithm not only supports learning with positive and negative examples, but also supports learning with positive or negative examples only. Experimental results demonstrate the effectiveness of our algorithm.","publish_time":1587081600000,"author_summary":" Li, Yeting; Chen, Haiming; Zhang, Lingqi;<br>Huang, Bo; Zhang, Jianzhao","abstract_summary":" The presence of a schema for XML documents has<br>numerous advantages. Unfortunately, many XML<br>documents in practice are not accompanied by a schema or a<br>valid schema. Therefore, it is essential to devise<br>algorithms to infer schemas. The fundamental task in XML<br>schema inference is to learn regular expressions. In<br>this paper, we focus on learning the subclass of<br>RE(&) called SIREs (the subclass of regular<br>expressions with interleaving). Previous work in this<br>direction lacks inference algorithms that support<br>inference from positive and negative examples. We<br>provide an algorithm to learn SIREs from positive and<br>negative examples based on genetic...","title_summary":" Inferring Restricted Regular Expressions<br>with Interleaving from Positive and Negative<br>Samples","x":-25.871969223,"y":42.7251777649,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.871969223,"tsne_y":42.7251777649,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"gwhym3ea","source_x":"PMC","title":"MemMAP: Compact and Generalizable Meta-LSTM Models for Memory Access Prediction","doi":"10.1007\/978-3-030-47436-2_5","abstract":"With the rise of Big Data, there has been a significant effort in increasing compute power through GPUs, TPUs, and heterogeneous architectures. As a result, many applications are memory bound, i.e., they are bottlenecked by the movement of data from main memory to compute units. One way to address this issue is through data prefetching, which relies on accurate prediction of memory accesses. While recent deep learning models have performed well on sequence prediction problems, they are far too heavy in terms of model size and inference latency to be practical for data prefetching. Here, we propose extremely compact LSTM models that can predict the next memory access with high accuracy. Prior LSTM based work on access prediction has used orders of magnitude more parameters and developed one model for each application (trace). While one (specialized) model per application can result in more accuracy, it is not a scalable approach. In contrast, our models can predict for a class of applications by trading off specialization at the cost of few retraining steps at runtime, for a more generalizable compact meta-model. Our experiments on 13 benchmark applications demonstrate that three compact meta-models can obtain accuracy close to specialized models using few batches of retraining for majority of the applications.","publish_time":1587081600000,"author_summary":" Srivastava, Ajitesh; Wang, Ta-Yang; Zhang,<br>Pengmiao; De Rose, Cesar Augusto F.; Kannan, Rajgopal;<br>Prasanna, Viktor K.","abstract_summary":" With the rise of Big Data, there has been a<br>significant effort in increasing compute power through<br>GPUs, TPUs, and heterogeneous architectures. As a<br>result, many applications are memory bound, i.e., they<br>are bottlenecked by the movement of data from main<br>memory to compute units. One way to address this issue<br>is through data prefetching, which relies on<br>accurate prediction of memory accesses. While recent<br>deep learning models have performed well on<br>sequence prediction problems, they are far too heavy in<br>terms of model size and inference latency to be<br>practical for data prefetching. Here, we propose<br>extremely compact LSTM...","title_summary":" MemMAP: Compact and Generalizable Meta-LSTM<br>Models for Memory Access Prediction","x":-26.842792511,"y":39.7446937561,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.842792511,"tsne_y":39.7446937561,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"eveoyytw","source_x":"PMC","title":"Limited Two-Way Deterministic Finite Automata with Advice","doi":"10.1007\/978-3-030-40608-0_15","abstract":"External assistance in the form of strings called advice is given to an automaton in order to make it a non-uniform model of computation. Automata with advice are then examined to better understand the limitations imposed by uniformity, which is a typical property shared by all feasible computational models. The main contribution of this paper is to introduce and investigate an extension of the model introduced by K\u00fc\u00e7\u00fck et al. [6]. The model is called circular deterministic finite automaton with advice tape (cdfat). In this model the input head is allowed to pass over input multiple times. The number of allowed passes over the input, which is typically a function of input length, is considered as a resource besides the advice amount. The results proved for the model include a hierarchy for cdfat with real-time heads, simulation of 1w\/1w cdfat by 1w\/rt cdfat, lower bounds of resources provided to a cdfat in order to make it powerful enough to recognize any language, utilizable advice limit regardless of the allowed pass limit, a relation between utilizable pass limit and advice limit, and some closure properties.","publish_time":1578355200000,"author_summary":" U\u00e7an, Ahmet Bilal","abstract_summary":" External assistance in the form of strings<br>called advice is given to an automaton in order to make<br>it a non-uniform model of computation. Automata<br>with advice are then examined to better understand<br>the limitations imposed by uniformity, which is a<br>typical property shared by all feasible computational<br>models. The main contribution of this paper is to<br>introduce and investigate an extension of the model<br>introduced by K\u00fc\u00e7\u00fck et al. [6]. The model is called circular<br>deterministic finite automaton with advice tape (cdfat). In<br>this model the input head is allowed to pass over<br>input multiple times. The number of...","title_summary":" Limited Two-Way Deterministic Finite<br>Automata with Advice","x":-25.5077133179,"y":44.0245819092,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.5077133179,"tsne_y":44.0245819092,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"6szflw6v","source_x":"PMC","title":"Ordered Semiautomatic Rings with Applications to Geometry","doi":"10.1007\/978-3-030-40608-0_9","abstract":"The present work looks at semiautomatic rings with automatic addition and comparisons which are dense subrings of the real numbers and asks how these can be used to represent geometric objects such that certain operations and transformations are automatic. The underlying ring has always to be a countable dense subring of the real numbers and additions and comparisons and multiplications with constants need to be automatic. It is shown that the ring can be selected such that equilateral triangles can be represented and rotations by [Formula: see text] are possible, while the standard representation of the b-adic rationals does not allow this.","publish_time":1578355200000,"author_summary":" Gao, Ziyuan; Jain, Sanjay; Qi, Ji; Schlicht,<br>Philipp; Stephan, Frank; Tarr, Jacob","abstract_summary":" The present work looks at semiautomatic rings<br>with automatic addition and comparisons which are<br>dense subrings of the real numbers and asks how these<br>can be used to represent geometric objects such<br>that certain operations and transformations are<br>automatic. The underlying ring has always to be a countable<br>dense subring of the real numbers and additions and<br>comparisons and multiplications with constants need to be<br>automatic. It is shown that the ring can be selected such<br>that equilateral triangles can be represented and<br>rotations by [Formula: see text] are possible, while the<br>standard representation of the b-adic rationals does<br>not...","title_summary":" Ordered Semiautomatic Rings with<br>Applications to Geometry","x":-21.7436466217,"y":45.6868057251,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.7436466217,"tsne_y":45.6868057251,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"wfzsi9u8","source_x":"PMC","title":"Cyclic Shift on Multi-component Grammars","doi":"10.1007\/978-3-030-40608-0_20","abstract":"Multi-component grammars, known in the literature as \u201cmultiple context-free grammars\u201d and \u201clinear context-free rewriting systems\u201d, describe the structure of a string by defining the properties of k-tuples of its substrings, in the same way as ordinary formal grammars (Chomsky\u2019s \u201ccontext-free\u201d) define properties of substrings. It is shown that, for every fixed k, the family of languages described by k-component grammars is closed under the cyclic shift operation. On the other hand, the subfamily defined by well-nested k-component grammars is not closed under the cyclic shift, yet their cyclic shifts are always defined by well-nested [Formula: see text]-component grammars.","publish_time":1578355200000,"author_summary":" Okhotin, Alexander; Sorokin, Alexey","abstract_summary":" Multi-component grammars, known in the<br>literature as \u201cmultiple context-free grammars\u201d and<br>\u201clinear context-free rewriting systems\u201d, describe<br>the structure of a string by defining the<br>properties of k-tuples of its substrings, in the same way as<br>ordinary formal grammars (Chomsky\u2019s \u201ccontext-free\u201d)<br>define properties of substrings. It is shown that, for<br>every fixed k, the family of languages described by<br>k-component grammars is closed under the cyclic shift<br>operation. On the other hand, the subfamily defined by<br>well-nested k-component grammars is not closed under the<br>cyclic shift, yet their cyclic shifts are always<br>defined by well-nested [Formula: see text]-component<br>grammars.","title_summary":" Cyclic Shift on Multi-component Grammars","x":-24.0423812866,"y":44.9986610413,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0423812866,"tsne_y":44.9986610413,"subcluster":14,"subcluster_description":"Orienting Combinator Equationsshort Q-Resolution","shape":"p"},{"cord_uid":"vjs0gvb5","source_x":"PMC","title":"Reducing the Ambiguity of Parikh Matrices","doi":"10.1007\/978-3-030-40608-0_28","abstract":"The Parikh matrix mapping allows us to describe words using matrices. Although compact, this description comes with a level of ambiguity since a single matrix may describe multiple words. This work looks at how considering the Parikh matrices of various transformations of a given word can decrease that ambiguity. More specifically, for any word, we study the Parikh matrix of its Lyndon conjugate as well as that of its projection to a smaller alphabet. Our results demonstrate that ambiguity can often be reduced using these concepts, and we give conditions on when they succeed.","publish_time":1578355200000,"author_summary":" Dick, Jeffery; Hutchinson, Laura K.; Merca\u015f,<br>Robert; Reidenbach, Daniel","abstract_summary":" The Parikh matrix mapping allows us to describe<br>words using matrices. Although compact, this<br>description comes with a level of ambiguity since a single<br>matrix may describe multiple words. This work looks at<br>how considering the Parikh matrices of various<br>transformations of a given word can decrease that ambiguity.<br>More specifically, for any word, we study the Parikh<br>matrix of its Lyndon conjugate as well as that of its<br>projection to a smaller alphabet. Our results demonstrate<br>that ambiguity can often be reduced using these<br>concepts, and we give conditions on when they succeed.","title_summary":" Reducing the Ambiguity of Parikh Matrices","x":-22.8235626221,"y":45.3154716492,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.8235626221,"tsne_y":45.3154716492,"subcluster":20,"subcluster_description":"Classic Real Number Representations","shape":"p"},{"cord_uid":"ys0sy9d9","source_x":"PMC","title":"Complexity Issues of String to Graph Approximate Matching","doi":"10.1007\/978-3-030-40608-0_17","abstract":"The problem of matching a query string to a directed graph, whose vertices are labeled by strings, has application in different fields, from data mining to computational biology. Several variants of the problem have been considered, depending on the fact that the match is exact or approximate and, in this latter case, which edit operations are considered and where are allowed. In this paper we present results on the complexity of the approximate matching problem, where edit operations are symbol substitutions and are allowed only on the graph labels or both on the graph labels and the query string. We introduce a variant of the problem that asks whether there exists a path in a graph that represents a query string with any number of edit operations and we show that is NP-complete, even when labels have length one and in the case the alphabet is binary. Moreover, when it is parameterized by the length of the input string and graph labels have length one, we show that the problem is fixed-parameter tractable and it is unlikely to admit a polynomial kernel. The NP-completeness of this problem leads to the inapproximability (within any factor) of the approximate matching when edit operations are allowed only on the graph labels. Moreover, we show that the variants of approximate string matching to graph we consider are not fixed-parameter tractable, when the parameter is the number of edit operations, even for graphs that have distance one from a DAG. The reduction for this latter result allows us to prove the inapproximability of the variant where edit operations can be applied both on the query string and on graph labels.","publish_time":1578355200000,"author_summary":" Dondi, Riccardo; Mauri, Giancarlo; Zoppis,<br>Italo","abstract_summary":" The problem of matching a query string to a<br>directed graph, whose vertices are labeled by strings,<br>has application in different fields, from data<br>mining to computational biology. Several variants of<br>the problem have been considered, depending on the<br>fact that the match is exact or approximate and, in<br>this latter case, which edit operations are<br>considered and where are allowed. In this paper we present<br>results on the complexity of the approximate matching<br>problem, where edit operations are symbol<br>substitutions and are allowed only on the graph labels or both<br>on the graph labels and the query string. We...","title_summary":" Complexity Issues of String to Graph<br>Approximate Matching","x":-22.9549312592,"y":43.3788375854,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.9549312592,"tsne_y":43.3788375854,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"5dfen4k2","source_x":"PMC","title":"Approaching Arithmetic Theories with Finite-State Automata","doi":"10.1007\/978-3-030-40608-0_3","abstract":"The automata-theoretic approach provides an elegant method for deciding linear arithmetic theories. This approach has recently been instrumental for settling long-standing open problems about the complexity of deciding the existential fragments of B\u00fcchi arithmetic and linear arithmetic over p-adic fields. In this article, which accompanies an invited talk, we give a high-level exposition of the NP upper bound for existential B\u00fcchi arithmetic, obtain some derived results, and further discuss some open problems.","publish_time":1578355200000,"author_summary":" Haase, Christoph","abstract_summary":" The automata-theoretic approach provides an<br>elegant method for deciding linear arithmetic<br>theories. This approach has recently been instrumental<br>for settling long-standing open problems about<br>the complexity of deciding the existential<br>fragments of B\u00fcchi arithmetic and linear arithmetic over<br>p-adic fields. In this article, which accompanies an<br>invited talk, we give a high-level exposition of the NP<br>upper bound for existential B\u00fcchi arithmetic,<br>obtain some derived results, and further discuss some<br>open problems.","title_summary":" Approaching Arithmetic Theories with<br>Finite-State Automata","x":-24.2798938751,"y":45.5403366089,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.2798938751,"tsne_y":45.5403366089,"subcluster":14,"subcluster_description":"Orienting Combinator Equationsshort Q-Resolution","shape":"p"},{"cord_uid":"xsufgkq6","source_x":"PMC","title":"Nonstandard Cayley Automatic Representations for Fundamental Groups of Torus Bundles over the Circle","doi":"10.1007\/978-3-030-40608-0_7","abstract":"We construct a new family of Cayley automatic representations of semidirect products [Formula: see text] for which none of the projections of the normal subgroup [Formula: see text] onto each of its cyclic components is finite automaton recognizable. For [Formula: see text] we describe a family of matrices from [Formula: see text] corresponding to these representations. We are motivated by a problem of characterization of all possible Cayley automatic representations of these groups.","publish_time":1578355200000,"author_summary":" Berdinsky, Dmitry; Kruengthomya, Prohrak","abstract_summary":" We construct a new family of Cayley automatic<br>representations of semidirect products [Formula: see text] for<br>which none of the projections of the normal subgroup<br>[Formula: see text] onto each of its cyclic components is<br>finite automaton recognizable. For [Formula: see<br>text] we describe a family of matrices from [Formula:<br>see text] corresponding to these<br>representations. We are motivated by a problem of<br>characterization of all possible Cayley automatic<br>representations of these groups.","title_summary":" Nonstandard Cayley Automatic<br>Representations for Fundamental Groups of Torus Bundles over<br>the Circle","x":-22.0228252411,"y":45.7222671509,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.0228252411,"tsne_y":45.7222671509,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"6mw6avpg","source_x":"PMC","title":"Lyndon Words versus Inverse Lyndon Words: Queries on Suffixes and Bordered Words","doi":"10.1007\/978-3-030-40608-0_27","abstract":"The Lyndon factorization of a word has been extensively studied in different contexts and several variants of it have been proposed. In particular, the canonical inverse Lyndon factorization [Formula: see text], introduced in [5], maintains the main properties of the Lyndon factorization since it can be computed in linear time and it is uniquely determined. In this paper we investigate new properties of this factorization with the purpose of exploring its use in string queries. As a main result, we prove an upper bound on the length of the longest common extension (or longest common prefix) for two factors of a word w. This bound is at most the maximum length of two consecutive factors of [Formula: see text]. A tool used in the proof is a property that we state for factors with nonempty borders in [Formula: see text]: a nonempty border of a factor [Formula: see text] cannot be a prefix of the next factor [Formula: see text]. Another interesting result relates sorting of global suffixes, i.e., suffixes of a word w, and sorting of local suffixes, i.e., suffixes of the factors in [Formula: see text]. Finally, given a word w and a factor x of w, we prove that their Lyndon factorizations share factors, except for the first and last term of the Lyndon factorization of x. This property suggests that, given two words sharing a common overlap, their Lyndon factorizations could be used to capture the common overlap of these two words.","publish_time":1578355200000,"author_summary":" Bonizzoni, Paola; De Felice, Clelia;<br>Zaccagnino, Rocco; Zizza, Rosalba","abstract_summary":" The Lyndon factorization of a word has been<br>extensively studied in different contexts and several<br>variants of it have been proposed. In particular, the<br>canonical inverse Lyndon factorization [Formula: see<br>text], introduced in [5], maintains the main<br>properties of the Lyndon factorization since it can be<br>computed in linear time and it is uniquely determined. In<br>this paper we investigate new properties of this<br>factorization with the purpose of exploring its use in string<br>queries. As a main result, we prove an upper bound on the<br>length of the longest common extension (or longest<br>common prefix) for two factors of...","title_summary":" Lyndon Words versus Inverse Lyndon Words:<br>Queries on Suffixes and Bordered Words","x":-23.0808639526,"y":44.1896705627,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.0808639526,"tsne_y":44.1896705627,"subcluster":29,"subcluster_description":"Inverse Lyndon Words","shape":"p"},{"cord_uid":"jcgvravf","source_x":"PMC","title":"Alternating Finite Automata with Limited Universal Branching","doi":"10.1007\/978-3-030-40608-0_13","abstract":"We consider measures that limit universal parallelism in computations of an alternating finite automaton (AFA). Maximum pared tree width counts the largest number of universal branches in any computation and acceptance width counts the number of universal branches in the best accepting computation, i.e., in the accepting computation with least universal parallelism. We give algorithms to decide whether the maximum pared tree width or the acceptance width of an AFA are bounded by an integer k. For a constant k the algorithm for maximum pared tree width operates in polynomial time. An AFA with m states and acceptance width k can be converted to an NFA with [Formula: see text] states. We consider corresponding lower bounds for the transformation. The tree width of an AFA counts the number of all (existential and universal) branches of the computation. We give upper and lower bounds for converting an AFA of bounded tree width to a DFA.","publish_time":1578355200000,"author_summary":" Keeler, Chris; Salomaa, Kai","abstract_summary":" We consider measures that limit universal<br>parallelism in computations of an alternating finite<br>automaton (AFA). Maximum pared tree width counts the<br>largest number of universal branches in any<br>computation and acceptance width counts the number of<br>universal branches in the best accepting computation,<br>i.e., in the accepting computation with least<br>universal parallelism. We give algorithms to decide<br>whether the maximum pared tree width or the acceptance<br>width of an AFA are bounded by an integer k. For a<br>constant k the algorithm for maximum pared tree width<br>operates in polynomial time. An AFA with m states and<br>acceptance width k...","title_summary":" Alternating Finite Automata with Limited<br>Universal Branching","x":-24.0773677826,"y":44.3196334839,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0773677826,"tsne_y":44.3196334839,"subcluster":21,"subcluster_description":"Stack Automata Modelsinvolutory Turing","shape":"p"},{"cord_uid":"uj3ta0mz","source_x":"PMC","title":"On the Weisfeiler-Leman Dimension of Fractional Packing","doi":"10.1007\/978-3-030-40608-0_25","abstract":"The k-dimensional Weisfeiler-Leman procedure ([Formula: see text]) has proven to be immensely fruitful in the algorithmic study of Graph Isomorphism. More generally, it is of fundamental importance in understanding and exploiting symmetries in graphs in various settings. Two graphs are [Formula: see text]-equivalent if dimention k does not suffice to distinguish them. [Formula: see text]-equivalence is known as fractional isomorphism of graphs, and the [Formula: see text]-equivalence relation becomes finer as k increases. We investigate to what extent standard graph parameters are preserved by [Formula: see text]-equivalence, focusing on fractional graph packing numbers. The integral packing numbers are typically NP-hard to compute, and we discuss applicability of [Formula: see text]-invariance for estimating the integrality gap of the LP relaxation provided by their fractional counterparts.","publish_time":1578355200000,"author_summary":" Arvind, Vikraman; Fuhlbr\u00fcck, Frank; K\u00f6bler,<br>Johannes; Verbitsky, Oleg","abstract_summary":" The k-dimensional Weisfeiler-Leman<br>procedure ([Formula: see text]) has proven to be<br>immensely fruitful in the algorithmic study of Graph<br>Isomorphism. More generally, it is of fundamental<br>importance in understanding and exploiting symmetries in<br>graphs in various settings. Two graphs are [Formula:<br>see text]-equivalent if dimention k does not<br>suffice to distinguish them. [Formula: see<br>text]-equivalence is known as fractional isomorphism of graphs,<br>and the [Formula: see text]-equivalence relation<br>becomes finer as k increases. We investigate to what<br>extent standard graph parameters are preserved by<br>[Formula: see text]-equivalence, focusing on<br>fractional graph packing numbers. The integral packing<br>numbers are typically NP-hard...","title_summary":" On the Weisfeiler-Leman Dimension of<br>Fractional Packing","x":-22.4080810547,"y":43.9192237854,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4080810547,"tsne_y":43.9192237854,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"akzr61vd","source_x":"PMC","title":"Simplified Parsing Expression Derivatives","doi":"10.1007\/978-3-030-40608-0_30","abstract":"This paper presents a new derivative parsing algorithm for parsing expression grammars; this new algorithm is both simpler and faster than the existing parsing expression derivative algorithm presented by Moss [12]. This new algorithm improves on the worst-case space and runtime bounds of the previous algorithm by a linear factor, as well as decreasing runtime by about half in practice.","publish_time":1578355200000,"author_summary":" Moss, Aaron","abstract_summary":" This paper presents a new derivative parsing<br>algorithm for parsing expression grammars; this new<br>algorithm is both simpler and faster than the existing<br>parsing expression derivative algorithm presented by<br>Moss [12]. This new algorithm improves on the<br>worst-case space and runtime bounds of the previous<br>algorithm by a linear factor, as well as decreasing<br>runtime by about half in practice.","title_summary":" Simplified Parsing Expression Derivatives","x":-24.6271152496,"y":46.1964149475,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.6271152496,"tsne_y":46.1964149475,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"4akkg1yu","source_x":"PMC","title":"Recompression: Technique for Word Equations and Compressed Data","doi":"10.1007\/978-3-030-40608-0_4","abstract":"In this talk I will present the recompression technique on the running example of word equations. In word equation problem we are given an equation [Formula: see text], where both u and v are words of letters and variables, and ask for a substitution of variables by words that equalizes the sides of the equation. The recompression technique is based on employing simple compression rules (replacement of two letters ab by a new letter c, replacement of maximal repetitions of a by a new letter), and modifying the equations (replacing a variable X by bX or Xa) so that those operations are sound and complete. The simple analysis focuses on the size of the instance and not on the combinatorial properties of words that are used. The recompression-based algorithm for word equations runs in nondeterministic linear space. The approach turned out to be quite robust and can be applied to various generalized, simplified and related problems, in particular, to problems in the area of grammar compressed words. I will comment on some of those applications.","publish_time":1578355200000,"author_summary":" Je\u017c, Artur","abstract_summary":" In this talk I will present the recompression<br>technique on the running example of word equations. In<br>word equation problem we are given an equation<br>[Formula: see text], where both u and v are words of letters<br>and variables, and ask for a substitution of<br>variables by words that equalizes the sides of the<br>equation. The recompression technique is based on<br>employing simple compression rules (replacement of two<br>letters ab by a new letter c, replacement of maximal<br>repetitions of a by a new letter), and modifying the<br>equations (replacing a variable X by bX or Xa) so that those...","title_summary":" Recompression: Technique for Word Equations<br>and Compressed Data","x":-23.8016548157,"y":43.8841972351,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.8016548157,"tsne_y":43.8841972351,"subcluster":28,"subcluster_description":"Automata Networksmonadic Decomposition","shape":"p"},{"cord_uid":"33kqrm7f","source_x":"PMC","title":"How to Prove that a Language Is Regular or Star-Free?","doi":"10.1007\/978-3-030-40608-0_5","abstract":"This survey article presents some standard and less standard methods used to prove that a language is regular or star-free.","publish_time":1578355200000,"author_summary":" Pin, Jean-\u00c9ric","abstract_summary":" This survey article presents some standard and<br>less standard methods used to prove that a language<br>is regular or star-free.","title_summary":" How to Prove that a Language Is Regular or<br>Star-Free?","x":-23.6032142639,"y":46.4535675049,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.6032142639,"tsne_y":46.4535675049,"subcluster":18,"subcluster_description":"Capturing Complexity Classes","shape":"p"},{"cord_uid":"5vgktd3o","source_x":"PMC","title":"On the Size of Depth-Two Threshold Circuits for the Inner Product Mod 2 Function","doi":"10.1007\/978-3-030-40608-0_16","abstract":"In this paper, we study the size of depth-two threshold circuits computing the inner product mod 2 function [Formula: see text] (mod 2). First, we reveal that [Formula: see text] can be computed by a depth-two threshold circuit of size significantly smaller than a folklore construction of size [Formula: see text]. Namely, we give a construction of such a circuit (denoted by [Formula: see text] circuit) of size [Formula: see text]. We also give an upper bound of [Formula: see text] for the case that the weights of the top threshold gate are polynomially bounded (denoted by [Formula: see text] circuit). Second, we give new lower bounds on the size of depth-two circuits of some special form; the top gate is an unbounded weight threshold gate and the bottom gates are symmetric gates (denoted by [Formula: see text] circuit). We show that any such circuit computing [Formula: see text] has size [Formula: see text] for every constant [Formula: see text]. This improves the previous bound of [Formula: see text] based on the sign-rank method due to Forster et al. [JCSS \u201902, FSTTCS \u201901]. Our technique has a unique feature that the lower bound is obtained by giving an explicit feasible solution to (the dual of) a certain linear programming problem. In fact, the problem itself was presented by the author over a decade ago [MFCS \u201905], and finding a good solution is an actual contribution of this work.","publish_time":1578355200000,"author_summary":" Amano, Kazuyuki","abstract_summary":" In this paper, we study the size of depth-two<br>threshold circuits computing the inner product mod 2<br>function [Formula: see text] (mod 2). First, we reveal<br>that [Formula: see text] can be computed by a<br>depth-two threshold circuit of size significantly<br>smaller than a folklore construction of size [Formula:<br>see text]. Namely, we give a construction of such a<br>circuit (denoted by [Formula: see text] circuit) of<br>size [Formula: see text]. We also give an upper bound<br>of [Formula: see text] for the case that the<br>weights of the top threshold gate are polynomially<br>bounded (denoted by [Formula: see text]...","title_summary":" On the Size of Depth-Two Threshold Circuits for<br>the Inner Product Mod 2 Function","x":-22.8360404968,"y":43.792388916,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.8360404968,"tsne_y":43.792388916,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"vwgfffnh","source_x":"PMC","title":"Boolean Monadic Recursive Schemes as a Logical Characterization of the Subsequential Functions","doi":"10.1007\/978-3-030-40608-0_10","abstract":"This paper defines boolean monadic recursive schemes (BMRSs), a restriction on recursive programs, and shows that when interpreted as transductions on strings they describe exactly the subsequential functions. We discuss how this new result furthers the study of the connections between logic, formal languages and functions, and automata.","publish_time":1578355200000,"author_summary":" Bhaskar, Siddharth; Chandlee, Jane; Jardine,<br>Adam; Oakden, Christopher","abstract_summary":" This paper defines boolean monadic recursive<br>schemes (BMRSs), a restriction on recursive programs,<br>and shows that when interpreted as transductions<br>on strings they describe exactly the<br>subsequential functions. We discuss how this new result<br>furthers the study of the connections between logic,<br>formal languages and functions, and automata.","title_summary":" Boolean Monadic Recursive Schemes as a Logical<br>Characterization of the Subsequential Functions","x":-23.9052944183,"y":45.907535553,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.9052944183,"tsne_y":45.907535553,"subcluster":16,"subcluster_description":"Strictly Local Tree Transducersequivalence","shape":"p"},{"cord_uid":"98bgbg1k","source_x":"PMC","title":"Complexity of Automatic Sequences","doi":"10.1007\/978-3-030-40608-0_18","abstract":"Automatic sequences can be defined by DFAs with output (DFAO) in two natural ways. We propose to consider the minimal size of a corresponding DFAO as the complexity measure of the automatic sequence, for both variants. This paper compares these complexity measures and investigates their properties like the relationships with kernel and morphic sequences. There exist automatic sequences for which the one complexity is exponentially greater than the other one, in both directions. For both complexity measures we investigate the effect of taking basic operations on sequences like removing or adding an element in front, and observe that these operations may increase the complexity by at most a quadratic factor.","publish_time":1578355200000,"author_summary":" Zantema, Hans","abstract_summary":" Automatic sequences can be defined by DFAs with<br>output (DFAO) in two natural ways. We propose to<br>consider the minimal size of a corresponding DFAO as the<br>complexity measure of the automatic sequence, for both<br>variants. This paper compares these complexity measures<br>and investigates their properties like the<br>relationships with kernel and morphic sequences. There exist<br>automatic sequences for which the one complexity is<br>exponentially greater than the other one, in both directions.<br>For both complexity measures we investigate the<br>effect of taking basic operations on sequences like<br>removing or adding an element in front, and observe that<br>these operations...","title_summary":" Complexity of Automatic Sequences","x":-23.0167655945,"y":45.396396637,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.0167655945,"tsne_y":45.396396637,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"an8xlnnd","source_x":"PMC","title":"Intersection and Union Hierarchies of Deterministic Context-Free Languages and Pumping Lemmas","doi":"10.1007\/978-3-030-40608-0_24","abstract":"We study the computational complexity of finite intersections and unions of deterministic context-free languages. Earlier, Wotschke (1978) demonstrated that intersections of [Formula: see text] deterministic context-free languages are in general more powerful than intersections of d deterministic context-free languages for any positive integer d based on the hierarchy separation of Liu and Weiner (1973). The argument of Liu and Weiner, however, works only on bounded languages of particular forms, and therefore Wotschke\u2019s result cannot be extended to disprove any other language to be written in the form of an intersection of d deterministic context-free languages. To deal with the non-membership of a wide range of languages, we circumvent their proof argument and instead devise a new, practical technical tool: a pumping lemma for finite unions of deterministic context-free languages. Since the family of deterministic context-free languages is closed under complementation, this pumping lemma enables us to show a non-membership relation of languages made up with finite intersections of even non-bounded languages as well. We also refer to a relationship to Hibbard\u2019s limited automata.","publish_time":1578355200000,"author_summary":" Yamakami, Tomoyuki","abstract_summary":" We study the computational complexity of<br>finite intersections and unions of deterministic<br>context-free languages. Earlier, Wotschke (1978)<br>demonstrated that intersections of [Formula: see text]<br>deterministic context-free languages are in general more<br>powerful than intersections of d deterministic<br>context-free languages for any positive integer d based on<br>the hierarchy separation of Liu and Weiner (1973).<br>The argument of Liu and Weiner, however, works only<br>on bounded languages of particular forms, and<br>therefore Wotschke\u2019s result cannot be extended to<br>disprove any other language to be written in the form of an<br>intersection of d deterministic context-free languages. To<br>deal with the non-membership...","title_summary":" Intersection and Union Hierarchies of<br>Deterministic Context-Free Languages and Pumping Lemmas","x":-24.1629543304,"y":44.4827880859,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.1629543304,"tsne_y":44.4827880859,"subcluster":21,"subcluster_description":"Stack Automata Modelsinvolutory Turing","shape":"p"},{"cord_uid":"zd73gar6","source_x":"PMC","title":"Complete Variable-Length Codes: An Excursion into Word Edit Operations","doi":"10.1007\/978-3-030-40608-0_31","abstract":"Given an alphabet A and a binary relation [Formula: see text], a language [Formula: see text] is [Formula: see text]-independent if [Formula: see text]; X is [Formula: see text]-closed if [Formula: see text]. The language X is complete if any word over A is a factor of some concatenation of words in X. Given a family of languages [Formula: see text] containing X, X is maximal in [Formula: see text] if no other set of [Formula: see text] can strictly contain X. A language [Formula: see text] is a variable-length code if any equation among the words of X is necessarily trivial. The study discusses the relationship between maximality and completeness in the case of [Formula: see text]-independent or [Formula: see text]-closed variable-length codes. We focus to the binary relations by which the images of words are computed by deleting, inserting, or substituting some characters.","publish_time":1578355200000,"author_summary":" N\u00e9raud, Jean","abstract_summary":" Given an alphabet A and a binary relation<br>[Formula: see text], a language [Formula: see text] is<br>[Formula: see text]-independent if [Formula: see text];<br>X is [Formula: see text]-closed if [Formula: see<br>text]. The language X is complete if any word over A is a<br>factor of some concatenation of words in X. Given a<br>family of languages [Formula: see text] containing X,<br>X is maximal in [Formula: see text] if no other set<br>of [Formula: see text] can strictly contain X. A<br>language [Formula: see text] is a variable-length code<br>if any equation among the words of X is...","title_summary":" Complete Variable-Length Codes: An Excursion<br>into Word Edit Operations","x":-23.0268821716,"y":44.1640892029,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.0268821716,"tsne_y":44.1640892029,"subcluster":29,"subcluster_description":"Inverse Lyndon Words","shape":"p"},{"cord_uid":"cfvekouq","source_x":"PMC","title":"Containment and Equivalence of Weighted Automata: Probabilistic and Max-Plus Cases","doi":"10.1007\/978-3-030-40608-0_2","abstract":"This paper surveys some results regarding decision problems for probabilistic and max-plus automata, such as containment and equivalence. Probabilistic and max-plus automata are part of the general family of weighted automata, whose semantics are maps from words to real values. Given two weighted automata, the equivalence problem asks whether their semantics are the same, and the containment problem whether one is point-wise smaller than the other one. These problems have been studied intensively and this paper will review some techniques used to show (un)decidability and state a list of open questions that still remain.","publish_time":1578355200000,"author_summary":" Daviaud, Laure","abstract_summary":" This paper surveys some results regarding<br>decision problems for probabilistic and max-plus<br>automata, such as containment and equivalence.<br>Probabilistic and max-plus automata are part of the general<br>family of weighted automata, whose semantics are maps<br>from words to real values. Given two weighted<br>automata, the equivalence problem asks whether their<br>semantics are the same, and the containment problem<br>whether one is point-wise smaller than the other one.<br>These problems have been studied intensively and<br>this paper will review some techniques used to show<br>(un)decidability and state a list of open questions that still<br>remain.","title_summary":" Containment and Equivalence of Weighted<br>Automata: Probabilistic and Max-Plus Cases","x":-24.8383178711,"y":44.7769355774,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.8383178711,"tsne_y":44.7769355774,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"y1o0mda9","source_x":"PMC","title":"Context-Sensitive Fusion Grammars Are Universal","doi":"10.1007\/978-3-030-40608-0_19","abstract":"Context-sensitive fusion grammars are a special case of context-dependent fusion grammars where a rule has only a single positive context condition instead of finite sets of positive and negative context conditions. They generate hypergraph languages from start hypergraphs via successive applications of context-sensitive fusion rules and multiplications of connected components, as well as a filtering mechanism to extract terminal hypergraphs from derived hypergraphs in a certain way. The application of a context-sensitive fusion rule consumes two complementarily labeled hyperedges and identifies corresponding attachment vertices provided that the context condition holds. In this paper, we show that the Post correspondence problem can be formulated very intuitively by such a grammar. Furthermore, we prove that these grammars can generate all recursively enumerable string languages (up to representation of strings as graphs) and are universal in this respect.","publish_time":1578355200000,"author_summary":" Lye, Aaron","abstract_summary":" Context-sensitive fusion grammars are a<br>special case of context-dependent fusion grammars<br>where a rule has only a single positive context<br>condition instead of finite sets of positive and negative<br>context conditions. They generate hypergraph<br>languages from start hypergraphs via successive<br>applications of context-sensitive fusion rules and<br>multiplications of connected components, as well as a filtering<br>mechanism to extract terminal hypergraphs from derived<br>hypergraphs in a certain way. The application of a<br>context-sensitive fusion rule consumes two complementarily<br>labeled hyperedges and identifies corresponding<br>attachment vertices provided that the context condition<br>holds. In this paper, we show that the Post<br>correspondence problem...","title_summary":" Context-Sensitive Fusion Grammars Are<br>Universal","x":-24.304151535,"y":45.0042800903,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.304151535,"tsne_y":45.0042800903,"subcluster":14,"subcluster_description":"Orienting Combinator Equationsshort Q-Resolution","shape":"p"},{"cord_uid":"la40zd0x","source_x":"PMC","title":"The Automatic Baire Property and an Effective Property of [Formula: see text]-Rational Functions","doi":"10.1007\/978-3-030-40608-0_21","abstract":"We prove that [Formula: see text]-regular languages accepted by B\u00fcchi or Muller automata satisfy an effective automata-theoretic version of the Baire property. Then we use this result to obtain a new effective property of rational functions over infinite words which are realized by finite state B\u00fcchi transducers: for each such function [Formula: see text], one can construct a deterministic B\u00fcchi automaton [Formula: see text] accepting a dense [Formula: see text]-subset of [Formula: see text] such that the restriction of F to [Formula: see text] is continuous.","publish_time":1578355200000,"author_summary":" Finkel, Olivier","abstract_summary":" We prove that [Formula: see text]-regular<br>languages accepted by B\u00fcchi or Muller automata satisfy an<br>effective automata-theoretic version of the Baire<br>property. Then we use this result to obtain a new effective<br>property of rational functions over infinite words<br>which are realized by finite state B\u00fcchi<br>transducers: for each such function [Formula: see text], one<br>can construct a deterministic B\u00fcchi automaton<br>[Formula: see text] accepting a dense [Formula: see<br>text]-subset of [Formula: see text] such that the<br>restriction of F to [Formula: see text] is continuous.","title_summary":" The Automatic Baire Property and an Effective<br>Property of [Formula: see text]-Rational Functions","x":-23.3824539185,"y":44.6102676392,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.3824539185,"tsne_y":44.6102676392,"subcluster":34,"subcluster_description":"Text]On Collapsing Prefix Normal","shape":"p"},{"cord_uid":"5cj6ht4g","source_x":"PMC","title":"Deciding Classes of Regular Languages: The Covering Approach","doi":"10.1007\/978-3-030-40608-0_6","abstract":"We investigate the membership problem that one may associate to every class of languages [Formula: see text]. The problem takes a regular language as input and asks whether it belongs to [Formula: see text]. In practice, finding an algorithm provides a deep insight on the class [Formula: see text]. While this problem has a long history, many famous open questions in automata theory are tied to membership. Recently, a breakthrough was made on several of these open questions. This was achieved by considering a more general decision problem than membership: covering. In the paper, we investigate how the new ideas and techniques brought about by the introduction of this problem can be applied to get new insight on earlier results. In particular, we use them to give new proofs for two of the most famous membership results: Sch\u00fctzenberger\u2019s theorem and Simon\u2019s theorem.","publish_time":1578355200000,"author_summary":" Place, Thomas","abstract_summary":" We investigate the membership problem that one<br>may associate to every class of languages<br>[Formula: see text]. The problem takes a regular language<br>as input and asks whether it belongs to [Formula:<br>see text]. In practice, finding an algorithm<br>provides a deep insight on the class [Formula: see text].<br>While this problem has a long history, many famous<br>open questions in automata theory are tied to<br>membership. Recently, a breakthrough was made on several of<br>these open questions. This was achieved by<br>considering a more general decision problem than<br>membership: covering. In the paper, we investigate how the<br>new ideas...","title_summary":" Deciding Classes of Regular Languages: The<br>Covering Approach","x":-23.6475124359,"y":44.2469940186,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.6475124359,"tsne_y":44.2469940186,"subcluster":35,"subcluster_description":"Semi-Simple Splicing Systemsthe State","shape":"p"},{"cord_uid":"970jqfrg","source_x":"PMC","title":"Geometrically Closed Positive Varieties of Star-Free Languages","doi":"10.1007\/978-3-030-40608-0_23","abstract":"A recently introduced operation of geometrical closure on formal languages is investigated. It is proved that the geometrical closure of a language from the positive variety [Formula: see text], the level 3\/2 of the Straubing-Th\u00e9rien hierarchy of star-free languages, always falls into the variety [Formula: see text], which is a new variety consisting of specific R-trivial languages. As a consequence, each class of regular languages lying between [Formula: see text] and [Formula: see text] is geometrically closed.","publish_time":1578355200000,"author_summary":" Kl\u00edma, Ond\u0159ej; Kostol\u00e1nyi, Peter","abstract_summary":" A recently introduced operation of<br>geometrical closure on formal languages is investigated.<br>It is proved that the geometrical closure of a<br>language from the positive variety [Formula: see text],<br>the level 3\/2 of the Straubing-Th\u00e9rien hierarchy<br>of star-free languages, always falls into the<br>variety [Formula: see text], which is a new variety<br>consisting of specific R-trivial languages. As a<br>consequence, each class of regular languages lying between<br>[Formula: see text] and [Formula: see text] is<br>geometrically closed.","title_summary":" Geometrically Closed Positive Varieties of<br>Star-Free Languages","x":-22.2640094757,"y":45.5245857239,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.2640094757,"tsne_y":45.5245857239,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"ovksvqb4","source_x":"PMC","title":"[Formula: see text] Is Decidable in [Formula: see text]","doi":"10.1007\/978-3-030-40608-0_8","abstract":"We show that it is decidable whether or not a relation on the reals definable in the structure [Formula: see text] can be defined in the structure [Formula: see text]. This result is achieved by obtaining a topological characterization of [Formula: see text]-definable relations in the family of [Formula: see text]-definable relations and then by following Muchnik\u2019s approach of showing that this characterization can be expressed in the logic of [Formula: see text].","publish_time":1578355200000,"author_summary":" B\u00e8s, Alexis; Choffrut, Christian","abstract_summary":" We show that it is decidable whether or not a<br>relation on the reals definable in the structure<br>[Formula: see text] can be defined in the structure<br>[Formula: see text]. This result is achieved by obtaining<br>a topological characterization of [Formula:<br>see text]-definable relations in the family of<br>[Formula: see text]-definable relations and then by<br>following Muchnik\u2019s approach of showing that this<br>characterization can be expressed in the logic of [Formula: see<br>text].","title_summary":" [Formula: see text] Is Decidable in [Formula:<br>see text]","x":-23.2968463898,"y":44.6174049377,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.2968463898,"tsne_y":44.6174049377,"subcluster":34,"subcluster_description":"Text]On Collapsing Prefix Normal","shape":"p"},{"cord_uid":"xus3wo5m","source_x":"PMC","title":"Expressiveness and Conciseness of Timed Automata for the Verification of Stochastic Models","doi":"10.1007\/978-3-030-40608-0_11","abstract":"Timed Automata are a well-known formalism for specifying timed behaviours. In this paper we are concerned with Timed Automata for the specification of timed behaviour of Continuous Time Markov Chains (CTMC), as used in the stochastic temporal logic CSL[Formula: see text]. A timed path formula of CSL[Formula: see text] is specified by a Deterministic Timed Automaton (DTA) that features two kinds of transitions: synchronizing transitions (triggered by CTMC transitions) and autonomous transitions (triggered when a clock reaches a given threshold). Other definitions of CSL[Formula: see text] are based on DTAs that do not include autonomous transitions. This raises the natural question: do autonomous transitions enhance expressiveness and\/or conciseness of DTAs? We prove that this is the case and we provide a syntactical characterization of DTAs for which autonomous transitions do not add expressive power, but allow one to define exponentially more concise DTAs.","publish_time":1578355200000,"author_summary":" Donatelli, Susanna; Haddad, Serge","abstract_summary":" Timed Automata are a well-known formalism for<br>specifying timed behaviours. In this paper we are<br>concerned with Timed Automata for the specification of<br>timed behaviour of Continuous Time Markov Chains<br>(CTMC), as used in the stochastic temporal logic<br>CSL[Formula: see text]. A timed path formula of CSL[Formula:<br>see text] is specified by a Deterministic Timed<br>Automaton (DTA) that features two kinds of transitions:<br>synchronizing transitions (triggered by CTMC transitions)<br>and autonomous transitions (triggered when a<br>clock reaches a given threshold). Other definitions<br>of CSL[Formula: see text] are based on DTAs that do<br>not include autonomous transitions. This raises<br>the natural...","title_summary":" Expressiveness and Conciseness of Timed<br>Automata for the Verification of Stochastic Models","x":-26.6932106018,"y":44.3862342834,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6932106018,"tsne_y":44.3862342834,"subcluster":36,"subcluster_description":"Parametric Component-Based Systemsproceedings Eighth","shape":"p"},{"cord_uid":"zgrabaiw","source_x":"PMC","title":"On Collapsing Prefix Normal Words","doi":"10.1007\/978-3-030-40608-0_29","abstract":"Prefix normal words are binary words in which each prefix has at least the same number of [Formula: see text]s as any factor of the same length. Firstly introduced in 2011, the problem of determining the index (amount of equivalence classes for a given word length) of the prefix normal equivalence relation is still open. In this paper, we investigate two aspects of the problem, namely prefix normal palindromes and so-called collapsing words (extending the notion of critical words). We prove characterizations for both the palindromes and the collapsing words and show their connection. Based on this, we show that still open problems regarding prefix normal words can be split into certain subproblems.","publish_time":1578355200000,"author_summary":" Fleischmann, Pamela; Kulczynski, Mitja;<br>Nowotka, Dirk; Poulsen, Danny B\u00f8gsted","abstract_summary":" Prefix normal words are binary words in which<br>each prefix has at least the same number of [Formula:<br>see text]s as any factor of the same length. Firstly<br>introduced in 2011, the problem of determining the index<br>(amount of equivalence classes for a given word length)<br>of the prefix normal equivalence relation is<br>still open. In this paper, we investigate two aspects<br>of the problem, namely prefix normal palindromes<br>and so-called collapsing words (extending the<br>notion of critical words). We prove<br>characterizations for both the palindromes and the collapsing<br>words and show their connection. Based on this, we<br>show that...","title_summary":" On Collapsing Prefix Normal Words","x":-23.3148975372,"y":44.6756820679,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.3148975372,"tsne_y":44.6756820679,"subcluster":34,"subcluster_description":"Text]On Collapsing Prefix Normal","shape":"p"},{"cord_uid":"41156h45","source_x":"PMC","title":"Windable Heads and Recognizing NL with Constant Randomness","doi":"10.1007\/978-3-030-40608-0_12","abstract":"Every language in NL has a k-head two-way nondeterministic finite automaton (2nfa([Formula: see text])) recognizing it. It is known how to build a constant-space verifier algorithm from a 2nfa([Formula: see text]) for the same language with constant-randomness, but with error probability [Image: see text] that can not be reduced further by repetition. We have defined the unpleasant characteristic of the heads that causes the high error as the property of being \u201cwindable\u201d. With a tweak on the previous verification algorithm, the error is improved to [Image: see text], where [Formula: see text] is the number of windable heads. Using this new algorithm, a subset of languages in NL that have a 2nfa([Formula: see text]) recognizer with [Formula: see text] can be verified with arbitrarily reducible error using constant space and randomness.","publish_time":1578355200000,"author_summary":" Gezer, Mehmet Utkan","abstract_summary":" Every language in NL has a k-head two-way<br>nondeterministic finite automaton (2nfa([Formula: see text]))<br>recognizing it. It is known how to build a constant-space<br>verifier algorithm from a 2nfa([Formula: see text]) for<br>the same language with constant-randomness, but<br>with error probability [Image: see text] that can<br>not be reduced further by repetition. We have<br>defined the unpleasant characteristic of the heads<br>that causes the high error as the property of being<br>\u201cwindable\u201d. With a tweak on the previous verification<br>algorithm, the error is improved to [Image: see text],<br>where [Formula: see text] is the number of windable<br>heads. Using this...","title_summary":" Windable Heads and Recognizing NL with<br>Constant Randomness","x":-23.4095039368,"y":44.1363525391,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.4095039368,"tsne_y":44.1363525391,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"1v41ya0m","source_x":"PMC","title":"Input Strictly Local Tree Transducers","doi":"10.1007\/978-3-030-40608-0_26","abstract":"We generalize the class of input strictly local string functions (Chandlee et al. 2014) to tree functions. We show they are characterized by a subclass of frontier-to-root, deterministic, linear tree transducers. We motivate this class from the study of natural language as it provides a way to distinguish local syntactic processes from non-local ones. We give examples illustrating this kind of analysis.","publish_time":1578355200000,"author_summary":" Ji, Jing; Heinz, Jeffrey","abstract_summary":" We generalize the class of input strictly local<br>string functions (Chandlee et al. 2014) to tree<br>functions. We show they are characterized by a subclass of<br>frontier-to-root, deterministic, linear tree transducers. We<br>motivate this class from the study of natural language as<br>it provides a way to distinguish local syntactic<br>processes from non-local ones. We give examples<br>illustrating this kind of analysis.","title_summary":" Input Strictly Local Tree Transducers","x":-23.9226341248,"y":45.7778167725,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.9226341248,"tsne_y":45.7778167725,"subcluster":16,"subcluster_description":"Strictly Local Tree Transducersequivalence","shape":"p"},{"cord_uid":"bdruuzbq","source_x":"PMC","title":"Pebble-Intervals Automata and FO[Formula: see text] with Two Orders","doi":"10.1007\/978-3-030-40608-0_14","abstract":"We introduce a novel automata model, which we call pebble-intervals automata (PIA), and study its power and closure properties. PIAs are tailored for a decidable fragment of FO that is important for reasoning about structures that use data values from infinite domains: the two-variable fragment with one total preorder and its induced successor relation, one linear order, and an arbitrary number of unary relations. We prove that the string projection of every language of data words definable in the logic is accepted by a pebble-intervals automaton [Image: see text], and obtain as a corollary an automata-theoretic proof of the [Formula: see text] upper bound for finite satisfiability due to Schwentick and Zeume.","publish_time":1578355200000,"author_summary":" Labai, Nadia; Kotek, Tomer; Ortiz, Magdalena;<br>Veith, Helmut","abstract_summary":" We introduce a novel automata model, which we<br>call pebble-intervals automata (PIA), and study<br>its power and closure properties. PIAs are<br>tailored for a decidable fragment of FO that is important<br>for reasoning about structures that use data<br>values from infinite domains: the two-variable<br>fragment with one total preorder and its induced<br>successor relation, one linear order, and an arbitrary<br>number of unary relations. We prove that the string<br>projection of every language of data words definable in the<br>logic is accepted by a pebble-intervals automaton<br>[Image: see text], and obtain as a corollary an<br>automata-theoretic proof of the [Formula:...","title_summary":" Pebble-Intervals Automata and FO[Formula:<br>see text] with Two Orders","x":-24.6381244659,"y":44.5099754333,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.6381244659,"tsne_y":44.5099754333,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"v4bjjpku","source_x":"PMC","title":"The Power of Programs over Monoids in [Image: see text]","doi":"10.1007\/978-3-030-40608-0_22","abstract":"The model of programs over (finite) monoids, introduced by Barrington and Th\u00e9rien, gives an interesting way to characterise the circuit complexity class [Image: see text] and its subclasses and showcases deep connections with algebraic automata theory. In this article, we investigate the computational power of programs over monoids in [Image: see text], a small variety of finite aperiodic monoids. First, we give a fine hierarchy within the class of languages recognised by programs over monoids from [Image: see text], based on the length of programs but also some parametrisation of [Image: see text]. Second, and most importantly, we make progress in understanding what regular languages can be recognised by programs over monoids in [Image: see text]. We show that those programs actually can recognise all languages from a class of restricted dot-depth one languages, using a non-trivial trick, and conjecture that this class suffices to characterise the regular languages recognised by programs over monoids in [Image: see text].","publish_time":1578355200000,"author_summary":" Grosshans, Nathan","abstract_summary":" The model of programs over (finite) monoids,<br>introduced by Barrington and Th\u00e9rien, gives an<br>interesting way to characterise the circuit complexity<br>class [Image: see text] and its subclasses and<br>showcases deep connections with algebraic automata<br>theory. In this article, we investigate the<br>computational power of programs over monoids in [Image: see<br>text], a small variety of finite aperiodic monoids.<br>First, we give a fine hierarchy within the class of<br>languages recognised by programs over monoids from<br>[Image: see text], based on the length of programs but<br>also some parametrisation of [Image: see text].<br>Second, and most importantly, we make progress...","title_summary":" The Power of Programs over Monoids in [Image:<br>see text]","x":-23.3621063232,"y":44.3912086487,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.3621063232,"tsne_y":44.3912086487,"subcluster":35,"subcluster_description":"Semi-Simple Splicing Systemsthe State","shape":"p"},{"cord_uid":"j0f0e02w","source_x":"PMC","title":"Event-B: From Systems to Sub-systems Modeling","doi":"10.1007\/978-3-030-48077-6_35","abstract":"Event-B [3] is a formal method that allows the verification of critical systems properties.","publish_time":1587513600000,"author_summary":" Kraibi, Kenza","abstract_summary":" Event-B [3] is a formal method that allows the<br>verification of critical systems properties.","title_summary":" Event-B: From Systems to Sub-systems Modeling","x":-28.3945484161,"y":43.3802604675,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.3945484161,"tsne_y":43.3802604675,"subcluster":12,"subcluster_description":"Automotive Light System","shape":"p"},{"cord_uid":"22ejwcft","source_x":"PMC","title":"Towards a Shared Specification Repository","doi":"10.1007\/978-3-030-48077-6_22","abstract":"Many formal methods research communities lack a shared set of benchmarks. As a result, many research articles in the past have evaluated new techniques on specifications that are specifically tailored to the problem or not publicly available. While this is great for proving the concept in question, it does not offer any insights on how it performs on real-world examples. Additionally, with machine learning techniques gaining more popularity, a larger set of public specifications is required. In this paper, we present our public set of B machines and urge contribution. As we think this to be an issue in other communities in scope of the ABZ as well, we are also interested in specifications expressed in other formalisms, for example Alloy, TLA[Formula: see text] or Z.","publish_time":1587513600000,"author_summary":" K\u00f6rner, Philipp; Leuschel, Michael;<br>Dunkelau, Jannik","abstract_summary":" Many formal methods research communities lack<br>a shared set of benchmarks. As a result, many<br>research articles in the past have evaluated new<br>techniques on specifications that are specifically<br>tailored to the problem or not publicly available. While<br>this is great for proving the concept in question, it<br>does not offer any insights on how it performs on<br>real-world examples. Additionally, with machine<br>learning techniques gaining more popularity, a larger<br>set of public specifications is required. In this<br>paper, we present our public set of B machines and urge<br>contribution. As we think this to be an issue in other...","title_summary":" Towards a Shared Specification Repository","x":-25.8699607849,"y":42.3842048645,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.8699607849,"tsne_y":42.3842048645,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"unsum1zz","source_x":"PMC","title":"Formal Distributed Protocol Development for Reservation of Railway Sections","doi":"10.1007\/978-3-030-48077-6_14","abstract":"The decentralisation of railway signalling systems has the potential to increase railway network capacity, availability and reduce maintenance costs. Given the safety-critical nature of railway signalling and the complexity of novel distributed signalling solutions, their safety should be guaranteed by using thorough system validation methods. In this paper, we present a rigorous formal development and verification of a distributed protocol for reservation of railway sections, which we believe could deliver benefits of a decentralised signalling while ensuring safety and liveness properties. For the formal distributed protocol development and verification, we devised a multifaceted framework, which aims to reduce modelling and verification effort, while still providing complementary techniques to study protocol from all relevant perspectives.","publish_time":1587513600000,"author_summary":" Stankaitis, Paulius; Iliasov, Alexei;<br>Kobayashi, Tsutomu; A\u00eft-Ameur, Yamine; Ishikawa,<br>Fuyuki; Romanovsky, Alexander","abstract_summary":" The decentralisation of railway signalling<br>systems has the potential to increase railway network<br>capacity, availability and reduce maintenance costs.<br>Given the safety-critical nature of railway<br>signalling and the complexity of novel distributed<br>signalling solutions, their safety should be guaranteed<br>by using thorough system validation methods. In<br>this paper, we present a rigorous formal<br>development and verification of a distributed protocol for<br>reservation of railway sections, which we believe could<br>deliver benefits of a decentralised signalling while<br>ensuring safety and liveness properties. For the formal<br>distributed protocol development and verification, we<br>devised a multifaceted framework, which aims to reduce<br>modelling and...","title_summary":" Formal Distributed Protocol Development for<br>Reservation of Railway Sections","x":-28.9994297028,"y":43.0318870544,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.9994297028,"tsne_y":43.0318870544,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"bwzzsek6","source_x":"PMC","title":"Modelling an Automotive Software-Intensive System with Adaptive Features Using ASMETA","doi":"10.1007\/978-3-030-48077-6_25","abstract":"In the context of automotive domain, modern control systems are software-intensive and have adaptive features to provide safety and comfort. These software-based features demand software engineering approaches and formal methods that are able to guarantee correct operation, since malfunctions may cause harm\/damage. Adaptive Exterior Light and the Speed Control Systems are examples of software-intensive systems that equip modern cars. We have used the Abstract State Machines to model the behaviour of both control systems. Each model has been developed through model refinement, following the incremental way in which functional requirements are given. We used the ASMETA tool-set to support the simulation of the abstract models, their validation against the informal requirements, and the verification of behavioural properties. In this paper, we discuss our modelling, validation and verification strategies, and the results (in terms of features addressed and not) of our activities. In particular, we provide insights on how we addressed the adaptive features (the adaptive high beam headlights and the adaptive cruise control) by explicitly modelling their software control loops according to the MAPE-K (Monitor-Analyse-Plan-Execute over a shared Knowledge) reference control model for self-adaptive systems.","publish_time":1587513600000,"author_summary":" Arcaini, Paolo; Bonfanti, Silvia;<br>Gargantini, Angelo; Riccobene, Elvinia; Scandurra,<br>Patrizia","abstract_summary":" In the context of automotive domain, modern<br>control systems are software-intensive and have<br>adaptive features to provide safety and comfort. These<br>software-based features demand software engineering<br>approaches and formal methods that are able to guarantee<br>correct operation, since malfunctions may cause<br>harm\/damage. Adaptive Exterior Light and the Speed Control<br>Systems are examples of software-intensive systems<br>that equip modern cars. We have used the Abstract<br>State Machines to model the behaviour of both control<br>systems. Each model has been developed through model<br>refinement, following the incremental way in which<br>functional requirements are given. We used the ASMETA<br>tool-set to support the...","title_summary":" Modelling an Automotive Software-Intensive<br>System with Adaptive Features Using ASMETA","x":-28.6853618622,"y":43.4102516174,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.6853618622,"tsne_y":43.4102516174,"subcluster":12,"subcluster_description":"Automotive Light System","shape":"p"},{"cord_uid":"v5w4veh2","source_x":"PMC","title":"Verifying SGAC Access Control Policies: A Comparison of ProB, Alloy and Z3","doi":"10.1007\/978-3-030-48077-6_15","abstract":"This paper describes the formalisation of SGAC access control policies using Z3 and then we compare the performance with ProB and Alloy. SGAC is an attribute-based, fine-grain access control model that uses acyclic subject and resource graphs to provide rule inheritance and streamline policy specification. To ensure patient privacy and safety, four types of properties are checked: accessibility, availability, contextuality and rule effectiveness. Automatic translation of SGAC policies into each specification language has been defined. ProB offers the best verification performances, by two orders of magnitude. The performances of Alloy and Z3 are similar.","publish_time":1587513600000,"author_summary":" de Azevedo Oliveira, Diego; Frappier, Marc","abstract_summary":" This paper describes the formalisation of SGAC<br>access control policies using Z3 and then we compare<br>the performance with ProB and Alloy. SGAC is an<br>attribute-based, fine-grain access control model that uses<br>acyclic subject and resource graphs to provide rule<br>inheritance and streamline policy specification. To<br>ensure patient privacy and safety, four types of<br>properties are checked: accessibility, availability,<br>contextuality and rule effectiveness. Automatic<br>translation of SGAC policies into each specification<br>language has been defined. ProB offers the best<br>verification performances, by two orders of magnitude. The<br>performances of Alloy and Z3 are similar.","title_summary":" Verifying SGAC Access Control Policies: A<br>Comparison of ProB, Alloy and Z3","x":-26.9270114899,"y":43.4483566284,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.9270114899,"tsne_y":43.4483566284,"subcluster":23,"subcluster_description":"Finite State Processesa Fast","shape":"p"},{"cord_uid":"1z454yuh","source_x":"PMC","title":"Event-B-Supported Choreography-Defined Communicating Systems: Correctness and Completeness","doi":"10.1007\/978-3-030-48077-6_11","abstract":"Choreographies prescribe the rendez-vous synchronisation of messages in a communicating system. Such a system is called realisable, if the traces of the prescribed communication coincide with those of the asynchronous system of peers, where the communication channels either use FIFO queues or multiset mailboxes. It has recently been shown that realisability can be characterised by two necessary conditions that together are also sufficient, whereas in general the synchronisability of communicating peers is undecidable. The sufficiency of the conditions permits the construction of correct communicating systems; their necessity shows that all choreography-defined communicating system can be obtained in this way. This article provides an integrated framework based on Event-B for such a construction with a major emphasis on Rodin-based proofs of correctness and completeness.","publish_time":1587513600000,"author_summary":" Benyagoub, Sarah; A\u00eft-Ameur, Yamine; Schewe,<br>Klaus-Dieter","abstract_summary":" Choreographies prescribe the rendez-vous<br>synchronisation of messages in a communicating system. Such a<br>system is called realisable, if the traces of the<br>prescribed communication coincide with those of the<br>asynchronous system of peers, where the communication<br>channels either use FIFO queues or multiset mailboxes.<br>It has recently been shown that realisability can<br>be characterised by two necessary conditions<br>that together are also sufficient, whereas in<br>general the synchronisability of communicating peers<br>is undecidable. The sufficiency of the<br>conditions permits the construction of correct<br>communicating systems; their necessity shows that all<br>choreography-defined communicating system can be obtained in this<br>way. This...","title_summary":" Event-B-Supported Choreography-Defined<br>Communicating Systems: Correctness and Completeness","x":-27.8824100494,"y":43.0254020691,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.8824100494,"tsne_y":43.0254020691,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"c41s7rb0","source_x":"PMC","title":"Formally Verified Architecture Patterns of Hybrid Systems Using Proof and Refinement with Event-B","doi":"10.1007\/978-3-030-48077-6_12","abstract":"Cyber-Physical Systems (CPS) play a central role in modern days technology. From simple thermostat controllers to more advanced autonomous cars, their versatility makes them perfect candidates for many applications, in particular for safety critical ones. Thus, their certification is a key issue and formal methods are good candidates to assess safety and produce associated certificates. Hybrid systems show continuous-time dynamics depending on mode that is required in several stages of the architecture of Cyber-Physical Systems. Our work addresses the problem of formally verifying hybrid systems using refinement and proof with Event-B. Our previous work [14] presented formally verified generic architecture patterns for designing centralised hybrid systems, based on our generic approach [15]. We extend this work and give a formally verified architecture pattern aimed at modelling distributed hybrid systems, featuring multiple plants and multiple controllers. We validate the approach and illustrate the use of the defined pattern on an extension of a very common case study, borrowed from literature.","publish_time":1587513600000,"author_summary":" Dupont, Guillaume; A\u00eft-Ameur, Yamine;<br>Pantel, Marc; Singh, Neeraj K.","abstract_summary":" Cyber-Physical Systems (CPS) play a central<br>role in modern days technology. From simple<br>thermostat controllers to more advanced autonomous cars,<br>their versatility makes them perfect candidates for<br>many applications, in particular for safety<br>critical ones. Thus, their certification is a key issue<br>and formal methods are good candidates to assess<br>safety and produce associated certificates. Hybrid<br>systems show continuous-time dynamics depending on<br>mode that is required in several stages of the<br>architecture of Cyber-Physical Systems. Our work addresses<br>the problem of formally verifying hybrid systems<br>using refinement and proof with Event-B. Our<br>previous work [14] presented formally verified generic<br>architecture...","title_summary":" Formally Verified Architecture Patterns of<br>Hybrid Systems Using Proof and Refinement with<br>Event-B","x":-28.1675338745,"y":43.5265808105,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.1675338745,"tsne_y":43.5265808105,"subcluster":13,"subcluster_description":"Hybrid Programs","shape":"p"},{"cord_uid":"cv2vph45","source_x":"PMC","title":"A Correct by Construction Approach for the Modeling and the Verification of Cyber-Physical Systems in Event-B","doi":"10.1007\/978-3-030-48077-6_31","abstract":"Cyber-Physical Systems (CPSs) connect the real world to software systems through a network of sensors and actuators: physical and discrete components interact in complex ways by involving different spatial and temporal scales. One of the most common architectures for CPSs is a discrete software controller which interacts with its physical environment in a closed-loop schema where input from sensors is processed and output is generated and communicated to actuators. We are concerned with the construction and verification of the correctness of such discrete controller using a correct by construction approach, which requires correct integration of discrete and continuous models.","publish_time":1587513600000,"author_summary":" Afendi, Meryem","abstract_summary":" Cyber-Physical Systems (CPSs) connect the<br>real world to software systems through a network of<br>sensors and actuators: physical and discrete<br>components interact in complex ways by involving<br>different spatial and temporal scales. One of the most<br>common architectures for CPSs is a discrete software<br>controller which interacts with its physical environment<br>in a closed-loop schema where input from sensors<br>is processed and output is generated and<br>communicated to actuators. We are concerned with the<br>construction and verification of the correctness of such<br>discrete controller using a correct by construction<br>approach, which requires correct integration of<br>discrete and continuous models.","title_summary":" A Correct by Construction Approach for the<br>Modeling and the Verification of Cyber-Physical<br>Systems in Event-B","x":-28.3987751007,"y":43.5190315247,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.3987751007,"tsne_y":43.5190315247,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"ihmcol1u","source_x":"PMC","title":"Existence Proof Obligations for Constraints, Properties and Invariants in Atelier B","doi":"10.1007\/978-3-030-48077-6_20","abstract":"Proof obligations of the B method and of Event B use predicates in the Constraints, Sets, Properties and Invariant clauses as hypotheses in proof obligations. A contradiction in these predicates results in trivially valid proof obligations and essentially voids the development. A textbook on the B method [3] presents three \u201cexistence proof obligations\u201d to show the satisfiability of the Constraints, Properties and Invariant clauses as soon as they are stated in a component. Together with new existence proof obligations for refinement, this prevents the introduction of such contradictions in the refinement chain. This paper presents a detailed formalization of these existence proof obligations, specifying their implementation in Atelier B.","publish_time":1587513600000,"author_summary":" Ru\u00edz Barradas, H\u00e9ctor; Burdy, Lilian;<br>D\u00e9harbe, David","abstract_summary":" Proof obligations of the B method and of Event B<br>use predicates in the Constraints, Sets,<br>Properties and Invariant clauses as hypotheses in proof<br>obligations. A contradiction in these predicates results in<br>trivially valid proof obligations and essentially voids<br>the development. A textbook on the B method [3]<br>presents three \u201cexistence proof obligations\u201d to show<br>the satisfiability of the Constraints,<br>Properties and Invariant clauses as soon as they are stated<br>in a component. Together with new existence proof<br>obligations for refinement, this prevents the<br>introduction of such contradictions in the refinement<br>chain. This paper presents a detailed formalization<br>of these...","title_summary":" Existence Proof Obligations for Constraints,<br>Properties and Invariants in Atelier B","x":-25.7658424377,"y":44.7461280823,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.7658424377,"tsne_y":44.7461280823,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"74u33t30","source_x":"PMC","title":"Exploring the Concept of Abstract State Machines for System Runtime Enforcement","doi":"10.1007\/978-3-030-48077-6_18","abstract":"Modern intelligent software systems are rapidly growing in complexity and scale, and many real usage scenarios might be impossible to reproduce and validate at design-time. As envisioned by the Models@run.time research community, the use of formal models at runtime are fundamental to address this challenge. In this paper, we explore the concept of ASM@run.time and put this definition into the context of the runtime enforcement technique to address the runtime assurance of software systems. This is a work-in-progress research line.","publish_time":1587513600000,"author_summary":" Riccobene, Elvinia; Scandurra, Patrizia","abstract_summary":" Modern intelligent software systems are<br>rapidly growing in complexity and scale, and many real<br>usage scenarios might be impossible to reproduce and<br>validate at design-time. As envisioned by the<br>Models@run.time research community, the use of formal models at<br>runtime are fundamental to address this challenge. In<br>this paper, we explore the concept of ASM@run.time<br>and put this definition into the context of the<br>runtime enforcement technique to address the runtime<br>assurance of software systems. This is a<br>work-in-progress research line.","title_summary":" Exploring the Concept of Abstract State<br>Machines for System Runtime Enforcement","x":-27.3962974548,"y":43.1320571899,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.3962974548,"tsne_y":43.1320571899,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"aql8mzdg","source_x":"PMC","title":"Formal Verification of Interoperability Between Future Network Architectures Using Alloy","doi":"10.1007\/978-3-030-48077-6_4","abstract":"The Internet is composed of many interconnected, interoperating networks. With the recent advances in Future Internet design, multiple new network architectures, especially Information-Centric Networks (ICN) have emerged. Given the ubiquity of networks based on the Internet Protocol (IP), it is likely that we will have a number of different interconnecting network domains with different architectures, including ICNs. Their interoperability is important, but at the same time difficult to prove. A formal tool can be helpful for such analysis. ICNs have a number of unique characteristics, warranting formal analysis, establishing properties that go beyond, and are different from, what have been used in the state-of-the-art because ICN operates at the level of content names rather than node addresses. We need to focus on node-to-content reachability, rather than node-to-node reachability. In this paper, we present a formal approach to model and analyze information-centric interoperability (ICI). We use Alloy Analyzer\u2019s model finding approach to verify properties expressed as invariants for information-centric services (both pull and push-based models) including content reachability and returnability. We extend our use of Alloy to model counting, to quantitatively analyze failure and mobility properties. We present a formally-verified ICI framework that allows for seamless interoperation among a multitude of network architectures. We also report on the impact of domain types, routing policies, and binding techniques on the probability of content reachability and returnability, under failures and mobility.","publish_time":1587513600000,"author_summary":" Jahanian, Mohammad; Chen, Jiachen;<br>Ramakrishnan, K. K.","abstract_summary":" The Internet is composed of many<br>interconnected, interoperating networks. With the recent<br>advances in Future Internet design, multiple new<br>network architectures, especially<br>Information-Centric Networks (ICN) have emerged. Given the<br>ubiquity of networks based on the Internet Protocol<br>(IP), it is likely that we will have a number of<br>different interconnecting network domains with<br>different architectures, including ICNs. Their<br>interoperability is important, but at the same time difficult to<br>prove. A formal tool can be helpful for such analysis.<br>ICNs have a number of unique characteristics,<br>warranting formal analysis, establishing properties<br>that go beyond, and are different from, what have<br>been...","title_summary":" Formal Verification of Interoperability<br>Between Future Network Architectures Using Alloy","x":-28.1753463745,"y":42.6310844421,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.1753463745,"tsne_y":42.6310844421,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"gp5ywdjb","source_x":"PMC","title":"Automatic Generation of DistAlgo Programs from Event-B Models","doi":"10.1007\/978-3-030-48077-6_34","abstract":"The development of distributed algorithms offers challenges in verifying that they meet their specifications. The correct-by-construction approach consists in developing a model of the algorithm before transforming this model into a program.","publish_time":1587513600000,"author_summary":" Grall, Alexis","abstract_summary":" The development of distributed algorithms<br>offers challenges in verifying that they meet their<br>specifications. The correct-by-construction approach<br>consists in developing a model of the algorithm before<br>transforming this model into a program.","title_summary":" Automatic Generation of DistAlgo Programs<br>from Event-B Models","x":-28.1049213409,"y":43.4107818604,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.1049213409,"tsne_y":43.4107818604,"subcluster":13,"subcluster_description":"Hybrid Programs","shape":"p"},{"cord_uid":"q262i5wy","source_x":"PMC","title":"A Formal Approach for the Modeling of High-Level Architectures Aligned with System Requirements","doi":"10.1007\/978-3-030-48077-6_33","abstract":"IRT Railenium (http:\/\/railenium.eu\/fr\/) is a test and applied research center for the rail industry in France. One of its three R&D and innovation programs aims in particular to provide the technological tools and bricks necessary for the development of the Autonomous Train.","publish_time":1587513600000,"author_summary":" Bougacha, Racem","abstract_summary":" IRT Railenium (http:\/\/railenium.eu\/fr\/) is a<br>test and applied research center for the rail<br>industry in France. One of its three R&D and innovation<br>programs aims in particular to provide the<br>technological tools and bricks necessary for the development<br>of the Autonomous Train.","title_summary":" A Formal Approach for the Modeling of<br>High-Level Architectures Aligned with System<br>Requirements","x":-28.7463531494,"y":43.2481422424,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.7463531494,"tsne_y":43.2481422424,"subcluster":12,"subcluster_description":"Automotive Light System","shape":"p"},{"cord_uid":"wmnq6n8w","source_x":"PMC","title":"A Framework for Critical Interactive System Formal Modelling and Analysis","doi":"10.1007\/978-3-030-48077-6_36","abstract":"Interactive system development does not follow the same life cycle as other system developments. The essential differences lie in the iterative nature of such system development. Throughout iterations, the requirements undergo many changes due to the evolution of customer\u2019s needs and user feedback after experiencing prototypes. The challenge is tougher in the case of critical HCI (aircraft cockpits, medical systems, nuclear power plant etc.). Indeed, critical HCI requires to be designed and built such that safety and security requirements are thoroughly fulfilled. This paper presents a novel development framework featuring formal verification and validation of critical interactive systems at modelling level. It identifies the several challenges of the interactive system development and settles down the main objectives. Furthermore, it sketches the most important traits of the proposed approach to circumvent the enumerated challenges. Hence, we discuss the importance of the pivot language Fluid, the domain theory specific to interactive systems and their modelling using Event-B.","publish_time":1587513600000,"author_summary":" Mendil, Isma\u00efl","abstract_summary":" Interactive system development does not<br>follow the same life cycle as other system<br>developments. The essential differences lie in the iterative<br>nature of such system development. Throughout<br>iterations, the requirements undergo many changes due to<br>the evolution of customer\u2019s needs and user<br>feedback after experiencing prototypes. The challenge<br>is tougher in the case of critical HCI (aircraft<br>cockpits, medical systems, nuclear power plant etc.).<br>Indeed, critical HCI requires to be designed and built<br>such that safety and security requirements are<br>thoroughly fulfilled. This paper presents a novel<br>development framework featuring formal verification and<br>validation of critical interactive systems at modelling...","title_summary":" A Framework for Critical Interactive System<br>Formal Modelling and Analysis","x":-29.3210716248,"y":43.3714141846,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-29.3210716248,"tsne_y":43.3714141846,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"5wyyb6ez","source_x":"PMC","title":"Analysing ProB\u2019s Constraint Solving Backends: What Do They Know? Do They Know Things? Let\u2019s Find Out!","doi":"10.1007\/978-3-030-48077-6_8","abstract":"We evaluate the strengths and weaknesses of different backends of the ProB constraint solver. For this, we train a random forest over a database of constraints to classify whether a backend is able to find a solution within a given amount of time or answers unknown. The forest is then analysed in regards of feature importances to determine subsets of the B language in which the respective backends excel or lack for performance. The results are compared to our initial assumptions over each backend\u2019s performance in these subsets based on personal experiences. While we do employ classifiers, we do not aim for a good predictor, but are rather interested in analysis of the classifier\u2019s learned knowledge over the utilised B constraints. The aim is to strengthen our knowledge of the different tools at hand by finding subsets of the B language in which a backend performs better than others.","publish_time":1587513600000,"author_summary":" Dunkelau, Jannik; Schmidt, Joshua; Leuschel,<br>Michael","abstract_summary":" We evaluate the strengths and weaknesses of<br>different backends of the ProB constraint solver. For<br>this, we train a random forest over a database of<br>constraints to classify whether a backend is able to find a<br>solution within a given amount of time or answers<br>unknown. The forest is then analysed in regards of<br>feature importances to determine subsets of the B<br>language in which the respective backends excel or lack<br>for performance. The results are compared to our<br>initial assumptions over each backend\u2019s performance<br>in these subsets based on personal experiences.<br>While we do employ classifiers, we do not...","title_summary":" Analysing ProB\u2019s Constraint Solving<br>Backends: What Do They Know? Do They Know Things? Let\u2019s<br>Find Out!","x":-25.2642478943,"y":42.0694007874,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.2642478943,"tsne_y":42.0694007874,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"zmfzkrdp","source_x":"PMC","title":"A Logic for Reflective ASMs","doi":"10.1007\/978-3-030-48077-6_7","abstract":"Reflective algorithms are algorithms that can modify their own behaviour. Recently a behavioural theory of reflective algorithms has been developed, which shows that they are captured by reflective abstract state machines (rASMs). Reflective ASMs exploit extended states that include an updatable representation of the ASM signature and rules to be executed by the machine in that state. Updates to the representation of ASM signatures and rules are realised by means of a sophisticated tree algebra defined in the background of the rASM. In this paper the theory is taken further by an extension of the logic of ASMs to capture inferences on rASMs. The key is the introduction of terms that are interpreted by ASM rules stored in some location. We show that fragments of the logic with a fixed bound on the number of steps preserve completeness, whereas the full run-logic for rASMs becomes incomplete.","publish_time":1587513600000,"author_summary":" Schewe, Klaus-Dieter; Ferrarotti, Flavio","abstract_summary":" Reflective algorithms are algorithms that can<br>modify their own behaviour. Recently a behavioural<br>theory of reflective algorithms has been developed,<br>which shows that they are captured by reflective<br>abstract state machines (rASMs). Reflective ASMs<br>exploit extended states that include an updatable<br>representation of the ASM signature and rules to be executed by<br>the machine in that state. Updates to the<br>representation of ASM signatures and rules are realised by<br>means of a sophisticated tree algebra defined in the<br>background of the rASM. In this paper the theory is taken<br>further by an extension of the logic of ASMs to capture...","title_summary":" A Logic for Reflective ASMs","x":-26.6305770874,"y":43.9338607788,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6305770874,"tsne_y":43.9338607788,"subcluster":33,"subcluster_description":"Netsstructural Reductions Revisiteda Study","shape":"p"},{"cord_uid":"rbuojotp","source_x":"PMC","title":"Structuring the State and Behavior of ASMs: Introducing a Trait-Based Construct for Abstract State Machine Languages","doi":"10.1007\/978-3-030-48077-6_17","abstract":"Abstract State Machine (ASM) theory is a well-known state-based formal method to analyze, verify, and specify software and hardware systems. Nowadays, as in other state-based formal methods, the proposed specification languages for ASMs still lack easy-to-comprehend language constructs for type abstractions to describe reusable and maintainable specifications. Almost all built-in behaviors are implicitly defined inside a concrete ASM language implementation and thus, the behavior is hidden from the language user. In this paper, we present a new ASM syntax extension based on traits, which allows the specifier (language user) to define new type abstractions in the form of structure and behavior definitions to reuse, maintain, structure, and extend the functionality in ASM specifications. We describe the proposed language construct by defining its syntax and semantics. The decision to use a trait-based syntax extension over other object-oriented language constructs like interfaces or mixins was motivated and driven by the results of previously conducted empirical studies. Moreover, we outline details about the implementation of the trait-based syntax extension in our Corinthian Abstract State Machine (CASM) language implementation.","publish_time":1587513600000,"author_summary":" Paulweber, Philipp; Pescosta, Emmanuel;<br>Zdun, Uwe","abstract_summary":" Abstract State Machine (ASM) theory is a<br>well-known state-based formal method to analyze, verify,<br>and specify software and hardware systems.<br>Nowadays, as in other state-based formal methods, the<br>proposed specification languages for ASMs still lack<br>easy-to-comprehend language constructs for type abstractions to<br>describe reusable and maintainable specifications.<br>Almost all built-in behaviors are implicitly defined<br>inside a concrete ASM language implementation and<br>thus, the behavior is hidden from the language user.<br>In this paper, we present a new ASM syntax<br>extension based on traits, which allows the specifier<br>(language user) to define new type abstractions in the<br>form of structure and...","title_summary":" Structuring the State and Behavior of ASMs:<br>Introducing a Trait-Based Construct for Abstract State<br>Machine Languages","x":-26.7399864197,"y":43.6241226196,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7399864197,"tsne_y":43.6241226196,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"mzhv1m2f","source_x":"PMC","title":"ProB and Jupyter for Logic, Set Theory, Theoretical Computer Science and Formal Methods","doi":"10.1007\/978-3-030-48077-6_19","abstract":"We present a tool for using the B language in computational notebooks, based on the Jupyter Notebook interface and the ProB tool. Applications of B notebooks include executable documentation of formal models, interactive manuals, validation reports but also teaching of formal methods, logic, set theory and theoretical computer science. In addition to B and Event-B, the tool supports Z, [Formula: see text] and Alloy.","publish_time":1587513600000,"author_summary":" Gele\u00dfus, David; Leuschel, Michael","abstract_summary":" We present a tool for using the B language in<br>computational notebooks, based on the Jupyter Notebook<br>interface and the ProB tool. Applications of B notebooks<br>include executable documentation of formal models,<br>interactive manuals, validation reports but also teaching<br>of formal methods, logic, set theory and<br>theoretical computer science. In addition to B and Event-B,<br>the tool supports Z, [Formula: see text] and Alloy.","title_summary":" ProB and Jupyter for Logic, Set Theory,<br>Theoretical Computer Science and Formal Methods","x":-25.6511325836,"y":44.8909759521,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.6511325836,"tsne_y":44.8909759521,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"y5h942ar","source_x":"PMC","title":"Programming the CLEARSY Safety Platform with B","doi":"10.1007\/978-3-030-48077-6_9","abstract":"The CLEARSY Safety Platform (CSSP) is aimed at easing the development and the deployment of safety critical applications, up to the safety integrity level 4 (SIL4). It relies on the smart integration of the B formal method, redundant code generation and compilation, and a hardware platform that ensures a safe execution of the software. This paper exposes the programming model of the CSSP used to develop control & command applications based on digital I\/Os.","publish_time":1587513600000,"author_summary":" Lecomte, Thierry","abstract_summary":" The CLEARSY Safety Platform (CSSP) is aimed at<br>easing the development and the deployment of safety<br>critical applications, up to the safety integrity level<br>4 (SIL4). It relies on the smart integration of<br>the B formal method, redundant code generation and<br>compilation, and a hardware platform that ensures a safe<br>execution of the software. This paper exposes the<br>programming model of the CSSP used to develop control &<br>command applications based on digital I\/Os.","title_summary":" Programming the CLEARSY Safety Platform with B","x":-27.9481945038,"y":43.0529212952,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.9481945038,"tsne_y":43.0529212952,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"ry2jpyh3","source_x":"PMC","title":"Integration of iUML-B and UPPAAL Timed Automata for Development of Real-Time Systems with Concurrent Processes","doi":"10.1007\/978-3-030-48077-6_13","abstract":"Developing safety-critical systems requires to consider safety and real-time requirements in addition to functional requirements. Event-B is a formalism that is visualised by iUML-B and supports the development of functional aspects having rich verification and validation tools. However, it lacks well-established support for timing analysis. UPPAAL Timed Automata (UTA), on the other hand, address timing aspects of systems, and enable model checking reachability and timing properties. By integrating iUML-B and UTA, we combine the best verifying and validating practices from the two methods achieving a formal development of systems. We present the mapping for translating iUML-B constructs to UTA. The novel aspect is the use of a multi-process trigger-response pattern to address the modelling and verification of reachability properties of complex systems with concurrent processes. The approach is demonstrated on an airport control system, where timing, fairness, as well as liveness properties play a vital role in proving safety requirements.","publish_time":1587513600000,"author_summary":" Shokri-Manninen, Fatima; Tsiopoulos,<br>Leonidas; Vain, J\u00fcri; Wald\u00e9n, Marina","abstract_summary":" Developing safety-critical systems requires<br>to consider safety and real-time requirements in<br>addition to functional requirements. Event-B is a<br>formalism that is visualised by iUML-B and supports the<br>development of functional aspects having rich<br>verification and validation tools. However, it lacks<br>well-established support for timing analysis. UPPAAL Timed<br>Automata (UTA), on the other hand, address timing<br>aspects of systems, and enable model checking<br>reachability and timing properties. By integrating iUML-B<br>and UTA, we combine the best verifying and<br>validating practices from the two methods achieving a<br>formal development of systems. We present the mapping<br>for translating iUML-B constructs to UTA. The...","title_summary":" Integration of iUML-B and UPPAAL Timed<br>Automata for Development of Real-Time Systems with<br>Concurrent Processes","x":-27.7459220886,"y":43.7098999023,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.7459220886,"tsne_y":43.7098999023,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"d90pot7g","source_x":"PMC","title":"A Characterization of Distributed ASMs with Partial-Order Runs","doi":"10.1007\/978-3-030-48077-6_6","abstract":"To overcome the practical limitations of partial-order runs of \u2018distributed ASMs\u2019 (Abstract State Machines) proposed by Gurevich, we have defined a concept of concurrent runs of multi-agent ASMs and could show that concurrent ASMs capture a natural language-independent axiomatic definition of concurrent algorithms, thus generalising Gurevich\u2019s seminal \u2018Sequential ASM Thesis\u2019 from sequential to concurrent algorithms. However, we remained intrigued by the fact that Blass and Gurevich used partial-order runs of distributed ASMs to explain runs of sequential recursive algorithms. We discovered that also the inverse simulation holds: for every distributed ASM with partial order runs, these runs can be described by runs of a sequential recursive algorithm. This surprising result clarifies the difference in expressivity between partial-order and concurrent runs.","publish_time":1587513600000,"author_summary":" B\u00f6rger, Egon; Schewe, Klaus-Dieter","abstract_summary":" To overcome the practical limitations of<br>partial-order runs of \u2018distributed ASMs\u2019 (Abstract State<br>Machines) proposed by Gurevich, we have defined a concept<br>of concurrent runs of multi-agent ASMs and could<br>show that concurrent ASMs capture a natural<br>language-independent axiomatic definition of concurrent<br>algorithms, thus generalising Gurevich\u2019s seminal<br>\u2018Sequential ASM Thesis\u2019 from sequential to concurrent<br>algorithms. However, we remained intrigued by the fact that<br>Blass and Gurevich used partial-order runs of<br>distributed ASMs to explain runs of sequential recursive<br>algorithms. We discovered that also the inverse simulation<br>holds: for every distributed ASM with partial order<br>runs, these runs can be described...","title_summary":" A Characterization of Distributed ASMs with<br>Partial-Order Runs","x":-26.5341529846,"y":44.1638298035,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5341529846,"tsne_y":44.1638298035,"subcluster":33,"subcluster_description":"Netsstructural Reductions Revisiteda Study","shape":"p"},{"cord_uid":"mlvstj8m","source_x":"PMC","title":"A Verified Low-Level Implementation of the Adaptive Exterior Light and Speed Control System","doi":"10.1007\/978-3-030-48077-6_30","abstract":"In this article, we present an approach to the ABZ 2020 case study, that differs from the ones usually presented at ABZ: Rather than using a (correct-by-construction) approach following a formal method, we use MISRA C for a low-level implementation instead. We strictly adhere to test-driven development for validation, and only afterwards apply model checking using CBMC for verification. In consequence, our realization of the ABZ case study can serve as a baseline reference for comparison, allowing to assess the benefit provided by the various formal modeling languages, methods and tools.","publish_time":1587513600000,"author_summary":" Krings, Sebastian; K\u00f6rner, Philipp;<br>Dunkelau, Jannik; Rutenkolk, Chris","abstract_summary":" In this article, we present an approach to the<br>ABZ 2020 case study, that differs from the ones<br>usually presented at ABZ: Rather than using a<br>(correct-by-construction) approach following a formal method, we use<br>MISRA C for a low-level implementation instead. We<br>strictly adhere to test-driven development for<br>validation, and only afterwards apply model checking using<br>CBMC for verification. In consequence, our<br>realization of the ABZ case study can serve as a baseline<br>reference for comparison, allowing to assess the benefit<br>provided by the various formal modeling languages,<br>methods and tools.","title_summary":" A Verified Low-Level Implementation of the<br>Adaptive Exterior Light and Speed Control System","x":-28.6230792999,"y":43.2728691101,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.6230792999,"tsne_y":43.2728691101,"subcluster":12,"subcluster_description":"Automotive Light System","shape":"p"},{"cord_uid":"eqlsy6ys","source_x":"PMC","title":"VisB: A Lightweight Tool to Visualize Formal Models with SVG Graphics","doi":"10.1007\/978-3-030-48077-6_21","abstract":"Visualization is important to present formal models to domain experts and to spot issues which are hard to formalise or have not been formalised yet. VisB is a visualization plugin for the ProB animator and model checker. VisB enables the user to create simple visualizations for formal models. An important design criterion was to re-use scalable vector graphics (SVG) generated by off-the-shelf graphic editors using a lightweight and easy-to-use annotation mechanism. The visualizations can be used to formal models in B, Event-B, Z, TLA+ and Alloy.","publish_time":1587513600000,"author_summary":" Werth, Michelle; Leuschel, Michael","abstract_summary":" Visualization is important to present formal<br>models to domain experts and to spot issues which are<br>hard to formalise or have not been formalised yet.<br>VisB is a visualization plugin for the ProB animator<br>and model checker. VisB enables the user to create<br>simple visualizations for formal models. An<br>important design criterion was to re-use scalable vector<br>graphics (SVG) generated by off-the-shelf graphic<br>editors using a lightweight and easy-to-use<br>annotation mechanism. The visualizations can be used to<br>formal models in B, Event-B, Z, TLA+ and Alloy.","title_summary":" VisB: A Lightweight Tool to Visualize Formal<br>Models with SVG Graphics","x":-27.6625213623,"y":43.3830757141,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.6625213623,"tsne_y":43.3830757141,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"i9g4b6qq","source_x":"PMC","title":"Modelling and Validating an Automotive System in Classical B and Event-B","doi":"10.1007\/978-3-030-48077-6_27","abstract":"We have modelled parts of the ABZ automotive case study using the B-method. For the early phases of modelling we have used the classical B for software, while for proof we have used Event-B and Rodin. It is maybe surprising that classical B\u2019s machine inclusion mechanism along with operation calls can be used for modular system modelling. Moreover, for one particular style of modelling, the result can then be translated to superposition refinement with event extension in Event-B. Before conducting the proof, we have validated our models using model checking and animation with visualizations. The graphical visualizations were constructed using a new plugin (VisB) which helped uncover errors and transforms our model into an executable, interactive reference specification which can be examined by users without formal background.","publish_time":1587513600000,"author_summary":" Leuschel, Michael; Mutz, Mareike; Werth,<br>Michelle","abstract_summary":" We have modelled parts of the ABZ automotive<br>case study using the B-method. For the early phases<br>of modelling we have used the classical B for<br>software, while for proof we have used Event-B and Rodin.<br>It is maybe surprising that classical B\u2019s machine<br>inclusion mechanism along with operation calls can be<br>used for modular system modelling. Moreover, for<br>one particular style of modelling, the result can<br>then be translated to superposition refinement<br>with event extension in Event-B. Before conducting<br>the proof, we have validated our models using model<br>checking and animation with visualizations. The<br>graphical visualizations were constructed using...","title_summary":" Modelling and Validating an Automotive System<br>in Classical B and Event-B","x":-28.7172431946,"y":43.4291000366,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.7172431946,"tsne_y":43.4291000366,"subcluster":12,"subcluster_description":"Automotive Light System","shape":"p"},{"cord_uid":"tzx24fob","source_x":"PMC","title":"Modelling Hybrid Programs with Event-B","doi":"10.1007\/978-3-030-48077-6_10","abstract":"Hybrid systems are one of the most common mathematical models for Cyber-Physical Systems (CPSs). They combine discrete dynamics represented by state machines or finite automata with continuous behaviors represented by differential equations. The measurement of continuous behaviors is performed by sensors. When these sensors have a continuous access to these measurements, we call such model an Event-Triggered model. The properties of this model are easier to prove, while its implementation is difficult in practice. Therefore, it is preferable to introduce a more realistic model, called Time-Triggered model, where the sensors take periodic measurements. Contrary to Event-Triggered models, Time-Triggered models are much easier to implement, but much more difficult to verify. Based on the differential refinement logic (dR[Formula: see text]), a dynamic logic for refinement relations on hybrid systems, it is possible to prove that a Time-Triggered model refines an Event-Triggered model. The major limitation of such logic is that it is not supported by any prover. In this paper, we propose a correct-by-construction approach that implements the reasoning on hybrid programs particularly the reasoning of dR[Formula: see text] in Event-B to take advantage of its associated tools.","publish_time":1587513600000,"author_summary":" Afendi, Meryem; Laleau, R\u00e9gine; Mammar, Amel","abstract_summary":" Hybrid systems are one of the most common<br>mathematical models for Cyber-Physical Systems (CPSs).<br>They combine discrete dynamics represented by<br>state machines or finite automata with continuous<br>behaviors represented by differential equations. The<br>measurement of continuous behaviors is performed by<br>sensors. When these sensors have a continuous access to<br>these measurements, we call such model an<br>Event-Triggered model. The properties of this model are easier<br>to prove, while its implementation is difficult<br>in practice. Therefore, it is preferable to<br>introduce a more realistic model, called Time-Triggered<br>model, where the sensors take periodic measurements.<br>Contrary to Event-Triggered models, Time-Triggered<br>models are...","title_summary":" Modelling Hybrid Programs with Event-B","x":-28.0567779541,"y":43.6709060669,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.0567779541,"tsne_y":43.6709060669,"subcluster":13,"subcluster_description":"Hybrid Programs","shape":"p"},{"cord_uid":"0m7nfrre","source_x":"PMC","title":"Refinement and Verification of Responsive Control Systems","doi":"10.1007\/978-3-030-48077-6_23","abstract":"Statechart notations with \u2018run to completion\u2019 semantics, are popular with engineers for designing controllers that respond to events in the environment with a sequence of state transitions. However, they lack formal refinement and rigorous verification methods. [Image: see text] , on the other hand, is based on refinement from an initial abstraction and is designed to make formal verification by automatic theorem provers feasible. We introduce a notion of refinement into a \u2018run to completion\u2019 statechart modelling notation, and leverage [Image: see text] tool support for theorem proving. We describe the difficulties in translating \u2018run to completion\u2019 semantics into [Image: see text] refinements and suggest a solution. We outline how safety and liveness properties could be verified.","publish_time":1587513600000,"author_summary":" Morris, Karla; Snook, Colin; Hoang, Thai Son;<br>Hulette, Geoffrey; Armstrong, Robert; Butler, Michael","abstract_summary":" Statechart notations with \u2018run to completion\u2019<br>semantics, are popular with engineers for designing<br>controllers that respond to events in the environment with a<br>sequence of state transitions. However, they lack<br>formal refinement and rigorous verification<br>methods. [Image: see text] , on the other hand, is based on<br>refinement from an initial abstraction and is designed to<br>make formal verification by automatic theorem<br>provers feasible. We introduce a notion of refinement<br>into a \u2018run to completion\u2019 statechart modelling<br>notation, and leverage [Image: see text] tool support for<br>theorem proving. We describe the difficulties in<br>translating \u2018run to completion\u2019 semantics into [Image:...","title_summary":" Refinement and Verification of Responsive<br>Control Systems","x":-27.4211540222,"y":43.7929458618,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.4211540222,"tsne_y":43.7929458618,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"30dpgue9","source_x":"PMC","title":"Validating Multiple Variants of an Automotive Light System with Electrum","doi":"10.1007\/978-3-030-48077-6_26","abstract":"This paper reports on the development and validation of a formal model for an automotive adaptive exterior lights system (ELS) with multiple variants in Electrum, a lightweight formal specification language that extends Alloy with mutable relations and temporal logic. We explore different strategies to address variability, one in pure Electrum and another through an annotative language extension. We then show how Electrum and its Analyzer can be used to validate systems of this nature, namely by checking that the reference scenarios are admissible, and to automatically verify whether the established requirements hold. A prototype was developed to translate the provided validation sequences into Electrum and back to further automate the validation process. The resulting ELS model was validated against the provided validation sequences and verified for most of requirements for all variants.","publish_time":1587513600000,"author_summary":" Cunha, Alcino; Macedo, Nuno; Liu, Chong","abstract_summary":" This paper reports on the development and<br>validation of a formal model for an automotive adaptive<br>exterior lights system (ELS) with multiple variants in<br>Electrum, a lightweight formal specification language<br>that extends Alloy with mutable relations and<br>temporal logic. We explore different strategies to<br>address variability, one in pure Electrum and another<br>through an annotative language extension. We then show<br>how Electrum and its Analyzer can be used to<br>validate systems of this nature, namely by checking that<br>the reference scenarios are admissible, and to<br>automatically verify whether the established requirements<br>hold. A prototype was developed to translate the<br>provided...","title_summary":" Validating Multiple Variants of an Automotive<br>Light System with Electrum","x":-28.81092453,"y":43.3568840027,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.81092453,"tsne_y":43.3568840027,"subcluster":12,"subcluster_description":"Automotive Light System","shape":"p"},{"cord_uid":"iof8n1id","source_x":"PMC","title":"Adding Concurrency to a Sequential Refinement Tower","doi":"10.1007\/978-3-030-48077-6_2","abstract":"This paper defines a concept and a verification methodology for adding concurrency to a sequential refinement tower of abstract state machines, that is based on data refinement and a component structure. We have developed such a refinement tower for the Flashix file system earlier, from which we generate executable (C and Scala) Code. The question we answer in this paper, is how to add concurrency based on locks to such a refinement tower, without breaking the initial modular structure. We achieve this by just enhancing the relevant components, and adding intermediate atomicity refinements that complement the data refinements that are already there. We also give a verification methodology for such atomicity refinements.","publish_time":1587513600000,"author_summary":" Schellhorn, Gerhard; Bodenm\u00fcller, Stefan;<br>Pf\u00e4hler, J\u00f6rg; Reif, Wolfgang","abstract_summary":" This paper defines a concept and a verification<br>methodology for adding concurrency to a sequential<br>refinement tower of abstract state machines, that is based<br>on data refinement and a component structure. We<br>have developed such a refinement tower for the<br>Flashix file system earlier, from which we generate<br>executable (C and Scala) Code. The question we answer in<br>this paper, is how to add concurrency based on locks<br>to such a refinement tower, without breaking the<br>initial modular structure. We achieve this by just<br>enhancing the relevant components, and adding<br>intermediate atomicity refinements that complement the<br>data refinements that are...","title_summary":" Adding Concurrency to a Sequential Refinement<br>Tower","x":-26.6465301514,"y":44.0630531311,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6465301514,"tsne_y":44.0630531311,"subcluster":33,"subcluster_description":"Netsstructural Reductions Revisiteda Study","shape":"p"},{"cord_uid":"me3rq9rz","source_x":"PMC","title":"Descriptional Complexity of Semi-simple Splicing Systems","doi":"10.1007\/978-3-030-48516-0_12","abstract":"Splicing systems are generative mechanisms introduced by Tom Head in 1987 to model the biological process of DNA recombination. The computational engine of a splicing system is the \u201csplicing operation\u201d, a cut-and-paste binary string operation defined by a set of \u201csplicing rules\u201d, quadruples [Formula: see text] where [Formula: see text] are words over an alphabet [Formula: see text]. For two strings [Formula: see text] and [Formula: see text], applying the splicing rule r produces the string [Formula: see text]. In this paper we focus on a particular type of splicing systems, called (i, j) semi-simple splicing systems, [Formula: see text] and [Formula: see text], wherein all splicing rules r have the property that the two strings in positions i and j in r are singleton letters, while the other two strings are empty. The language generated by such a system consists of the set of words that are obtained starting from an initial set called \u201caxiom set\u201d, by iteratively applying the splicing rules to strings in the axiom set as well as to intermediately produced strings. We consider semi-simple splicing systems where the axiom set is a regular language, and investigate the descriptional complexity of such systems in terms of the size of the minimal deterministic finite automata that recognize the languages they generate.","publish_time":1590451200000,"author_summary":" Kari, Lila; Ng, Timothy","abstract_summary":" Splicing systems are generative mechanisms<br>introduced by Tom Head in 1987 to model the biological<br>process of DNA recombination. The computational<br>engine of a splicing system is the \u201csplicing<br>operation\u201d, a cut-and-paste binary string operation<br>defined by a set of \u201csplicing rules\u201d, quadruples<br>[Formula: see text] where [Formula: see text] are words<br>over an alphabet [Formula: see text]. For two<br>strings [Formula: see text] and [Formula: see text],<br>applying the splicing rule r produces the string<br>[Formula: see text]. In this paper we focus on a particular<br>type of splicing systems, called (i, j) semi-simple<br>splicing systems, [Formula: see text]...","title_summary":" Descriptional Complexity of Semi-simple<br>Splicing Systems","x":-23.4128360748,"y":44.2693862915,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.4128360748,"tsne_y":44.2693862915,"subcluster":35,"subcluster_description":"Semi-Simple Splicing Systemsthe State","shape":"p"},{"cord_uid":"xha57sy5","source_x":"PMC","title":"Computing the Shortest String and the Edit-Distance for Parsing Expression Languages","doi":"10.1007\/978-3-030-48516-0_4","abstract":"A distance between two languages is a useful tool to measure the language similarity, and is closely related to the intersection problem as well as the shortest string problem. A parsing expression grammar (PEG) is an unambiguous grammar such that the choice operator selects the first matching in PEG while it can be ambiguous in a context-free grammar. PEGs are also closely related to top-down parsing languages. We consider two problems on parsing expression languages (PELs). One is the r-shortest string problem that decides whether or not a given PEL contains a string of length shorter than r. The other problem is the edit-distance problem of PELs with respect to other language families such as finite languages or regular languages. We show that the r-shortest string problem and the edit-distance problem with respect to finite languages are NEXPTIME-complete, and the edit-distance problem with respect to regular languages is undecidable. In addition, we prove that it is impossible to compute a length bound [Formula: see text] of a PEG G such that L(G) has a string w of length at most [Formula: see text].","publish_time":1590451200000,"author_summary":" Cheon, Hyunjoon; Han, Yo-Sub","abstract_summary":" A distance between two languages is a useful<br>tool to measure the language similarity, and is<br>closely related to the intersection problem as well as<br>the shortest string problem. A parsing expression<br>grammar (PEG) is an unambiguous grammar such that the<br>choice operator selects the first matching in PEG<br>while it can be ambiguous in a context-free grammar.<br>PEGs are also closely related to top-down parsing<br>languages. We consider two problems on parsing expression<br>languages (PELs). One is the r-shortest string problem<br>that decides whether or not a given PEL contains a<br>string of length shorter than r. The other...","title_summary":" Computing the Shortest String and the<br>Edit-Distance for Parsing Expression Languages","x":-23.4818611145,"y":43.8023490906,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.4818611145,"tsne_y":43.8023490906,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"fjy2ol7b","source_x":"PMC","title":"The State Complexity of Lexicographically Smallest Words and Computing Successors","doi":"10.1007\/978-3-030-48516-0_7","abstract":"Given a regular language L over an ordered alphabet [Formula: see text], the set of lexicographically smallest (resp., largest) words of each length is itself regular. Moreover, there exists an unambiguous finite-state transducer that, on a given word [Formula: see text], outputs the length-lexicographically smallest word larger than w (henceforth called the L-successor of w). In both cases, na\u00efve constructions result in an exponential blowup in the number of states. We prove that if L is recognized by a DFA with n states, then [Formula: see text] states are sufficient for a DFA to recognize the subset S(L) of L composed of its lexicographically smallest words. We give a matching lower bound that holds even if S(L) is represented as an NFA. We then show that the same upper and lower bounds hold for an unambiguous finite-state transducer that computes L-successors.","publish_time":1590451200000,"author_summary":" Fleischer, Lukas; Shallit, Jeffrey","abstract_summary":" Given a regular language L over an ordered<br>alphabet [Formula: see text], the set of<br>lexicographically smallest (resp., largest) words of each length<br>is itself regular. Moreover, there exists an<br>unambiguous finite-state transducer that, on a given word<br>[Formula: see text], outputs the<br>length-lexicographically smallest word larger than w (henceforth called<br>the L-successor of w). In both cases, na\u00efve<br>constructions result in an exponential blowup in the number of<br>states. We prove that if L is recognized by a DFA with n<br>states, then [Formula: see text] states are sufficient<br>for a DFA to recognize the subset S(L) of L...","title_summary":" The State Complexity of Lexicographically<br>Smallest Words and Computing Successors","x":-23.7093887329,"y":44.3359107971,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.7093887329,"tsne_y":44.3359107971,"subcluster":35,"subcluster_description":"Semi-Simple Splicing Systemsthe State","shape":"p"},{"cord_uid":"f8qfdtr5","source_x":"PMC","title":"Transition Property for [Formula: see text]-Power Free Languages with [Formula: see text] and [Formula: see text] Letters","doi":"10.1007\/978-3-030-48516-0_22","abstract":"In 1985, Restivo and Salemi presented a list of five problems concerning power free languages. Problem 4 states: Given [Formula: see text]-power-free words u and v, decide whether there is a transition from u to v. Problem 5 states: Given [Formula: see text]-power-free words u and v, find a transition word w, if it exists. Let [Formula: see text] denote an alphabet with k letters. Let [Formula: see text] denote the [Formula: see text]-power free language over the alphabet [Formula: see text], where [Formula: see text] is a rational number or a rational \u201cnumber with [Formula: see text]\u201d. If [Formula: see text] is a \u201cnumber with [Formula: see text]\u201d then suppose [Formula: see text] and [Formula: see text]. If [Formula: see text] is \u201conly\u201d a number then suppose [Formula: see text] and [Formula: see text] or [Formula: see text] and [Formula: see text]. We show that: If [Formula: see text] is a right extendable word in [Formula: see text] and [Formula: see text] is a left extendable word in [Formula: see text] then there is a (transition) word w such that [Formula: see text]. We also show a construction of the word w.","publish_time":1590451200000,"author_summary":" Rukavicka, Josef","abstract_summary":" In 1985, Restivo and Salemi presented a list of<br>five problems concerning power free languages.<br>Problem 4 states: Given [Formula: see<br>text]-power-free words u and v, decide whether there is a<br>transition from u to v. Problem 5 states: Given [Formula:<br>see text]-power-free words u and v, find a<br>transition word w, if it exists. Let [Formula: see text]<br>denote an alphabet with k letters. Let [Formula: see<br>text] denote the [Formula: see text]-power free<br>language over the alphabet [Formula: see text], where<br>[Formula: see text] is a rational number or a rational<br>\u201cnumber with [Formula: see text]\u201d. If [Formula:...","title_summary":" Transition Property for [Formula: see<br>text]-Power Free Languages with [Formula: see text] and<br>[Formula: see text] Letters","x":-23.0128059387,"y":44.2387046814,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.0128059387,"tsne_y":44.2387046814,"subcluster":29,"subcluster_description":"Inverse Lyndon Words","shape":"p"},{"cord_uid":"vhyb3f6s","source_x":"PMC","title":"Avoidability of Additive Cubes over Alphabets of Four Numbers","doi":"10.1007\/978-3-030-48516-0_15","abstract":"Let [Formula: see text] be a set of size 4 such that [Formula: see text] cannot be obtained by applying the same affine function to all of the elements of [Formula: see text]. We show that there is an infinite sequence of elements of [Formula: see text] that contains no three consecutive blocks of same size and same sum (additive cubes). Moreover, it is possible to replace [Formula: see text] by [Formula: see text] in the statement.","publish_time":1590451200000,"author_summary":" Lietard, Florian; Rosenfeld, Matthieu","abstract_summary":" Let [Formula: see text] be a set of size 4 such<br>that [Formula: see text] cannot be obtained by<br>applying the same affine function to all of the elements<br>of [Formula: see text]. We show that there is an<br>infinite sequence of elements of [Formula: see text]<br>that contains no three consecutive blocks of same<br>size and same sum (additive cubes). Moreover, it is<br>possible to replace [Formula: see text] by [Formula: see<br>text] in the statement.","title_summary":" Avoidability of Additive Cubes over Alphabets<br>of Four Numbers","x":-22.5384044647,"y":44.489025116,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.5384044647,"tsne_y":44.489025116,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"og764vav","source_x":"PMC","title":"Dynamics of Cellular Automata on Beta-Shifts and Direct Topological Factorizations","doi":"10.1007\/978-3-030-48516-0_14","abstract":"We consider the range of possible dynamics of cellular automata (CA) on two-sided beta-shifts [Formula: see text]. We show that any reversible CA [Formula: see text] has an almost equicontinuous direction whenever [Formula: see text] is not sofic. This has the corollary that non-sofic beta-shifts are topologically direct prime, i.e. they are not conjugate to direct topological factorizations [Formula: see text] of two nontrivial subshifts X and Y. We also make some preliminary observations on direct topological factorizations of beta-shifts that are subshifts of finite type.","publish_time":1590451200000,"author_summary":" Kopra, Johan","abstract_summary":" We consider the range of possible dynamics of<br>cellular automata (CA) on two-sided beta-shifts<br>[Formula: see text]. We show that any reversible CA<br>[Formula: see text] has an almost equicontinuous<br>direction whenever [Formula: see text] is not sofic. This<br>has the corollary that non-sofic beta-shifts are<br>topologically direct prime, i.e. they are not conjugate to<br>direct topological factorizations [Formula: see<br>text] of two nontrivial subshifts X and Y. We also make<br>some preliminary observations on direct<br>topological factorizations of beta-shifts that are<br>subshifts of finite type.","title_summary":" Dynamics of Cellular Automata on Beta-Shifts<br>and Direct Topological Factorizations","x":-22.8376731873,"y":45.0803184509,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.8376731873,"tsne_y":45.0803184509,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"9sbs7490","source_x":"PMC","title":"On Tree Substitution Grammars","doi":"10.1007\/978-3-030-48516-0_18","abstract":"Tree substitution grammars are formal models that are used extensively in natural language processing. It is demonstrated that their expressive power is located strictly between the local tree grammars and the regular tree grammars. A decision procedure for the problem of determining whether a tree substitution grammar generates a local tree language is provided. Unfortunately, the class of tree substitution languages is neither closed under union, nor intersection, nor complements. Indeed unions of tree substitution languages even generate an infinite hierarchy. However, all finite and all co-finite tree languages are tree substitution languages.","publish_time":1590451200000,"author_summary":" Maletti, Andreas; Stier, Kevin","abstract_summary":" Tree substitution grammars are formal models<br>that are used extensively in natural language<br>processing. It is demonstrated that their expressive power<br>is located strictly between the local tree<br>grammars and the regular tree grammars. A decision<br>procedure for the problem of determining whether a tree<br>substitution grammar generates a local tree language is<br>provided. Unfortunately, the class of tree substitution<br>languages is neither closed under union, nor<br>intersection, nor complements. Indeed unions of tree<br>substitution languages even generate an infinite<br>hierarchy. However, all finite and all co-finite tree<br>languages are tree substitution languages.","title_summary":" On Tree Substitution Grammars","x":-24.3059806824,"y":45.1983642578,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.3059806824,"tsne_y":45.1983642578,"subcluster":14,"subcluster_description":"Orienting Combinator Equationsshort Q-Resolution","shape":"p"},{"cord_uid":"a233g9ba","source_x":"PMC","title":"Equivalence of Linear Tree Transducers with Output in the Free Group","doi":"10.1007\/978-3-030-48516-0_16","abstract":"We show that equivalence of deterministic linear tree transducers can be decided in polynomial time when their outputs are interpreted over the free group. Due to the cancellation properties offered by the free group, the required constructions are not only more general, but also simpler than the corresponding constructions for proving equivalence of deterministic linear tree-to-word transducers.","publish_time":1590451200000,"author_summary":" L\u00f6bel, Raphaela; Luttenberger, Michael;<br>Seidl, Helmut","abstract_summary":" We show that equivalence of deterministic<br>linear tree transducers can be decided in polynomial<br>time when their outputs are interpreted over the<br>free group. Due to the cancellation properties<br>offered by the free group, the required constructions<br>are not only more general, but also simpler than the<br>corresponding constructions for proving equivalence of<br>deterministic linear tree-to-word transducers.","title_summary":" Equivalence of Linear Tree Transducers with<br>Output in the Free Group","x":-23.9201564789,"y":45.8418502808,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.9201564789,"tsne_y":45.8418502808,"subcluster":16,"subcluster_description":"Strictly Local Tree Transducersequivalence","shape":"p"},{"cord_uid":"5bzxd1g2","source_x":"PMC","title":"Scattered Factor-Universality of Words","doi":"10.1007\/978-3-030-48516-0_2","abstract":"A word [Formula: see text] is a scattered factor of a word w if u can be obtained from w by deleting some of its letters: there exist the (potentially empty) words [Formula: see text] such that [Formula: see text]. The set of all scattered factors up to length k of a word is called its full k-spectrum. Firstly, we show an algorithm deciding whether the k-spectra for given k of two words are equal or not, running in optimal time. Secondly, we consider a notion of scattered-factors universality: the word w, with [Formula: see text], is called k-universal if its k-spectrum includes all words of length k over the alphabet [Formula: see text]; we extend this notion to k-circular universality. After a series of preliminary combinatorial results, we present an algorithm computing, for a given [Formula: see text]-universal word w the minimal i such that [Formula: see text] is k-universal for some [Formula: see text]. Several other connected problems are also considered.","publish_time":1590451200000,"author_summary":" Barker, Laura; Fleischmann, Pamela;<br>Harwardt, Katharina; Manea, Florin; Nowotka, Dirk","abstract_summary":" A word [Formula: see text] is a scattered factor<br>of a word w if u can be obtained from w by deleting<br>some of its letters: there exist the (potentially<br>empty) words [Formula: see text] such that [Formula:<br>see text]. The set of all scattered factors up to<br>length k of a word is called its full k-spectrum.<br>Firstly, we show an algorithm deciding whether the<br>k-spectra for given k of two words are equal or not, running<br>in optimal time. Secondly, we consider a notion of<br>scattered-factors universality: the word w, with [Formula: see<br>text], is called k-universal if...","title_summary":" Scattered Factor-Universality of Words","x":-22.972448349,"y":44.2216377258,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.972448349,"tsne_y":44.2216377258,"subcluster":29,"subcluster_description":"Inverse Lyndon Words","shape":"p"},{"cord_uid":"rac91hmt","source_x":"PMC","title":"Operations on Permutation Automata","doi":"10.1007\/978-3-030-48516-0_10","abstract":"We investigate the class of languages recognized by permutation deterministic finite automata. Using automata constructions and some properties of permutation automata, we show that this class is closed under Boolean operations, reversal, and quotients, and it is not closed under concatenation, power, Kleene closure, positive closure, cut, shuffle, cyclic shift, and permutation. We prove that the state complexity of Boolean operations, Kleene closure, positive closure, and right quotient on permutation languages is the same as in the general case of regular languages. Next, we get the tight upper bounds on the state complexity of concatenation ([Formula: see text]), square ([Formula: see text]), reversal ([Formula: see text]), and left quotient ([Formula: see text]; tight if [Formula: see text]). All our witnesses are unary or binary, and the binary alphabet is always optimal, except for Boolean operations in the case of [Formula: see text]. In the unary case, the state complexity of all considered operations is the same as for regular languages, except for quotients and cut. In case of quotients, it is [Formula: see text], and in case of cut, it is either [Formula: see text] or [Formula: see text], depending on whether there exists an integer [Formula: see text] with [Formula: see text] such that [Formula: see text].","publish_time":1590451200000,"author_summary":" Hospod\u00e1r, Michal; Mlyn\u00e1r\u010dik, Peter","abstract_summary":" We investigate the class of languages<br>recognized by permutation deterministic finite<br>automata. Using automata constructions and some<br>properties of permutation automata, we show that this<br>class is closed under Boolean operations, reversal,<br>and quotients, and it is not closed under<br>concatenation, power, Kleene closure, positive closure, cut,<br>shuffle, cyclic shift, and permutation. We prove that<br>the state complexity of Boolean operations,<br>Kleene closure, positive closure, and right quotient<br>on permutation languages is the same as in the<br>general case of regular languages. Next, we get the<br>tight upper bounds on the state complexity of<br>concatenation ([Formula: see text]), square ([Formula:...","title_summary":" Operations on Permutation Automata","x":-23.7155818939,"y":44.3834075928,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.7155818939,"tsne_y":44.3834075928,"subcluster":35,"subcluster_description":"Semi-Simple Splicing Systemsthe State","shape":"p"},{"cord_uid":"7ke0z029","source_x":"PMC","title":"On the Fine Grained Complexity of Finite Automata Non-emptiness of Intersection","doi":"10.1007\/978-3-030-48516-0_6","abstract":"We study the fine grained complexity of the DFA non-emptiness of intersection problem parameterized by the number k of input automata (k -DFA-NEI). More specifically, we are given a list [Formula: see text] of DFA\u2019s over a common alphabet [Formula: see text], and the goal is to determine whether [Formula: see text]. This problem can be solved in time [Formula: see text] by applying the classic Rabin-Scott product construction. In this work, we show that the existence of algorithms solving k -DFA-NEI in time slightly faster than [Formula: see text] would imply the existence of deterministic sub-exponential time algorithms for the simulation of nondeterministic linear space bounded computations. This consequence strengthens the existing conditional lower bounds for k-DFA-NEI and implies new non-uniform circuit lower bounds.","publish_time":1590451200000,"author_summary":" de Oliveira Oliveira, Mateus; Wehar, Michael","abstract_summary":" We study the fine grained complexity of the DFA<br>non-emptiness of intersection problem parameterized by the<br>number k of input automata (k -DFA-NEI). More<br>specifically, we are given a list [Formula: see text] of DFA\u2019s<br>over a common alphabet [Formula: see text], and the<br>goal is to determine whether [Formula: see text].<br>This problem can be solved in time [Formula: see<br>text] by applying the classic Rabin-Scott product<br>construction. In this work, we show that the existence of<br>algorithms solving k -DFA-NEI in time slightly faster than<br>[Formula: see text] would imply the existence of<br>deterministic sub-exponential time algorithms for...","title_summary":" On the Fine Grained Complexity of Finite<br>Automata Non-emptiness of Intersection","x":-24.26055336,"y":44.3108787537,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.26055336,"tsne_y":44.3108787537,"subcluster":21,"subcluster_description":"Stack Automata Modelsinvolutory Turing","shape":"p"},{"cord_uid":"tkwd9j0z","source_x":"PMC","title":"The Characterization of Rational Numbers Belonging to a Minimal Path in the Stern-Brocot Tree According to a Second Order Balancedness","doi":"10.1007\/978-3-030-48516-0_24","abstract":"In 1842, Dirichlet observed that any real number [Formula: see text] can be obtained as the limit of a sequence [Formula: see text] of irreducible rational numbers. Few years later, M. Stern (1858) and A. Brocot (1861) defined a tree-like arrangement of all the (irreducible) rational numbers whose infinite paths are the Dirichlet sequences of the real numbers and are characterized by their continued fraction representations. The Stern-Brocot tree is equivalent to the Christoffel tree obtained by ordering the Christoffel words according to their standard factorization. We remark that the Fibonacci word\u2019s prefixes belong to a minimal path in the Christoffel tree with respect to the second order balancedness parameter defined on Christoffel words. This alows us to switch back to the Stern-Brocot tree, in order to give a characterization of the continued fraction representation for all the rational numbers belonging to minimal paths with respect to the growth of the second order balancedness.","publish_time":1590451200000,"author_summary":" Frosini, Andrea; Tarsissi, Lama","abstract_summary":" In 1842, Dirichlet observed that any real<br>number [Formula: see text] can be obtained as the limit<br>of a sequence [Formula: see text] of irreducible<br>rational numbers. Few years later, M. Stern (1858) and A.<br>Brocot (1861) defined a tree-like arrangement of all<br>the (irreducible) rational numbers whose<br>infinite paths are the Dirichlet sequences of the real<br>numbers and are characterized by their continued<br>fraction representations. The Stern-Brocot tree is<br>equivalent to the Christoffel tree obtained by ordering<br>the Christoffel words according to their standard<br>factorization. We remark that the Fibonacci word\u2019s prefixes<br>belong to a minimal path in the...","title_summary":" The Characterization of Rational Numbers<br>Belonging to a Minimal Path in the Stern-Brocot Tree<br>According to a Second Order Balancedness","x":-22.5228157043,"y":44.7729644775,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.5228157043,"tsne_y":44.7729644775,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"u821tjh1","source_x":"PMC","title":"Avoiding 5\/4-Powers on the Alphabet of Nonnegative Integers (Extended Abstract)","doi":"10.1007\/978-3-030-48516-0_21","abstract":"We identify the structure of the lexicographically least word avoiding 5\/4-powers on the alphabet of nonnegative integers.","publish_time":1590451200000,"author_summary":" Rowland, Eric; Stipulanti, Manon","abstract_summary":" We identify the structure of the<br>lexicographically least word avoiding 5\/4-powers on the alphabet<br>of nonnegative integers.","title_summary":" Avoiding 5\/4-Powers on the Alphabet of<br>Nonnegative Integers (Extended Abstract)","x":-22.4262180328,"y":46.7289619446,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4262180328,"tsne_y":46.7289619446,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"h2ip2jqf","source_x":"PMC","title":"Reconstructing Words from Right-Bounded-Block Words","doi":"10.1007\/978-3-030-48516-0_8","abstract":"A reconstruction problem of words from scattered factors asks for the minimal information, like multisets of scattered factors of a given length or the number of occurrences of scattered factors from a given set, necessary to uniquely determine a word. We show that a word [Formula: see text] can be reconstructed from the number of occurrences of at most [Formula: see text] scattered factors of the form [Formula: see text], where [Formula: see text] is the number of occurrences of the letter [Formula: see text] in w. Moreover, we generalize the result to alphabets of the form [Formula: see text] by showing that at most [Formula: see text] scattered factors suffices to reconstruct w. Both results improve on the upper bounds known so far. Complexity time bounds on reconstruction algorithms are also considered here.","publish_time":1590451200000,"author_summary":" Fleischmann, Pamela; Lejeune, Marie; Manea,<br>Florin; Nowotka, Dirk; Rigo, Michel","abstract_summary":" A reconstruction problem of words from<br>scattered factors asks for the minimal information, like<br>multisets of scattered factors of a given length or the<br>number of occurrences of scattered factors from a<br>given set, necessary to uniquely determine a word. We<br>show that a word [Formula: see text] can be<br>reconstructed from the number of occurrences of at most<br>[Formula: see text] scattered factors of the form<br>[Formula: see text], where [Formula: see text] is the<br>number of occurrences of the letter [Formula: see<br>text] in w. Moreover, we generalize the result to<br>alphabets of the form [Formula: see text]...","title_summary":" Reconstructing Words from<br>Right-Bounded-Block Words","x":-22.8890399933,"y":44.1242370605,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.8890399933,"tsne_y":44.1242370605,"subcluster":29,"subcluster_description":"Inverse Lyndon Words","shape":"p"},{"cord_uid":"i6pohkl9","source_x":"PMC","title":"Sublinear-Time Language Recognition and Decision by One-Dimensional Cellular Automata","doi":"10.1007\/978-3-030-48516-0_19","abstract":"After an apparent hiatus of roughly 30 years, we revisit a seemingly neglected subject in the theory of (one-dimensional) cellular automata: sublinear-time computation. The model considered is that of ACAs, which are language acceptors whose acceptance condition depends on the states of all cells in the automaton. We prove a time hierarchy theorem for sublinear-time ACA classes, analyze their intersection with the regular languages, and, finally, establish strict inclusions in the parallel computation classes [Formula: see text] and (uniform) [Formula: see text]. As an addendum, we introduce and investigate the concept of a decider ACA (DACA) as a candidate for a decider counterpart to (acceptor) ACAs. We show the class of languages decidable in constant time by DACAs equals the locally testable languages, and we also determine [Formula: see text] as the (tight) time complexity threshold for DACAs up to which no advantage compared to constant time is possible.","publish_time":1590451200000,"author_summary":" Modanese, Augusto","abstract_summary":" After an apparent hiatus of roughly 30 years, we<br>revisit a seemingly neglected subject in the theory of<br>(one-dimensional) cellular automata: sublinear-time<br>computation. The model considered is that of ACAs, which are<br>language acceptors whose acceptance condition depends<br>on the states of all cells in the automaton. We<br>prove a time hierarchy theorem for sublinear-time<br>ACA classes, analyze their intersection with the<br>regular languages, and, finally, establish strict<br>inclusions in the parallel computation classes [Formula:<br>see text] and (uniform) [Formula: see text]. As an<br>addendum, we introduce and investigate the concept of a<br>decider ACA (DACA) as a candidate for...","title_summary":" Sublinear-Time Language Recognition and<br>Decision by One-Dimensional Cellular Automata","x":-23.7952003479,"y":44.2619247437,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.7952003479,"tsne_y":44.2619247437,"subcluster":35,"subcluster_description":"Semi-Simple Splicing Systemsthe State","shape":"p"},{"cord_uid":"62hue455","source_x":"PMC","title":"On the Degeneracy of Random Expressions Specified by Systems of Combinatorial Equations","doi":"10.1007\/978-3-030-48516-0_13","abstract":"We consider general expressions, which are trees whose nodes are labeled with operators, that represent syntactic descriptions of formulas. We assume that there is an operator that has an absorbing pattern and prove that if we use this property to simplify a uniform random expression with n nodes, then the expected size of the result is bounded by a constant. In our framework, expressions are defined using a combinatorial system, which describes how they are built: one can ensure, for instance, that there are no two consecutive stars in regular expressions. This generalizes a former result where only one equation was allowed, confirming the lack of expressivity of uniform random expressions.","publish_time":1590451200000,"author_summary":" Koechlin, Florent; Nicaud, Cyril; Rotondo,<br>Pablo","abstract_summary":" We consider general expressions, which are<br>trees whose nodes are labeled with operators, that<br>represent syntactic descriptions of formulas. We assume<br>that there is an operator that has an absorbing<br>pattern and prove that if we use this property to<br>simplify a uniform random expression with n nodes, then<br>the expected size of the result is bounded by a<br>constant. In our framework, expressions are defined<br>using a combinatorial system, which describes how<br>they are built: one can ensure, for instance, that<br>there are no two consecutive stars in regular<br>expressions. This generalizes a former result where only one<br>equation...","title_summary":" On the Degeneracy of Random Expressions<br>Specified by Systems of Combinatorial Equations","x":-23.3255786896,"y":45.048614502,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.3255786896,"tsne_y":45.048614502,"subcluster":24,"subcluster_description":"Word Problem","shape":"p"},{"cord_uid":"oauavcy7","source_x":"PMC","title":"An Approach to the Herzog-Sch\u00f6nheim Conjecture Using Automata","doi":"10.1007\/978-3-030-48516-0_5","abstract":"Let G be a group and [Formula: see text],..., [Formula: see text] be subgroups of G of indices [Formula: see text] respectively. In 1974, M. Herzog and J. Sch\u00f6nheim conjectured that if [Formula: see text], [Formula: see text], is a coset partition of G, then [Formula: see text] cannot be distinct. In this paper, we present a new approach to the Herzog-Sch\u00f6nheim conjecture based on automata and present a translation of the conjecture as a problem on automata.","publish_time":1590451200000,"author_summary":" Chouraqui, Fabienne","abstract_summary":" Let G be a group and [Formula: see text],...,<br>[Formula: see text] be subgroups of G of indices [Formula:<br>see text] respectively. In 1974, M. Herzog and J.<br>Sch\u00f6nheim conjectured that if [Formula: see text],<br>[Formula: see text], is a coset partition of G, then<br>[Formula: see text] cannot be distinct. In this paper, we<br>present a new approach to the Herzog-Sch\u00f6nheim<br>conjecture based on automata and present a translation of<br>the conjecture as a problem on automata.","title_summary":" An Approach to the Herzog-Sch\u00f6nheim<br>Conjecture Using Automata","x":-23.4131793976,"y":44.6352653503,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.4131793976,"tsne_y":44.6352653503,"subcluster":34,"subcluster_description":"Text]On Collapsing Prefix Normal","shape":"p"},{"cord_uid":"gqkl0rlh","source_x":"PMC","title":"A Study of a Simple Class of Modifiers: Product Modifiers","doi":"10.1007\/978-3-030-48516-0_9","abstract":"A modifier is a k-ary operator acting on DFAs and producing a DFA. Modifiers are involved in the theory of state complexity. We define and study a class of simple modifiers, called product modifiers, and we link closely the regular operations they encode to boolean operations.","publish_time":1590451200000,"author_summary":" Caron, Pascal; Hamel-de-le-court, Edwin;<br>Luque, Jean-Gabriel","abstract_summary":" A modifier is a k-ary operator acting on DFAs and<br>producing a DFA. Modifiers are involved in the theory of<br>state complexity. We define and study a class of<br>simple modifiers, called product modifiers, and we<br>link closely the regular operations they encode to<br>boolean operations.","title_summary":" A Study of a Simple Class of Modifiers: Product<br>Modifiers","x":-24.1537055969,"y":46.1464767456,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.1537055969,"tsne_y":46.1464767456,"subcluster":17,"subcluster_description":"Quantum Finite Automatainsertion-Deletion Systems","shape":"p"},{"cord_uid":"vf9gyc1v","source_x":"PMC","title":"Space Complexity of Stack Automata Models","doi":"10.1007\/978-3-030-48516-0_11","abstract":"This paper examines several measures of space complexity on variants of stack automata: non-erasing stack automata and checking stack automata. These measures capture the minimum stack size required to accept any word in a language (weak measure), the maximum stack size used in any accepting computation on any accepted word (accept measure), and the maximum stack size used in any computation (strong measure). We give a detailed characterization of the accept and strong space complexity measures for checking stack automata. Exactly one of three cases can occur: the complexity is either bounded by a constant, behaves (up to small technicalities explained in the paper) like a linear function, or it grows arbitrarily larger than the length of the input word. However, this result does not hold for non-erasing stack automata; we provide an example when the space complexity grows with the square root of the input length. Furthermore, an investigation is done regarding the best complexity of any machine accepting a given language, and on decidability of space complexity properties.","publish_time":1590451200000,"author_summary":" Ibarra, Oscar H.; Jir\u00e1sek, Jozef; McQuillan,<br>Ian; Prigioniero, Luca","abstract_summary":" This paper examines several measures of space<br>complexity on variants of stack automata: non-erasing<br>stack automata and checking stack automata. These<br>measures capture the minimum stack size required to<br>accept any word in a language (weak measure), the<br>maximum stack size used in any accepting computation on<br>any accepted word (accept measure), and the<br>maximum stack size used in any computation (strong<br>measure). We give a detailed characterization of the<br>accept and strong space complexity measures for<br>checking stack automata. Exactly one of three cases can<br>occur: the complexity is either bounded by a constant,<br>behaves (up to small technicalities...","title_summary":" Space Complexity of Stack Automata Models","x":-24.2682476044,"y":44.3170509338,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.2682476044,"tsne_y":44.3170509338,"subcluster":21,"subcluster_description":"Stack Automata Modelsinvolutory Turing","shape":"p"},{"cord_uid":"io5d72lm","source_x":"PMC","title":"Equational Theories of Scattered and Countable Series-Parallel Posets","doi":"10.1007\/978-3-030-48516-0_1","abstract":"In this paper we consider two classes of posets labeled over an alphabet A. The class [Formula: see text] is built from the letters and closed under the operations of series finite, [Formula: see text] and [Formula: see text] products, and finite parallel product. In the class [Formula: see text], [Formula: see text] and [Formula: see text] products are replaced by [Formula: see text] and [Formula: see text] powers. We prove that [Formula: see text] and [Formula: see text] are freely generated in their respective natural varieties of algebras [Formula: see text] and [Formula: see text], and that the equational theory of [Formula: see text] is decidable.","publish_time":1590451200000,"author_summary":" Amazigh, Amrane; Bedon, Nicolas","abstract_summary":" In this paper we consider two classes of posets<br>labeled over an alphabet A. The class [Formula: see<br>text] is built from the letters and closed under the<br>operations of series finite, [Formula: see text] and<br>[Formula: see text] products, and finite parallel<br>product. In the class [Formula: see text], [Formula: see<br>text] and [Formula: see text] products are replaced<br>by [Formula: see text] and [Formula: see text]<br>powers. We prove that [Formula: see text] and [Formula:<br>see text] are freely generated in their respective<br>natural varieties of algebras [Formula: see text] and<br>[Formula: see text], and that the equational...","title_summary":" Equational Theories of Scattered and<br>Countable Series-Parallel Posets","x":-22.9850788116,"y":44.4861793518,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.9850788116,"tsne_y":44.4861793518,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"beo9po37","source_x":"PMC","title":"Context-Freeness of Word-MIX Languages","doi":"10.1007\/978-3-030-48516-0_23","abstract":"In this paper we provide a decidable characterisation of the context-freeness of a Word-MIX language [Formula: see text], where [Formula: see text] is the set of all words over [Formula: see text] that contain the same number of subword occurrences of parameter words [Formula: see text].","publish_time":1590451200000,"author_summary":" Sin\u2019Ya, Ryoma","abstract_summary":" In this paper we provide a decidable<br>characterisation of the context-freeness of a Word-MIX language<br>[Formula: see text], where [Formula: see text] is the set<br>of all words over [Formula: see text] that contain<br>the same number of subword occurrences of<br>parameter words [Formula: see text].","title_summary":" Context-Freeness of Word-MIX Languages","x":-23.3841018677,"y":45.0530052185,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.3841018677,"tsne_y":45.0530052185,"subcluster":24,"subcluster_description":"Word Problem","shape":"p"},{"cord_uid":"8qs1bybv","source_x":"PMC","title":"On Normalish Subgroups of the R. Thompson Groups","doi":"10.1007\/978-3-030-48516-0_3","abstract":"Results in [Formula: see text] algebras, of Matte Bon and Le Boudec, and of Haagerup and Olesen, apply to the R. Thompson groups [Formula: see text]. These results together show that F is non-amenable if and only if T has a simple reduced [Formula: see text]-algebra. In further investigations into the structure of [Formula: see text]-algebras, Breuillard, Kalantar, Kennedy, and Ozawa introduce the notion of a normalish subgroup of a group G. They show that if a group G admits no non-trivial finite normal subgroups and no normalish amenable subgroups then it has a simple reduced [Formula: see text]-algebra. Our chief result concerns the R. Thompson groups [Formula: see text]; we show that there is an elementary amenable group [Formula: see text] (where here, [Formula: see text]) with E normalish in V. The proof given uses a natural partial action of the group V on a regular language determined by a synchronizing automaton in order to verify a certain stability condition: once again highlighting the existence of interesting intersections of the theory of V with various forms of formal language theory.","publish_time":1590451200000,"author_summary":" Bleak, Collin","abstract_summary":" Results in [Formula: see text] algebras, of<br>Matte Bon and Le Boudec, and of Haagerup and Olesen,<br>apply to the R. Thompson groups [Formula: see text].<br>These results together show that F is non-amenable if<br>and only if T has a simple reduced [Formula: see<br>text]-algebra. In further investigations into the structure<br>of [Formula: see text]-algebras, Breuillard,<br>Kalantar, Kennedy, and Ozawa introduce the notion of a<br>normalish subgroup of a group G. They show that if a group G<br>admits no non-trivial finite normal subgroups and no<br>normalish amenable subgroups then it has a simple reduced<br>[Formula: see text]-algebra. Our...","title_summary":" On Normalish Subgroups of the R. Thompson<br>Groups","x":-22.5292034149,"y":44.6636810303,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.5292034149,"tsne_y":44.6636810303,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"o2jk06pz","source_x":"PMC","title":"On the Balancedness of Tree-to-Word Transducers","doi":"10.1007\/978-3-030-48516-0_17","abstract":"A language over an alphabet [Formula: see text] of opening ([Formula: see text]) and closing ([Formula: see text]) brackets, is balanced if it is a subset of the Dyck language [Formula: see text] over [Formula: see text], and it is well-formed if all words are prefixes of words in [Formula: see text]. We show that well-formedness of a context-free language is decidable in polynomial time, and that the longest common reduced suffix can be computed in polynomial time. With this at a hand we decide for the class 2-TW of non-linear tree transducers with output alphabet [Formula: see text] whether or not the output language is balanced.","publish_time":1590451200000,"author_summary":" L\u00f6bel, Raphaela; Luttenberger, Michael;<br>Seidl, Helmut","abstract_summary":" A language over an alphabet [Formula: see text]<br>of opening ([Formula: see text]) and closing<br>([Formula: see text]) brackets, is balanced if it is a<br>subset of the Dyck language [Formula: see text] over<br>[Formula: see text], and it is well-formed if all words are<br>prefixes of words in [Formula: see text]. We show that<br>well-formedness of a context-free language is decidable in<br>polynomial time, and that the longest common reduced<br>suffix can be computed in polynomial time. With this at<br>a hand we decide for the class 2-TW of non-linear<br>tree transducers with output alphabet [Formula:<br>see text] whether...","title_summary":" On the Balancedness of Tree-to-Word<br>Transducers","x":-23.3883075714,"y":44.3937721252,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.3883075714,"tsne_y":44.3937721252,"subcluster":35,"subcluster_description":"Semi-Simple Splicing Systemsthe State","shape":"p"},{"cord_uid":"m3ixq4a4","source_x":"PMC","title":"Complexity of Searching for 2 by 2 Submatrices in Boolean Matrices","doi":"10.1007\/978-3-030-48516-0_20","abstract":"We study the problem of finding a given [Formula: see text] matrix as a submatrix of a given Boolean matrix. Three variants are considered: search for a matching submatrix of any area, of minimum area, or of maximum area. The problem relates to 2D pattern matching, and to fields such as data mining, where the search for submatrices plays an important role. Besides these connections, the problem itself is very natural and its investigation helps to demonstrate differences between search tasks in one-dimensional and multidimensional topologies. Our results reveal that the problem variants are of different complexities. First, we show that given an [Formula: see text] Boolean matrix, the any variant can be solved in [Formula: see text] time for any given [Formula: see text] matrix, but requires various strategies for different [Formula: see text] matrices. This contrasts with the complexity of the task over matrices with entries from the set [Formula: see text], where the problem is Triangle Finding-hard and hence no algorithm with similar running time is known for it. Then, we show that the minimization variant in the case of Boolean matrices can also be solved in [Formula: see text] time. Finally, in contrast, we prove Triangle Finding-hardness for the maximization variant and show that there is a rectangular matrix multiplication-based algorithm solving it in [Formula: see text] time.","publish_time":1590451200000,"author_summary":" Pr\u016f\u0161a, Daniel; Wehar, Michael","abstract_summary":" We study the problem of finding a given<br>[Formula: see text] matrix as a submatrix of a given<br>Boolean matrix. Three variants are considered: search<br>for a matching submatrix of any area, of minimum<br>area, or of maximum area. The problem relates to 2D<br>pattern matching, and to fields such as data mining,<br>where the search for submatrices plays an important<br>role. Besides these connections, the problem itself<br>is very natural and its investigation helps to<br>demonstrate differences between search tasks in<br>one-dimensional and multidimensional topologies. Our results<br>reveal that the problem variants are of different<br>complexities. First, we show...","title_summary":" Complexity of Searching for 2 by 2 Submatrices<br>in Boolean Matrices","x":-22.6747932434,"y":43.374294281,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.6747932434,"tsne_y":43.374294281,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"ei2mudex","source_x":"PMC","title":"Equivalent Rewritings on Path Views with Binding Patterns","doi":"10.1007\/978-3-030-49461-2_26","abstract":"A view with a binding pattern is a parameterized query on a database. Such views are used, e.g., to model Web services. To answer a query on such views, the views have to be orchestrated together in execution plans. We show how queries can be rewritten into equivalent execution plans, which are guaranteed to deliver the same results as the query on all databases. We provide a correct and complete algorithm to find these plans for path views and atomic queries. Finally, we show that our method can be used to answer queries on real-world Web services.","publish_time":1588809600000,"author_summary":" Romero, Julien; Preda, Nicoleta; Amarilli,<br>Antoine; Suchanek, Fabian","abstract_summary":" A view with a binding pattern is a parameterized<br>query on a database. Such views are used, e.g., to<br>model Web services. To answer a query on such views,<br>the views have to be orchestrated together in<br>execution plans. We show how queries can be rewritten into<br>equivalent execution plans, which are guaranteed to<br>deliver the same results as the query on all databases.<br>We provide a correct and complete algorithm to<br>find these plans for path views and atomic queries.<br>Finally, we show that our method can be used to answer<br>queries on real-world Web services.","title_summary":" Equivalent Rewritings on Path Views with<br>Binding Patterns","x":-27.1423835754,"y":42.6524772644,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.1423835754,"tsne_y":42.6524772644,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"01o1w8bt","source_x":"PMC","title":"Handling Impossible Derivations During Stream Reasoning","doi":"10.1007\/978-3-030-49461-2_1","abstract":"With the rapid expansion of the Web and the advent of the Internet of Things, there is a growing need to design tools for intelligent analytics and decision making on streams of data. Logic-based frameworks like LARS allow the execution of complex reasoning on such streams, but it is paramount that the computation is completed in a timely manner before the stream expires. To reduce the runtime, we can extend the validity of inferred conclusions to the future to avoid repeated derivations, but this is not enough to avoid all sources of redundant computation. To further alleviate this problem, this paper introduces a new technique that infers the impossibility of certain derivations in the future and blocks the reasoner from performing computation that is doomed to fail anyway. An experimental analysis on microbenchmarks shows that our technique leads to a significant reduction of the reasoning runtime.","publish_time":1588809600000,"author_summary":" Bazoobandi, Hamid R.; Bal, Henri; van<br>Harmelen, Frank; Urbani, Jacopo","abstract_summary":" With the rapid expansion of the Web and the<br>advent of the Internet of Things, there is a growing<br>need to design tools for intelligent analytics and<br>decision making on streams of data. Logic-based<br>frameworks like LARS allow the execution of complex<br>reasoning on such streams, but it is paramount that the<br>computation is completed in a timely manner before the<br>stream expires. To reduce the runtime, we can extend<br>the validity of inferred conclusions to the future<br>to avoid repeated derivations, but this is not<br>enough to avoid all sources of redundant computation.<br>To further alleviate this problem, this...","title_summary":" Handling Impossible Derivations During<br>Stream Reasoning","x":-27.2850570679,"y":42.4519767761,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.2850570679,"tsne_y":42.4519767761,"subcluster":4,"subcluster_description":"Persistent Software Transactional","shape":"p"},{"cord_uid":"ug1lixug","source_x":"PMC","title":"Scheduling Processes Without Sudden Termination","doi":"10.1007\/978-3-030-49418-6_8","abstract":"Dynamic controllability is the most general criterion to guarantee that a process can be executed without time failures. However, it admits schedules with an undesirable property: starting an activity without knowing its deadline. We analyze the specific constellations of temporal constraints causing such a sudden termination. Consequently, we introduce the somewhat stricter notion of semi-dynamic controllability, and present necessary and sufficient conditions to guarantee that a process can be executed without time failures and without sudden termination. A sound and complete algorithm for checking whether a process is semi-dynamically controllable complements the approach.","publish_time":1588636800000,"author_summary":" Eder, Johann; Franceschetti, Marco; Lubas,<br>Josef","abstract_summary":" Dynamic controllability is the most general<br>criterion to guarantee that a process can be executed<br>without time failures. However, it admits schedules<br>with an undesirable property: starting an activity<br>without knowing its deadline. We analyze the specific<br>constellations of temporal constraints causing such a sudden<br>termination. Consequently, we introduce the somewhat<br>stricter notion of semi-dynamic controllability, and<br>present necessary and sufficient conditions to<br>guarantee that a process can be executed without time<br>failures and without sudden termination. A sound and<br>complete algorithm for checking whether a process is<br>semi-dynamically controllable complements the approach.","title_summary":" Scheduling Processes Without Sudden<br>Termination","x":-27.4876289368,"y":44.2972831726,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.4876289368,"tsne_y":44.2972831726,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"wrr258lg","source_x":"PMC","title":"Ordering a Sparse Graph to Minimize the Sum of Right Ends of Edges","doi":"10.1007\/978-3-030-48966-3_17","abstract":"Motivated by a warehouse logistics problem we study mappings of the vertices of a graph onto prescribed points on the real line that minimize the sum (or equivalently, the average) of the coordinates of the right ends of all edges. We focus on graphs whose edge numbers do not exceed the vertex numbers too much, that is, graphs with few cycles. Intuitively, dense subgraphs should be placed early in the ordering, in order to finish many edges soon. However, our main \u201ccalculation trick\u201d is to compare the objective function with the case when (almost) every vertex is the right end of exactly one edge. The deviations from this case are described by \u201ccharges\u201d that can form \u201cdipoles\u201d. This reformulation enables us to derive polynomial algorithms and NP-completeness results for relevant special cases, and FPT results.","publish_time":1588204800000,"author_summary":" Damaschke, Peter","abstract_summary":" Motivated by a warehouse logistics problem we<br>study mappings of the vertices of a graph onto<br>prescribed points on the real line that minimize the sum (or<br>equivalently, the average) of the coordinates of the right<br>ends of all edges. We focus on graphs whose edge<br>numbers do not exceed the vertex numbers too much, that<br>is, graphs with few cycles. Intuitively, dense<br>subgraphs should be placed early in the ordering, in order<br>to finish many edges soon. However, our main<br>\u201ccalculation trick\u201d is to compare the objective function<br>with the case when (almost) every vertex is the right<br>end...","title_summary":" Ordering a Sparse Graph to Minimize the Sum of<br>Right Ends of Edges","x":-22.3748855591,"y":43.1522216797,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.3748855591,"tsne_y":43.1522216797,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"i0w07j59","source_x":"PMC","title":"Two Robots Patrolling on a Line: Integer Version and Approximability","doi":"10.1007\/978-3-030-48966-3_16","abstract":"Suppose that two robots can move at unit speed on a line and must visit certain points called stations infinitely often. Every station allows some maximal waiting time between two visits. The problem is to construct an optimal schedule for the robots. While the one-robot problem is easy to solve in linear time, already for two robots the complexity is open. Chuangpishit, Czyzowicz, Gasieniec, Georgiou, Jurdzinski, and Kranakis (SOFSEM 2018) found a [Formula: see text]-approximation algorithm. Here we provide a PTAS, accomplished by rounding and (perhaps more surprisingly) by using the well-quasi ordering of vectors of positive integers. The result is not very practical in the present form, but further investigation of the integer version may make it more usable.","publish_time":1588204800000,"author_summary":" Damaschke, Peter","abstract_summary":" Suppose that two robots can move at unit speed on<br>a line and must visit certain points called<br>stations infinitely often. Every station allows some<br>maximal waiting time between two visits. The problem is<br>to construct an optimal schedule for the robots.<br>While the one-robot problem is easy to solve in linear<br>time, already for two robots the complexity is open.<br>Chuangpishit, Czyzowicz, Gasieniec, Georgiou, Jurdzinski,<br>and Kranakis (SOFSEM 2018) found a [Formula: see<br>text]-approximation algorithm. Here we provide a PTAS,<br>accomplished by rounding and (perhaps more surprisingly) by<br>using the well-quasi ordering of vectors of positive<br>integers. The result...","title_summary":" Two Robots Patrolling on a Line: Integer<br>Version and Approximability","x":-21.8954772949,"y":41.4083786011,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.8954772949,"tsne_y":41.4083786011,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"aogk1yra","source_x":"PMC","title":"The Steiner Problem for Count Matroids","doi":"10.1007\/978-3-030-48966-3_25","abstract":"We introduce and study a generalization of the well-known Steiner tree problem to count matroids. In the count matroid [Formula: see text], defined on the edge set of a graph [Formula: see text], a set [Formula: see text] is independent if every vertex set [Formula: see text] spans at most [Formula: see text] edges of F. The graph is called (k, l)-tight if its edge set is independent in [Formula: see text] and [Formula: see text] holds. Given a graph [Formula: see text], a non-negative length function [Formula: see text], a set [Formula: see text] of terminals and parameters k, l, our goal is to find a shortest (k, l)-tight subgraph of G that contains the terminals. Since [Formula: see text] is isomorphic to the graphic matroid of G, the special case [Formula: see text] corresponds to the Steiner tree problem. We obtain other interesting problems by choosing different parameters: for example, in the case [Formula: see text], [Formula: see text] the target is a shortest rigid subgraph containing all terminals. First we show that this problem is NP-hard even if [Formula: see text], [Formula: see text], and w is metric, or [Formula: see text] and [Formula: see text]. As a by-product of this result we obtain that finding a shortest circuit in [Formula: see text] is NP-hard. Then we design a [Formula: see text]-approximation algorithm for the metric version of the problem with parameters [Formula: see text], for all [Formula: see text]. In particular, we obtain a 3-approximation algorithm for the Steiner version of the shortest rigid subgraph problem. We also show that the metric version can be solved in polynomial time for [Formula: see text], [Formula: see text], provided |T| is fixed.","publish_time":1588204800000,"author_summary":" Jord\u00e1n, Tibor; Kobayashi, Yusuke; Mahara,<br>Ryoga; Makino, Kazuhisa","abstract_summary":" We introduce and study a generalization of the<br>well-known Steiner tree problem to count matroids. In the<br>count matroid [Formula: see text], defined on the<br>edge set of a graph [Formula: see text], a set<br>[Formula: see text] is independent if every vertex set<br>[Formula: see text] spans at most [Formula: see text]<br>edges of F. The graph is called (k, l)-tight if its edge<br>set is independent in [Formula: see text] and<br>[Formula: see text] holds. Given a graph [Formula: see<br>text], a non-negative length function [Formula: see<br>text], a set [Formula: see text] of terminals and<br>parameters k,...","title_summary":" The Steiner Problem for Count Matroids","x":-22.5222835541,"y":43.7074775696,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.5222835541,"tsne_y":43.7074775696,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"cib8uyxq","source_x":"PMC","title":"The Micro-world of Cographs","doi":"10.1007\/978-3-030-48966-3_3","abstract":"Cographs constitute a small point in the atlas of graph classes. However, by zooming in on this point, we discover a complex world, where many parameters jump from finiteness to infinity. In the present paper, we identify several milestones in the world of cographs and create a hierarchy of graph parameters grounded on these milestones.","publish_time":1588204800000,"author_summary":" Alecu, Bogdan; Lozin, Vadim; de Werra,<br>Dominique","abstract_summary":" Cographs constitute a small point in the atlas<br>of graph classes. However, by zooming in on this<br>point, we discover a complex world, where many<br>parameters jump from finiteness to infinity. In the<br>present paper, we identify several milestones in the<br>world of cographs and create a hierarchy of graph<br>parameters grounded on these milestones.","title_summary":" The Micro-world of Cographs","x":-22.2856693268,"y":46.2847251892,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.2856693268,"tsne_y":46.2847251892,"subcluster":32,"subcluster_description":"Efficient Normalizers","shape":"p"},{"cord_uid":"sdkycdhk","source_x":"PMC","title":"Between Proper and Strong Edge-Colorings of Subcubic Graphs","doi":"10.1007\/978-3-030-48966-3_27","abstract":"In a proper edge-coloring the edges of every color form a matching. A matching is induced if the end-vertices of its edges induce a matching. A strong edge-coloring is an edge-coloring in which the edges of every color form an induced matching. We consider intermediate types of edge-colorings, where some of the colors are allowed to form matchings, and the remaining form induced matchings. Our research is motivated by the conjecture proposed in a recent paper on S-packing edge-colorings (N. Gastineau and O. Togni, On S-packing edge-colorings of cubic graphs, Discrete Appl. Math. 259 (2019)). We prove that every graph with maximum degree 3 can be decomposed into one matching and at most 8 induced matchings, and two matchings and at most 5 induced matchings. We also show that if a graph is in class I, the number of induced matchings can be decreased by one, hence confirming the conjecture for this class of graphs.","publish_time":1588204800000,"author_summary":" Hocquard, Herv\u00e9; Lajou, Dimitri; Lu\u017ear, Borut","abstract_summary":" In a proper edge-coloring the edges of every<br>color form a matching. A matching is induced if the<br>end-vertices of its edges induce a matching. A strong<br>edge-coloring is an edge-coloring in which the edges of every<br>color form an induced matching. We consider<br>intermediate types of edge-colorings, where some of the<br>colors are allowed to form matchings, and the<br>remaining form induced matchings. Our research is<br>motivated by the conjecture proposed in a recent paper on<br>S-packing edge-colorings (N. Gastineau and O. Togni, On<br>S-packing edge-colorings of cubic graphs, Discrete<br>Appl. Math. 259 (2019)). We prove that every graph...","title_summary":" Between Proper and Strong Edge-Colorings of<br>Subcubic Graphs","x":-22.3260211945,"y":43.3719863892,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.3260211945,"tsne_y":43.3719863892,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"o8yf9l6j","source_x":"PMC","title":"Fair Packing of Independent Sets","doi":"10.1007\/978-3-030-48966-3_12","abstract":"In this work we add a graph theoretical perspective to a classical problem of fairly allocating indivisible items to several agents. Agents have different profit valuations of items and we allow an incompatibility relation between pairs of items described in terms of a conflict graph. Hence, every feasible allocation of items to the agents corresponds to a partial coloring, that is, a collection of pairwise disjoint independent sets. The sum of profits of vertices\/items assigned to one color\/agent should be optimized in a maxi-min sense. We derive complexity and algorithmic results for this problem, which is a generalization of the classical Partition and Independent Set problems. In particular, we show that the problem is strongly NP-complete in the classes of bipartite graphs and their line graphs, and solvable in pseudo-polynomial time in the classes of cocomparability graphs and biconvex bipartite graphs.","publish_time":1588204800000,"author_summary":" Chiarelli, Nina; Krnc, Matja\u017e; Milani\u010d,<br>Martin; Pferschy, Ulrich; Piva\u010d, Nevena; Schauer,<br>Joachim","abstract_summary":" In this work we add a graph theoretical<br>perspective to a classical problem of fairly allocating<br>indivisible items to several agents. Agents have different<br>profit valuations of items and we allow an<br>incompatibility relation between pairs of items described in<br>terms of a conflict graph. Hence, every feasible<br>allocation of items to the agents corresponds to a partial<br>coloring, that is, a collection of pairwise disjoint<br>independent sets. The sum of profits of vertices\/items<br>assigned to one color\/agent should be optimized in a<br>maxi-min sense. We derive complexity and algorithmic<br>results for this problem, which is a generalization of<br>the...","title_summary":" Fair Packing of Independent Sets","x":-22.3420505524,"y":42.963054657,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.3420505524,"tsne_y":42.963054657,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"on906lhf","source_x":"PMC","title":"A Family of Tree-Based Generators for Bubbles in Directed Graphs","doi":"10.1007\/978-3-030-48966-3_2","abstract":"Bubbles are pairs of internally vertex-disjoint (s, t)-paths in a directed graph. In de Bruijn graphs built from reads of RNA and DNA data, bubbles represent interesting biological events, such as alternative splicing (AS) and allelic differences (SNPs and indels). However, the set of all bubbles in a de Bruijn graph built from real data is usually too large to be efficiently enumerated and analysed in practice. In particular, despite significant research done in this area, listing bubbles still remains the main bottleneck for tools that detect AS events in a reference-free context. Recently, in [1] the concept of a bubble generator was introduced as a way for obtaining a compact representation of the bubble space of a graph. Although this generator was quite effective in finding AS events, preliminary experiments showed that it is about 5 times slower than state-of-art methods. In this paper we propose a new family of bubble generators which improve substantially on the previous generator: generators in this new family are about two orders of magnitude faster and are still able to achieve similar precision in identifying AS events. To highlight the practical value of our new generators, we also report some experimental results on a real dataset.","publish_time":1588204800000,"author_summary":" Acu\u00f1a, Vicente; Lima, Leandro; Italiano,<br>Giuseppe F.; Pep\u00e8 Sciarria, Luca; Sagot, Marie-France;<br>Sinaimeri, Blerina","abstract_summary":" Bubbles are pairs of internally<br>vertex-disjoint (s, t)-paths in a directed graph. In de Bruijn<br>graphs built from reads of RNA and DNA data, bubbles<br>represent interesting biological events, such as<br>alternative splicing (AS) and allelic differences (SNPs<br>and indels). However, the set of all bubbles in a de<br>Bruijn graph built from real data is usually too large<br>to be efficiently enumerated and analysed in<br>practice. In particular, despite significant research<br>done in this area, listing bubbles still remains the<br>main bottleneck for tools that detect AS events in a<br>reference-free context. Recently, in [1] the concept of a...","title_summary":" A Family of Tree-Based Generators for Bubbles<br>in Directed Graphs","x":-23.5704288483,"y":43.3589668274,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.5704288483,"tsne_y":43.3589668274,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"nvpljvo1","source_x":"PMC","title":"Acyclic Matching in Some Subclasses of Graphs","doi":"10.1007\/978-3-030-48966-3_31","abstract":"A subset [Formula: see text] of edges of a graph [Formula: see text] is called a matching if no two edges of M share a common vertex. A matching M in a graph G is called an acyclic matching if G[V(M)], the subgraph of G induced by the M-saturated vertices of G is acyclic. The Acyclic Matching Problem is the problem of finding an acyclic matching of maximum size. The decision version of the Acyclic Matching Problem is known to be NP-complete for general graphs as well as for bipartite graphs. In this paper, we strengthen this result by showing that the decision version of the Acyclic Matching Problem remains NP-complete for comb-convex bipartite graphs and dually-chordal graphs. On the positive side, we present linear time algorithms to compute an acyclic matching of maximum size in split graphs and proper interval graphs. Finally, we show that the Acyclic Matching Problem is hard to approximate within a factor of [Formula: see text] for any [Formula: see text], unless [Formula: see text] and the Acyclic Matching Problem is APX-complete for [Formula: see text]-regular graphs for [Formula: see text], where k is a constant.","publish_time":1588204800000,"author_summary":" Panda, B. S.; Chaudhary, Juhi","abstract_summary":" A subset [Formula: see text] of edges of a graph<br>[Formula: see text] is called a matching if no two edges of M<br>share a common vertex. A matching M in a graph G is<br>called an acyclic matching if G[V(M)], the subgraph of<br>G induced by the M-saturated vertices of G is<br>acyclic. The Acyclic Matching Problem is the problem of<br>finding an acyclic matching of maximum size. The<br>decision version of the Acyclic Matching Problem is<br>known to be NP-complete for general graphs as well as<br>for bipartite graphs. In this paper, we strengthen<br>this result by showing...","title_summary":" Acyclic Matching in Some Subclasses of Graphs","x":-22.5602607727,"y":43.4328994751,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.5602607727,"tsne_y":43.4328994751,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"ymfajaf9","source_x":"PMC","title":"Bounded Degree Group Steiner Tree Problems","doi":"10.1007\/978-3-030-48966-3_26","abstract":"Motivated by some open problems posed in [13], we study three problems that seek a low degree subtree T of a graph [Formula: see text]. In the Min-Degree Group Steiner Tree problem we are given a collection of node subsets (groups), and T should contain a node from every group. In the Min-Degree Steiner k-Tree problem we are given a set R of terminals and an integer k, and T should contain k terminals. In both problems the goal is to minimize the maximum degree of T. In the more general Degrees Bounded Min-Cost Group Steiner Tree problem, we are also given edge costs and individual degree bounds [Formula: see text]. The output tree T should obey the degree constraints [Formula: see text] for all [Formula: see text], and among all such trees we seek one of minimum cost. When the input is a tree, an [Formula: see text] approximation for the cost is given in [10]. Our first result generalizes [10] \u2013 we give a bicriteria [Formula: see text]-approximation algorithm for Degrees Bounded Min-Cost Group Steiner Tree problem on tree inputs. This matches the cost ratio of [10] but also approximates the degrees within [Formula: see text]. Our second result shows that if Min-Degree Group Steiner Tree admits ratio [Formula: see text] then Min-Degree Steiner [Formula: see text]-Tree admits ratio [Formula: see text]. Combined with [12], this implies an [Formula: see text]-approximation for Min-Degree Steiner [Formula: see text]-Tree on general graphs, in quasi-polynomial time. Our third result is a polynomial time [Formula: see text]-approximation algorithm for Min-Degree Group Steiner Tree on bounded treewidth graphs.","publish_time":1588204800000,"author_summary":" Kortsarz, Guy; Nutov, Zeev","abstract_summary":" Motivated by some open problems posed in [13],<br>we study three problems that seek a low degree<br>subtree T of a graph [Formula: see text]. In the<br>Min-Degree Group Steiner Tree problem we are given a<br>collection of node subsets (groups), and T should contain a<br>node from every group. In the Min-Degree Steiner<br>k-Tree problem we are given a set R of terminals and an<br>integer k, and T should contain k terminals. In both<br>problems the goal is to minimize the maximum degree of T.<br>In the more general Degrees Bounded Min-Cost<br>Group Steiner Tree problem, we are...","title_summary":" Bounded Degree Group Steiner Tree Problems","x":-22.379907608,"y":43.2671470642,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.379907608,"tsne_y":43.2671470642,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"vp13ppbp","source_x":"PMC","title":"On the Complexity of Broadcast Domination and Multipacking in Digraphs","doi":"10.1007\/978-3-030-48966-3_20","abstract":"We study the complexity of the two dual covering and packing distance-based problems Broadcast Domination and Multipacking in digraphs. A dominating broadcast of a digraph D is a function [Formula: see text] such that for each vertex v of D, there exists a vertex t with [Formula: see text] having a directed path to v of length at most f(t). The cost of f is the sum of f(v) over all vertices v. A multipacking is a set S of vertices of D such that for each vertex v of D and for every integer d, there are at most d vertices from S within directed distance at most d from v. The maximum size of a multipacking of D is a lower bound to the minimum cost of a dominating broadcast of D. Let Broadcast Domination denote the problem of deciding whether a given digraph D has a dominating broadcast of cost at most k, and Multipacking the problem of deciding whether D has a multipacking of size at least k. It is known that Broadcast Domination is polynomial-time solvable for the class of all undirected graphs (that is, symmetric digraphs), while polynomial-time algorithms for Multipacking are known only for a few classes of undirected graphs. We prove that Broadcast Domination and Multipacking are both NP-complete for digraphs, even for planar layered acyclic digraphs of small maximum degree. Moreover, when parameterized by the solution cost\/solution size, we show that the problems are respectively W[2]-hard and W[1]-hard. We also show that Broadcast Domination is FPT on acyclic digraphs, and that it does not admit a polynomial kernel for such inputs, unless the polynomial hierarchy collapses to its third level. In addition, we show that both problems are FPT when parameterized by the solution cost\/solution size together with the maximum out-degree. Finally, we give for both problems polynomial-time algorithms for some subclasses of acyclic digraphs.","publish_time":1588204800000,"author_summary":" Foucaud, Florent; Gras, Benjamin; Perez,<br>Anthony; Sikora, Florian","abstract_summary":" We study the complexity of the two dual covering<br>and packing distance-based problems Broadcast<br>Domination and Multipacking in digraphs. A dominating<br>broadcast of a digraph D is a function [Formula: see text]<br>such that for each vertex v of D, there exists a vertex<br>t with [Formula: see text] having a directed path<br>to v of length at most f(t). The cost of f is the sum of<br>f(v) over all vertices v. A multipacking is a set S of<br>vertices of D such that for each vertex v of D and for every<br>integer d, there are at most...","title_summary":" On the Complexity of Broadcast Domination and<br>Multipacking in Digraphs","x":-22.365272522,"y":43.2217788696,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.365272522,"tsne_y":43.2217788696,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"xaoh4929","source_x":"PMC","title":"On the Complexity of Singly Connected Vertex Deletion","doi":"10.1007\/978-3-030-48966-3_18","abstract":"A digraph D is singly connected if for all ordered pairs of vertices [Formula: see text], there is at most one path in D from u to v. In this paper, we study the Singly Connected Vertex Deletion (SCVD) problem: Given an n-vertex digraph D and a positive integer k, does there exist a set [Formula: see text] such that [Formula: see text] and [Formula: see text] is singly connected? This problem may be seen as a directed counterpart of the (Undirected) Feedback Vertex Set problem, as an undirected graph is singly connected if and only if it is acyclic. SCVD is known to be NP-hard on general digraphs. We study the complexity of SCVD on various classes of digraphs such as tournaments, and various generalisations of tournaments such as digraphs of bounded independence number, in- and out-tournaments and local tournaments. We show that unlike the Feedback Vertex Set on Tournaments (FVST) problem, SCVD is polynomial time solvable on tournaments. In addition, we show that SCVD is polynomial time solvable on digraphs of bounded independence number, and on the class of acyclic local tournaments. We also study the parameterized complexity of SCVD, with k as the parameter, on the class of in-tournaments. And we show that on in-tournaments (and out-tournaments), SCVD admits a fixed-parameter tractable algorithm and a quadratic kernel. We also show that on the class of local tournaments, which is a sub-class of in-tournaments, SCVD admits a linear kernel.","publish_time":1588204800000,"author_summary":" Das, Avinandan; Kanesh, Lawqueen; Madathil,<br>Jayakrishnan; Muluk, Komal; Purohit, Nidhi; Saurabh, Saket","abstract_summary":" A digraph D is singly connected if for all<br>ordered pairs of vertices [Formula: see text], there is<br>at most one path in D from u to v. In this paper, we<br>study the Singly Connected Vertex Deletion (SCVD)<br>problem: Given an n-vertex digraph D and a positive<br>integer k, does there exist a set [Formula: see text]<br>such that [Formula: see text] and [Formula: see<br>text] is singly connected? This problem may be seen as<br>a directed counterpart of the (Undirected)<br>Feedback Vertex Set problem, as an undirected graph is<br>singly connected if and only if it is acyclic....","title_summary":" On the Complexity of Singly Connected Vertex<br>Deletion","x":-22.4791259766,"y":43.4343452454,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4791259766,"tsne_y":43.4343452454,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"ehc3186z","source_x":"PMC","title":"Nonexistence Certificates for Ovals in a Projective Plane of Order Ten","doi":"10.1007\/978-3-030-48966-3_8","abstract":"In 1983, a computer search was performed for ovals in a projective plane of order ten. The search was exhaustive and negative, implying that such ovals do not exist. However, no nonexistence certificates were produced by this search, and to the best of our knowledge the search has never been independently verified. In this paper, we rerun the search for ovals in a projective plane of order ten and produce a collection of nonexistence certificates that, when taken together, imply that such ovals do not exist. Our search program uses the cube-and-conquer paradigm from the field of satisfiability (SAT) checking, coupled with a programmatic SAT solver and the nauty symbolic computation library for removing symmetries from the search.","publish_time":1588204800000,"author_summary":" Bright, Curtis; Cheung, Kevin K. H.; Stevens,<br>Brett; Kotsireas, Ilias; Ganesh, Vijay","abstract_summary":" In 1983, a computer search was performed for<br>ovals in a projective plane of order ten. The search<br>was exhaustive and negative, implying that such<br>ovals do not exist. However, no nonexistence<br>certificates were produced by this search, and to the best of<br>our knowledge the search has never been<br>independently verified. In this paper, we rerun the search for<br>ovals in a projective plane of order ten and produce a<br>collection of nonexistence certificates that, when taken<br>together, imply that such ovals do not exist. Our search<br>program uses the cube-and-conquer paradigm from the<br>field of satisfiability (SAT) checking,...","title_summary":" Nonexistence Certificates for Ovals in a<br>Projective Plane of Order Ten","x":-22.5540008545,"y":45.3575592041,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.5540008545,"tsne_y":45.3575592041,"subcluster":20,"subcluster_description":"Classic Real Number Representations","shape":"p"},{"cord_uid":"hwef35a9","source_x":"PMC","title":"Optimal In-place Algorithms for Basic Graph Problems","doi":"10.1007\/978-3-030-48966-3_10","abstract":"We present linear time in-place algorithms for several fundamental graph problems including the well-known graph search methods (like depth-first search, breadth-first search, maximum cardinality search), connectivity problems (like biconnectivity, 2-edge connectivity), decomposition problem (like chain decomposition) among various others, improving the running time (by polynomial multiplicative factor) of the recent results of Chakraborty et al. [ESA, 2018] who designed [Formula: see text] time in-place algorithms for some of the above mentioned problems. The running times of all our algorithms are essentially optimal as they run in linear time. One of the main ideas behind obtaining these algorithms is the detection and careful exploitation of sortedness present in the input representation for any graph without loss of generality. This observation alone is powerful enough to design some basic linear time in-place algorithms, but more non-trivial graph problems require extra techniques which, we believe, may find other applications while designing in-place algorithms for different graph problems in future.","publish_time":1588204800000,"author_summary":" Chakraborty, Sankardeep; Sadakane,<br>Kunihiko; Satti, Srinivasa Rao","abstract_summary":" We present linear time in-place algorithms for<br>several fundamental graph problems including the<br>well-known graph search methods (like depth-first<br>search, breadth-first search, maximum cardinality<br>search), connectivity problems (like biconnectivity,<br>2-edge connectivity), decomposition problem (like<br>chain decomposition) among various others,<br>improving the running time (by polynomial<br>multiplicative factor) of the recent results of Chakraborty et<br>al. [ESA, 2018] who designed [Formula: see text]<br>time in-place algorithms for some of the above<br>mentioned problems. The running times of all our<br>algorithms are essentially optimal as they run in linear<br>time. One of the main ideas behind obtaining these<br>algorithms is the detection...","title_summary":" Optimal In-place Algorithms for Basic Graph<br>Problems","x":-22.5546894073,"y":43.014957428,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.5546894073,"tsne_y":43.014957428,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"bgstpile","source_x":"PMC","title":"Edge-Disjoint Branchings in Temporal Graphs","doi":"10.1007\/978-3-030-48966-3_9","abstract":"A temporal digraph [Formula: see text] is a triple [Formula: see text] where G is a digraph, [Formula: see text] is a function on V(G) that tells us the time stamps when a vertex is active, and [Formula: see text] is a function on E(G) that tells for each [Formula: see text] when u and v are linked. Given a static digraph G, and a subset [Formula: see text], a spanning branching with root R is a subdigraph of G that has exactly one path from R to each [Formula: see text]. In this paper, we consider the temporal version of Edmonds\u2019 classical result about the problem of finding k edge-disjoint spanning branchings respectively rooted at given [Formula: see text]. We introduce and investigate different definitions of spanning branchings, and of edge-disjointness in the context of temporal graphs. A branching [Formula: see text] is vertex-spanning if the root is able to reach each vertex v of G at some time where v is active, while it is temporal-spanning if v can be reached from the root at every time where v is active. On the other hand, two branchings [Formula: see text] and [Formula: see text] are edge-disjoint if they do not use the same edge of G, and are temporal-edge-disjoint if they can use the same edge of G but at different times. This lead us to four definitions of disjoint spanning branchings and we prove that, unlike the static case, only one of these can be computed in polynomial time, namely the temporal-edge-disjoint temporal-spanning branchings problem, while the other versions are [Formula: see text]-complete, even under very strict assumptions.","publish_time":1588204800000,"author_summary":" Campos, Victor; Lopes, Raul; Marino, Andrea;<br>Silva, Ana","abstract_summary":" A temporal digraph [Formula: see text] is a<br>triple [Formula: see text] where G is a digraph,<br>[Formula: see text] is a function on V(G) that tells us the<br>time stamps when a vertex is active, and [Formula:<br>see text] is a function on E(G) that tells for each<br>[Formula: see text] when u and v are linked. Given a static<br>digraph G, and a subset [Formula: see text], a spanning<br>branching with root R is a subdigraph of G that has exactly<br>one path from R to each [Formula: see text]. In this<br>paper, we consider the temporal version...","title_summary":" Edge-Disjoint Branchings in Temporal Graphs","x":-22.6340885162,"y":43.7059059143,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.6340885162,"tsne_y":43.7059059143,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"o2mc83eu","source_x":"PMC","title":"Parameterized Algorithms for Partial Vertex Covers in Bipartite Graphs","doi":"10.1007\/978-3-030-48966-3_30","abstract":"In this paper, we discuss parameterized algorithms for variants of the partial vertex cover problem. Recall that in the classical vertex cover problem (VC), we are given a graph [Formula: see text] and a number K and asked if we can cover all of the edges in E, using at most K vertices from V. In the partial vertex cover problem (PVC), in addition to the parameter K, we are given a second parameter [Formula: see text] and the question is whether we can cover at least [Formula: see text] of the edges in E using at most K vertices from V. The weighted generalizations of the VC and PVC problems are called the weighted vertex cover (WVC) and the partial weighted vertex cover problem (WPVC) respectively. In the WPVC problem, we are given two parameters R and L, associated respectively with the vertex set V and edge set E of the graph [Formula: see text]. Additionally, we are given non-negative integral weight functions for the vertices and the edges. The goal then is to cover edges of total weight at least L, using vertices of total weight at most R. (In the WVC problem, the goal is to cover all the edges with vertices whose total weight is at most R). This paper studies several variants of the PVC problem and establishes new results from the perspective of fixed-parameter tractability and W[1]-hardness. We also introduce a new problem called the partial vertex cover with matching constraint and show that it is fixed-parameter tractable for a certain class of graphs.","publish_time":1588204800000,"author_summary":" Mkrtchyan, Vahan; Petrosyan, Garik;<br>Subramani, K.; Wojciechowski, Piotr","abstract_summary":" In this paper, we discuss parameterized<br>algorithms for variants of the partial vertex cover<br>problem. Recall that in the classical vertex cover<br>problem (VC), we are given a graph [Formula: see text]<br>and a number K and asked if we can cover all of the<br>edges in E, using at most K vertices from V. In the<br>partial vertex cover problem (PVC), in addition to the<br>parameter K, we are given a second parameter [Formula: see<br>text] and the question is whether we can cover at least<br>[Formula: see text] of the edges in E using at most K<br>vertices...","title_summary":" Parameterized Algorithms for Partial Vertex<br>Covers in Bipartite Graphs","x":-22.4440422058,"y":43.2938308716,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4440422058,"tsne_y":43.2938308716,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"lkbknxeq","source_x":"PMC","title":"Skyline Computation with Noisy Comparisons","doi":"10.1007\/978-3-030-48966-3_22","abstract":"Given a set of n points in a d-dimensional space, we seek to compute the skyline, i.e., those points that are not strictly dominated by any other point, using few comparisons between elements. We adopt the noisy comparison model [15] where comparisons fail with constant probability and confidence can be increased through independent repetitions of a comparison. In this model motivated by Crowdsourcing applications, Groz and Milo [18] show three bounds on the query complexity for the skyline problem. We improve significantly on that state of the art and provide two output-sensitive algorithms computing the skyline with respective query complexity [Formula: see text] and [Formula: see text], where k is the size of the skyline and [Formula: see text] the expected probability that our algorithm fails to return the correct answer. These results are tight for low dimensions.","publish_time":1588204800000,"author_summary":" Groz, Beno\u00eet; Mallmann-Trenn, Frederik;<br>Mathieu, Claire; Verdugo, Victor","abstract_summary":" Given a set of n points in a d-dimensional space,<br>we seek to compute the skyline, i.e., those points<br>that are not strictly dominated by any other point,<br>using few comparisons between elements. We adopt the<br>noisy comparison model [15] where comparisons fail<br>with constant probability and confidence can be<br>increased through independent repetitions of a<br>comparison. In this model motivated by Crowdsourcing<br>applications, Groz and Milo [18] show three bounds on the query<br>complexity for the skyline problem. We improve<br>significantly on that state of the art and provide two<br>output-sensitive algorithms computing the skyline with<br>respective query complexity...","title_summary":" Skyline Computation with Noisy Comparisons","x":-22.170085907,"y":42.6749649048,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.170085907,"tsne_y":42.6749649048,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"0v61sin9","source_x":"PMC","title":"Equitable d-degenerate Choosability of Graphs","doi":"10.1007\/978-3-030-48966-3_19","abstract":"Let [Formula: see text] be the class of d-degenerate graphs and let L be a list assignment for a graph G. A colouring of G such that every vertex receives a colour from its list and the subgraph induced by vertices coloured with one color is a d-degenerate graph is called the [Formula: see text]-colouring of G. For a k-uniform list assignment L and [Formula: see text], a graph G is equitably [Formula: see text]-colorable if there is an [Formula: see text]-colouring of G such that the size of any colour class does not exceed [Formula: see text]. An equitable [Formula: see text]-colouring is a generalization of an equitable list coloring, introduced by Kostochka et al., and an equitable list arboricity presented by Zhang. Such a model can be useful in the network decomposition where some structural properties on subnets are imposed. In this paper we give a polynomial-time algorithm that for a given (k, d)-partition of G with a t-uniform list assignment L and [Formula: see text], returns its equitable [Formula: see text]-colouring. In addition, we show that 3-dimensional grids are equitably [Formula: see text]-colorable for any t-uniform list assignment L where [Formula: see text].","publish_time":1588204800000,"author_summary":" Drgas-Burchardt, Ewa; Furma\u0144czyk, Hanna;<br>Sidorowicz, El\u017cbieta","abstract_summary":" Let [Formula: see text] be the class of<br>d-degenerate graphs and let L be a list assignment for a graph<br>G. A colouring of G such that every vertex receives<br>a colour from its list and the subgraph induced by<br>vertices coloured with one color is a d-degenerate graph<br>is called the [Formula: see text]-colouring of G.<br>For a k-uniform list assignment L and [Formula: see<br>text], a graph G is equitably [Formula: see<br>text]-colorable if there is an [Formula: see text]-colouring of<br>G such that the size of any colour class does not<br>exceed [Formula: see text]. An equitable...","title_summary":" Equitable d-degenerate Choosability of<br>Graphs","x":-22.5188560486,"y":43.6139411926,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.5188560486,"tsne_y":43.6139411926,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"qknpwgqs","source_x":"PMC","title":"Iterated Type Partitions","doi":"10.1007\/978-3-030-48966-3_15","abstract":"This paper introduces a novel parameter, called iterated type partition, that can be computed in polynomial time and nicely places between modular-width and neighborhood diversity. We prove that the Equitable Coloring problem is W[1]-hard when parametrized by the iterated type partition. This result extends to modular-width, answering an open question on the complexity of Equitable Coloring when parametrized by modular-width. On the contrary, we show that the Equitable Coloring problem is FPT when parameterized by neighborhood diversity. Furthermore, we present a scheme for devising FPT algorithms parameterized by iterated type partition, which enables us to find optimal solutions for several graph problems. While the considered problems are already known to be FPT with respect to modular-width, the novel algorithms are both simpler and more efficient. As an example, in this paper, we give an algorithm for the Dominating Set problem that outputs an optimal set in time [Formula: see text], where n and t are the size and the iterated type partition of the input graph, respectively.","publish_time":1588204800000,"author_summary":" Cordasco, Gennaro; Gargano, Luisa; Rescigno,<br>Adele A.","abstract_summary":" This paper introduces a novel parameter,<br>called iterated type partition, that can be computed<br>in polynomial time and nicely places between<br>modular-width and neighborhood diversity. We prove that the<br>Equitable Coloring problem is W[1]-hard when<br>parametrized by the iterated type partition. This result<br>extends to modular-width, answering an open question<br>on the complexity of Equitable Coloring when<br>parametrized by modular-width. On the contrary, we show that<br>the Equitable Coloring problem is FPT when<br>parameterized by neighborhood diversity. Furthermore, we<br>present a scheme for devising FPT algorithms<br>parameterized by iterated type partition, which enables us to<br>find optimal solutions for several...","title_summary":" Iterated Type Partitions","x":-22.8729515076,"y":43.2312316895,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.8729515076,"tsne_y":43.2312316895,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"zzrakyw2","source_x":"PMC","title":"Connectivity Keeping Trees in 2-Connected Graphs with Girth Conditions","doi":"10.1007\/978-3-030-48966-3_24","abstract":"Mader conjectured in 2010 that for any tree T of order m, every k-connected graph G with minimum degree at least [Formula: see text] contains a subtree [Formula: see text] such that [Formula: see text] is k-connected. This conjecture has been proved for [Formula: see text]; however, it remains open for general [Formula: see text]; for [Formula: see text], partially affirmative answers have been shown, all of which restrict the class of trees to special subclasses such as trees of order at most 8, trees with diameter at most 4, trees with at most 5 internal vertices, and caterpillars. Instead of restricting the class of trees, we consider 2-connected graphs with girth conditions. We then show that Mader\u2019s conjecture is true for every 2-connected graph G with [Formula: see text], where g(G) and [Formula: see text] denote the girth of G and the minimum degree of a vertex in G, respectively. Besides, we show that for every 2-connected graph G with [Formula: see text], the lower bound of [Formula: see text] on [Formula: see text] in Mader\u2019s conjecture can be improved to [Formula: see text] if [Formula: see text]. Moreover, the lower bound of [Formula: see text] (respectively, [Formula: see text]) on g(G) in these results can be improved to [Formula: see text] (respectively, [Formula: see text] with [Formula: see text]) if no six (respectively, four) cycles of length g(G) have a common path of length [Formula: see text] in G. Mader\u2019s conjecture is interesting not only from a theoretical point of view but also from a practical point of view, since it may be applied to fault-tolerant problems in communication networks. Our proofs lead to [Formula: see text] time algorithms for finding a desired subtree in a given 2-connected graph G satisfying the assumptions.","publish_time":1588204800000,"author_summary":" Hasunuma, Toru","abstract_summary":" Mader conjectured in 2010 that for any tree T of<br>order m, every k-connected graph G with minimum<br>degree at least [Formula: see text] contains a subtree<br>[Formula: see text] such that [Formula: see text] is<br>k-connected. This conjecture has been proved for [Formula:<br>see text]; however, it remains open for general<br>[Formula: see text]; for [Formula: see text], partially<br>affirmative answers have been shown, all of which restrict<br>the class of trees to special subclasses such as<br>trees of order at most 8, trees with diameter at most 4,<br>trees with at most 5 internal vertices, and<br>caterpillars. Instead...","title_summary":" Connectivity Keeping Trees in 2-Connected<br>Graphs with Girth Conditions","x":-22.5026702881,"y":43.6291313171,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.5026702881,"tsne_y":43.6291313171,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"w5gn7a7k","source_x":"PMC","title":"Strongly Stable and Maximum Weakly Stable Noncrossing Matchings","doi":"10.1007\/978-3-030-48966-3_23","abstract":"In IWOCA 2019, Ruangwises and Itoh introduced stable noncrossing matchings, where participants of each side are aligned on each of two parallel lines, and no two matching edges are allowed to cross each other. They defined two stability notions, strongly stable noncrossing matching (SSNM) and weakly stable noncrossing matching (WSNM), depending on the strength of blocking pairs. They proved that a WSNM always exists and presented an [Formula: see text]-time algorithm to find one for an instance with n men and n women. They also posed open questions of the complexities of determining existence of an SSNM and finding a largest WSNM. In this paper, we show that both problems are solvable in polynomial time. Our algorithms are applicable to extensions where preference lists may include ties, except for one case which we show to be NP-complete.","publish_time":1588204800000,"author_summary":" Hamada, Koki; Miyazaki, Shuichi; Okamoto,<br>Kazuya","abstract_summary":" In IWOCA 2019, Ruangwises and Itoh introduced<br>stable noncrossing matchings, where participants of<br>each side are aligned on each of two parallel lines,<br>and no two matching edges are allowed to cross each<br>other. They defined two stability notions, strongly<br>stable noncrossing matching (SSNM) and weakly stable<br>noncrossing matching (WSNM), depending on the strength of<br>blocking pairs. They proved that a WSNM always exists and<br>presented an [Formula: see text]-time algorithm to find<br>one for an instance with n men and n women. They also<br>posed open questions of the complexities of<br>determining existence of an SSNM and finding a...","title_summary":" Strongly Stable and Maximum Weakly Stable<br>Noncrossing Matchings","x":-22.2473316193,"y":43.5249519348,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.2473316193,"tsne_y":43.5249519348,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"rja8m1bp","source_x":"PMC","title":"Decremental Optimization of Dominating Sets Under the Reconfiguration Framework","doi":"10.1007\/978-3-030-48966-3_6","abstract":"Given a dominating set, how much smaller a dominating set can we find through elementary operations? Here, we proceed by iterative vertex addition and removal while maintaining the property that the set forms a dominating set of bounded size. This can be seen as the optimization variant of the dominating set reconfiguration problem, where two dominating sets are given and the question is merely whether they can be reached from one another through elementary operations. We show that this problem is PSPACE-complete, even if the input graph is a bipartite graph, a split graph, or has bounded pathwidth. On the positive side, we give linear-time algorithms for cographs, trees and interval graphs. We also study the parameterized complexity of this problem. More precisely, we show that the problem is W[2]-hard when parameterized by the upper bound on the size of an intermediary dominating set. On the other hand, we give fixed-parameter algorithms with respect to the minimum size of a vertex cover, or [Formula: see text] where d is the degeneracy and s is the upper bound of the output solution.","publish_time":1588204800000,"author_summary":" Blanch\u00e9, Alexandre; Mizuta, Haruka; Ouvrard,<br>Paul; Suzuki, Akira","abstract_summary":" Given a dominating set, how much smaller a<br>dominating set can we find through elementary operations?<br>Here, we proceed by iterative vertex addition and<br>removal while maintaining the property that the set<br>forms a dominating set of bounded size. This can be<br>seen as the optimization variant of the dominating<br>set reconfiguration problem, where two<br>dominating sets are given and the question is merely<br>whether they can be reached from one another through<br>elementary operations. We show that this problem is<br>PSPACE-complete, even if the input graph is a bipartite graph, a<br>split graph, or has bounded pathwidth. On the...","title_summary":" Decremental Optimization of Dominating Sets<br>Under the Reconfiguration Framework","x":-22.6171779633,"y":43.0234069824,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.6171779633,"tsne_y":43.0234069824,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"f555a0ek","source_x":"PMC","title":"Polynomial Time Algorithms for Tracking Path Problems","doi":"10.1007\/978-3-030-48966-3_13","abstract":"Given a graph G, and terminal vertices s and t, the Tracking Paths problem asks to compute a minimum number of vertices to be marked as trackers, such that the sequence of trackers encountered in each [Formula: see text]-[Formula: see text] path is unique. Tracking Paths is NP-hard in both directed and undirected graphs in general. In this paper we give a collection of polynomial time algorithms for some restricted versions of Tracking Paths. We prove that Tracking Paths is polynomial time solvable for chordal graphs and tournament graphs. We prove that Tracking Paths is NP-hard in graphs with bounded maximum degree [Formula: see text], and give a [Formula: see text]-approximate algorithm for the same. We also analyze the version of tracking [Formula: see text]-[Formula: see text] paths where paths are tracked using edges instead of vertices, and we give a polynomial time algorithm for the same. Finally we give a polynomial algorithm which, given an undirected graph G, a tracking set [Formula: see text], and a sequence of trackers [Formula: see text], returns the unique [Formula: see text]-[Formula: see text] path in G that corresponds to [Formula: see text], if one exists.","publish_time":1588204800000,"author_summary":" Choudhary, Pratibha","abstract_summary":" Given a graph G, and terminal vertices s and t,<br>the Tracking Paths problem asks to compute a<br>minimum number of vertices to be marked as trackers,<br>such that the sequence of trackers encountered in<br>each [Formula: see text]-[Formula: see text] path<br>is unique. Tracking Paths is NP-hard in both<br>directed and undirected graphs in general. In this paper<br>we give a collection of polynomial time<br>algorithms for some restricted versions of Tracking<br>Paths. We prove that Tracking Paths is polynomial time<br>solvable for chordal graphs and tournament graphs. We<br>prove that Tracking Paths is NP-hard in graphs with<br>bounded...","title_summary":" Polynomial Time Algorithms for Tracking Path<br>Problems","x":-22.4259643555,"y":43.4017448425,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4259643555,"tsne_y":43.4017448425,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"5abiajbm","source_x":"PMC","title":"Improved Budgeted Connected Domination and Budgeted Edge-Vertex Domination","doi":"10.1007\/978-3-030-48966-3_28","abstract":"We consider the Budgeted version of the classical Connected Dominating Set problem (BCDS). Given a graph G and a budget k, we seek a connected subset of at most k vertices maximizing the number of dominated vertices in G. We improve over the previous [Formula: see text] approximation in [Khuller, Purohit, and Sarpatwar, SODA 2014] by introducing a new method for performing tree decompositions in the analysis of the last part of the algorithm. This new approach provides a [Formula: see text] approximation guarantee. By generalizing the analysis of the first part of the algorithm, we are able to modify it appropriately and obtain a further improvement to [Formula: see text]. On the other hand, we prove a [Formula: see text] inapproximability bound, for any [Formula: see text]. We also examine the edge-vertex domination variant, where an edge dominates its endpoints and all vertices neighboring them. In Budgeted Edge-Vertex Domination (BEVD), we are given a graph G, and a budget k, and we seek a, not necessarily connected, subset of k edges such that the number of dominated vertices in G is maximized. We prove there exists a [Formula: see text]-approximation algorithm. Also, for any [Formula: see text], we present a [Formula: see text]-inapproximability result by a gap-preserving reduction from the maximum coverage problem. Finally, we examine the \u201cdual\u201d Partial Edge-Vertex Domination (PEVD) problem, where a graph G and a quota [Formula: see text] are given. The goal is to select a minimum-size set of edges to dominate at least [Formula: see text] vertices in G. In this case, we present a [Formula: see text]-approximation algorithm by a reduction to the partial cover problem.","publish_time":1588204800000,"author_summary":" Lamprou, Ioannis; Sigalas, Ioannis;<br>Zissimopoulos, Vassilis","abstract_summary":" We consider the Budgeted version of the<br>classical Connected Dominating Set problem (BCDS).<br>Given a graph G and a budget k, we seek a connected<br>subset of at most k vertices maximizing the number of<br>dominated vertices in G. We improve over the previous<br>[Formula: see text] approximation in [Khuller, Purohit,<br>and Sarpatwar, SODA 2014] by introducing a new<br>method for performing tree decompositions in the<br>analysis of the last part of the algorithm. This new<br>approach provides a [Formula: see text] approximation<br>guarantee. By generalizing the analysis of the first part<br>of the algorithm, we are able to modify...","title_summary":" Improved Budgeted Connected Domination and<br>Budgeted Edge-Vertex Domination","x":-22.3938293457,"y":43.1656723022,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.3938293457,"tsne_y":43.1656723022,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"tmk79okg","source_x":"PMC","title":"Parameterized Complexity of [Formula: see text]-Path Packing","doi":"10.1007\/978-3-030-48966-3_4","abstract":"Given a graph [Formula: see text], [Formula: see text], and integers k and [Formula: see text], the [Formula: see text] -Path Packing problem asks to find k vertex-disjoint paths of length [Formula: see text] that have endpoints in A and internal points in [Formula: see text]. We study the parameterized complexity of this problem with parameters |A|, [Formula: see text], k, treewidth, pathwidth, and their combinations. We present sharp complexity contrasts with respect to these parameters. Among other results, we show that the problem is polynomial-time solvable when [Formula: see text], while it is NP-complete for constant [Formula: see text]. We also show that the problem is W[1]-hard parameterized by pathwidth[Formula: see text], while it is fixed-parameter tractable parameterized by treewidth[Formula: see text].","publish_time":1588204800000,"author_summary":" Belmonte, R\u00e9my; Hanaka, Tesshu; Kanzaki,<br>Masaaki; Kiyomi, Masashi; Kobayashi, Yasuaki;<br>Kobayashi, Yusuke; Lampis, Michael; Ono, Hirotaka;<br>Otachi, Yota","abstract_summary":" Given a graph [Formula: see text], [Formula:<br>see text], and integers k and [Formula: see text],<br>the [Formula: see text] -Path Packing problem asks<br>to find k vertex-disjoint paths of length<br>[Formula: see text] that have endpoints in A and internal<br>points in [Formula: see text]. We study the<br>parameterized complexity of this problem with parameters<br>|A|, [Formula: see text], k, treewidth, pathwidth,<br>and their combinations. We present sharp<br>complexity contrasts with respect to these parameters.<br>Among other results, we show that the problem is<br>polynomial-time solvable when [Formula: see text], while it is<br>NP-complete for constant [Formula: see text]....","title_summary":" Parameterized Complexity of [Formula: see<br>text]-Path Packing","x":-22.6217880249,"y":43.86145401,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.6217880249,"tsne_y":43.86145401,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"uvod1hmv","source_x":"PMC","title":"On Proper Labellings of Graphs with Minimum Label Sum","doi":"10.1007\/978-3-030-48966-3_5","abstract":"The 1-2-3 Conjecture states that every nice graph G (without component isomorphic to [Formula: see text]) admits a proper 3-labelling, i.e., a labelling of the edges with 1, 2, 3 such that no two adjacent vertices are incident to the same sum of labels. Another interpretation of this conjecture is that every nice graph G can be turned into a locally irregular multigraph M, i.e., with no two adjacent vertices of the same degree, by replacing each edge by at most three parallel edges. In other words, for every nice graph G, there should exist a locally irregular multigraph M with the same adjacencies and having few edges. We study proper labellings of graphs with the extra requirement that the sum of assigned labels must be as small as possible. That is, given a graph G, we are looking for a locally irregular multigraph [Formula: see text] with the fewest edges possible that can be obtained from G by replacing edges with parallel edges. This problem is quite different from the 1-2-3 Conjecture, as we prove that there is no k such that [Formula: see text] can always be obtained from G by replacing each edge with at most k parallel edges. We investigate several aspects of this problem. We prove that the problem of designing proper labellings with minimum label sum is [Formula: see text]-hard in general, but solvable in polynomial time for graphs with bounded treewidth. We also conjecture that every nice connected graph G admits a proper labelling with label sum at most [Formula: see text], which we verify for several classes of graphs.","publish_time":1588204800000,"author_summary":" Bensmail, Julien; Fioravantes, Foivos;<br>Nisse, Nicolas","abstract_summary":" The 1-2-3 Conjecture states that every nice<br>graph G (without component isomorphic to [Formula:<br>see text]) admits a proper 3-labelling, i.e., a<br>labelling of the edges with 1, 2, 3 such that no two adjacent<br>vertices are incident to the same sum of labels. Another<br>interpretation of this conjecture is that every nice graph G can<br>be turned into a locally irregular multigraph M,<br>i.e., with no two adjacent vertices of the same<br>degree, by replacing each edge by at most three parallel<br>edges. In other words, for every nice graph G, there<br>should exist a locally irregular multigraph M...","title_summary":" On Proper Labellings of Graphs with Minimum<br>Label Sum","x":-22.4418048859,"y":43.5242347717,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4418048859,"tsne_y":43.5242347717,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"iahart50","source_x":"PMC","title":"Further Results on Online Node- and Edge-Deletion Problems with Advice","doi":"10.1007\/978-3-030-48966-3_11","abstract":"In online edge- and node-deletion problems the input arrives node by node and an algorithm has to delete nodes or edges in order to keep the input graph in a given graph class at all times. We consider graph classes that can be characterized by forbidden sets of induced subgraphs and analyze the advice complexity of getting an optimal solution. We give almost tight lower and upper bounds for the [Image: see text] , where there is one forbidden induced subgraph that may or may not be disconnected and tight bounds on the [Image: see text] , where we have an arbitrary number of forbidden connected graphs. For the latter result we present an algorithm that computes the advice complexity directly from [Formula: see text]. For the [Image: see text] the advice complexity is basically an easy function of the size of the biggest component in H.","publish_time":1588204800000,"author_summary":" Chen, Li-Hsuan; Hung, Ling-Ju; Lotze, Henri;<br>Rossmanith, Peter","abstract_summary":" In online edge- and node-deletion problems the<br>input arrives node by node and an algorithm has to<br>delete nodes or edges in order to keep the input graph in<br>a given graph class at all times. We consider<br>graph classes that can be characterized by forbidden<br>sets of induced subgraphs and analyze the advice<br>complexity of getting an optimal solution. We give almost<br>tight lower and upper bounds for the [Image: see text]<br>, where there is one forbidden induced subgraph<br>that may or may not be disconnected and tight bounds<br>on the [Image: see text] , where we have...","title_summary":" Further Results on Online Node- and<br>Edge-Deletion Problems with Advice","x":-22.5614624023,"y":43.2249641418,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.5614624023,"tsne_y":43.2249641418,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"oi17m6gu","source_x":"PMC","title":"Optimizing Self-organizing Lists-on-Lists Using Transitivity and Pursuit-Enhanced Object Partitioning","doi":"10.1007\/978-3-030-49161-1_20","abstract":"The study of Self-organizing lists deals with the problem of lowering the average-case asymptotic cost of a list data structure receiving query accesses in Non-stationary Environments (NSEs) with the so-called \u201clocality of reference\u201d property. The de facto schemes for Adaptive lists in such Environments are the Move To Front (MTF) and Transposition (TR) rules. However, significant drawbacks exist in the asymptotic accuracy and speed of list re-organization for the MTF and TR rules. This paper improves on these schemes using the design of an Adaptive list data structure as a hierarchical data \u201csub\u201d-structure. In this framework, we employ a hierarchical Singly-Linked-Lists on Singly-Linked-Lists (SLLs-on-SLLs) design, which divides the list data structure into an outer and inner list context. The inner-list context is itself a SLLs containing sub-elements of the list, while the outer-list context contains these sublist partitions as its primitive elements. The elements belonging to a particular sublist partition are determined using reinforcement learning schemes from the theory of Learning Automata. In this paper, we show that the Transitivity Pursuit-Enhanced Object Migration Automata (TPEOMA) can be used in conjunction with the hierarchical SLLs-on-SLLs as the dependence capturing mechanism to learn the probabilistic distribution of the elements in the Environment. The idea of Transitivity builds on the Pursuit concept that injects a noise filter into the EOMA to filter divergent queries from the Environment, thereby increasing the likelihood of training the Automaton to approximate the \u201ctrue\u201d distribution of the Environment. By taking advantage of the Transitivity phenomenon based on the statistical distribution of the queried elements, we can infer \u201cdependent\u201d query pairs from non-accessed elements in the transitivity relation. The TPEOMA-enhanced hierarchical SLLs-on-SLLs schemes results in superior performances to the MTF and TR schemes as well as to the EOMA-enhanced hierarchical SLLs-on-SLLs schemes in NSEs. However, the results are observed to have superior performances to the PEOMA-enhanced hierarchical schemes in Environments with a Periodic non-stationary distribution but were inferior in Markovian Switching Environments.","publish_time":1588723200000,"author_summary":" Ekaba Bisong, O.; John Oommen, B.","abstract_summary":" The study of Self-organizing lists deals with<br>the problem of lowering the average-case<br>asymptotic cost of a list data structure receiving query<br>accesses in Non-stationary Environments (NSEs) with<br>the so-called \u201clocality of reference\u201d property.<br>The de facto schemes for Adaptive lists in such<br>Environments are the Move To Front (MTF) and Transposition<br>(TR) rules. However, significant drawbacks exist<br>in the asymptotic accuracy and speed of list<br>re-organization for the MTF and TR rules. This paper improves on<br>these schemes using the design of an Adaptive list<br>data structure as a hierarchical data<br>\u201csub\u201d-structure. In this framework, we employ a hierarchical...","title_summary":" Optimizing Self-organizing Lists-on-Lists<br>Using Transitivity and Pursuit-Enhanced Object<br>Partitioning","x":-22.2854766846,"y":42.333656311,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.2854766846,"tsne_y":42.333656311,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"urlhi811","source_x":"PMC","title":"Preservation of the Exchange Principle via Lattice Operations on (S,N)\u2013 Implications","doi":"10.1007\/978-3-030-49186-4_15","abstract":"In this paper, we investigate a special case of an open problem that is related to the exchange principle, a property of fuzzy implications. We focus on the cases of (S,N)\u2013 implications and the preservation of the exchange principle via lattice operations. We present and prove some sufficient conditions such that the exchange principle is preserved under the join and meet operations if we use (S,N)\u2013 implications.","publish_time":1588723200000,"author_summary":" Grammatikopoulos, Dimitrios S.;<br>Papadopoulos, Basil K.","abstract_summary":" In this paper, we investigate a special case of<br>an open problem that is related to the exchange<br>principle, a property of fuzzy implications. We focus on<br>the cases of (S,N)\u2013 implications and the<br>preservation of the exchange principle via lattice<br>operations. We present and prove some sufficient<br>conditions such that the exchange principle is preserved<br>under the join and meet operations if we use (S,N)\u2013<br>implications.","title_summary":" Preservation of the Exchange Principle via<br>Lattice Operations on (S,N)\u2013 Implications","x":-22.3266716003,"y":45.8986930847,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.3266716003,"tsne_y":45.8986930847,"subcluster":32,"subcluster_description":"Efficient Normalizers","shape":"p"},{"cord_uid":"480x49jl","source_x":"PMC","title":"An Introduction of FD-Complete Constraints","doi":"10.1007\/978-3-030-49186-4_3","abstract":"The performance of solving a constraint problem can often be improved by converting a subproblem into a single constraint (for example into a regular membership constraint or a table constraint). In the past, it stood out, that specialist constraint solvers (like simplex solver or SAT solver) outperform general constraint solvers, for the problems they can handle. The disadvantage of such specialist constraint solvers is that they can handle only a small subset of problems with special limitations to the domains of the variables and\/or to the allowed constraints. In this paper we introduce the concept of fd-complete constraints and fd-complete constraint satisfaction problems, which allow combining both previous approaches. More accurately, we convert general constraint problems into problems which use only one, respectively one kind of constraint. The goal is it to interpret and solve the converted constraint problems with specialist solvers, which can solve the transformed constraint problems faster than the original solver the original constraint problems.","publish_time":1588723200000,"author_summary":" L\u00f6ffler, Sven; Liu, Ke; Hofstedt, Petra","abstract_summary":" The performance of solving a constraint<br>problem can often be improved by converting a<br>subproblem into a single constraint (for example into a<br>regular membership constraint or a table constraint).<br>In the past, it stood out, that specialist<br>constraint solvers (like simplex solver or SAT solver)<br>outperform general constraint solvers, for the problems<br>they can handle. The disadvantage of such<br>specialist constraint solvers is that they can handle only<br>a small subset of problems with special<br>limitations to the domains of the variables and\/or to the<br>allowed constraints. In this paper we introduce the<br>concept of fd-complete constraints and fd-complete...","title_summary":" An Introduction of FD-Complete Constraints","x":-22.0074691772,"y":40.9745483398,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.0074691772,"tsne_y":40.9745483398,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"qw2wbips","source_x":"PMC","title":"Model-Driven Development of a Digital Twin for Injection Molding","doi":"10.1007\/978-3-030-49435-3_6","abstract":"Digital Twins (DTs) of Cyber-Physical Production Systems (CPPSs) enable the smart automation of production processes, collection of data, and can thus reduce manual efforts for supervising and controlling CPPSs. Realizing DTs is challenging and requires significant efforts for their conception and integration with the represented CPPS. To mitigate this, we present an approach to systematically engineering DTs for injection molding that supports domain-specific customizations and automation of essential development activities based on a model-driven reference architecture. In this approach, reactive CPPS behavior is defined in terms of a Domain-Specific Language (DSL) for specifying events that occur in the physical system. The reference architecture connects to the CPPS through a novel DSL for representing OPC-UA bindings. We have evaluated this approach with a DT of an injection molding machine that controls the machine to optimize the Design of Experiment (DoE) parameters between experiment cycles before the products are molded. Through this, our reference implementation of the DT facilitates the time-consuming setup of a DT and the subsequent injection molding activities. Overall, this facilitates to systematically engineer digital twins with reactive behavior that help to optimize machine use.","publish_time":1590796800000,"author_summary":" Bibow, Pascal; Dalibor, Manuela; Hopmann,<br>Christian; Mainz, Ben; Rumpe, Bernhard; Schmalzing,<br>David; Schmitz, Mauritius; Wortmann, Andreas","abstract_summary":" Digital Twins (DTs) of Cyber-Physical<br>Production Systems (CPPSs) enable the smart automation of<br>production processes, collection of data, and can thus<br>reduce manual efforts for supervising and<br>controlling CPPSs. Realizing DTs is challenging and<br>requires significant efforts for their conception and<br>integration with the represented CPPS. To mitigate this, we<br>present an approach to systematically engineering DTs<br>for injection molding that supports<br>domain-specific customizations and automation of essential<br>development activities based on a model-driven reference<br>architecture. In this approach, reactive CPPS behavior is<br>defined in terms of a Domain-Specific Language (DSL)<br>for specifying events that occur in the physical<br>system....","title_summary":" Model-Driven Development of a Digital Twin for<br>Injection Molding","x":-29.2358951569,"y":43.3180351257,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-29.2358951569,"tsne_y":43.3180351257,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"xlnhsh15","source_x":"PMC","title":"Conformance Checking Approximation Using Subset Selection and Edit Distance","doi":"10.1007\/978-3-030-49435-3_15","abstract":"Conformance checking techniques let us find out to what degree a process model and real execution data correspond to each other. In recent years, alignments have proven extremely useful in calculating conformance statistics. Most techniques to compute alignments provide an exact solution. However, in many applications, it is enough to have an approximation of the conformance value. Specifically, for large event data, the computation time for alignments is considerably long using current techniques which makes them inapplicable in reality. Also, it is no longer feasible to use standard hardware for complex process models. This paper, proposes new approximation techniques to compute approximated conformance checking values close to exact solution values in less time. These methods also provide upper and lower bounds for the approximated alignment value. Our experiments on real event data show that it is possible to improve the performance of conformance checking by using the proposed methods compared to using the state-of-the-art alignment approximation technique. Results show that in most of the cases, we provide tight bounds, accurate approximated alignment values, and similar deviation statistics.","publish_time":1588982400000,"author_summary":" Fani Sani, Mohammadreza; van Zelst,<br>Sebastiaan J.; van der Aalst, Wil M. P.","abstract_summary":" Conformance checking techniques let us find<br>out to what degree a process model and real<br>execution data correspond to each other. In recent years,<br>alignments have proven extremely useful in calculating<br>conformance statistics. Most techniques to compute<br>alignments provide an exact solution. However, in many<br>applications, it is enough to have an approximation of the<br>conformance value. Specifically, for large event data, the<br>computation time for alignments is considerably long using<br>current techniques which makes them inapplicable in<br>reality. Also, it is no longer feasible to use standard<br>hardware for complex process models. This paper,<br>proposes new approximation techniques to...","title_summary":" Conformance Checking Approximation Using<br>Subset Selection and Edit Distance","x":-25.9090976715,"y":42.1324234009,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.9090976715,"tsne_y":42.1324234009,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"f3w0qz4h","source_x":"PMC","title":"Ordinal Graph-Based Games","doi":"10.1007\/978-3-030-50146-4_21","abstract":"The graphical, hypergraphical and polymatrix games frameworks provide concise representations of non-cooperative normal-form games involving many agents. In these graph-based games, agents interact in simultaneous local subgames with the agents which are their neighbors in a graph. Recently, ordinal normal form games have been proposed as a framework for game theory where agents\u2019 utilities are ordinal. This paper presents the first definition of Ordinal Graphical Games (OGG), Ordinal Hypergraphical Games (OHG), and Ordinal Polymatrix Games (OPG). We show that, as for classical graph-based games, determining whether a pure NE exists is also NP-hard. We propose an original CSP model to decide their existence and compute them. Then, a polynomial-time algorithm to compute possibilistic mixed equilibria for graph-based games is proposed. Finally, the experimental study is dedicated to test our proposed solution concepts for ordinal graph-based games.","publish_time":1589760000000,"author_summary":" Azzabi, Arij; Ben Amor, Nahla; Fargier,<br>H\u00e9l\u00e8ne; Sabbadin, R\u00e9gis","abstract_summary":" The graphical, hypergraphical and polymatrix<br>games frameworks provide concise representations<br>of non-cooperative normal-form games involving<br>many agents. In these graph-based games, agents<br>interact in simultaneous local subgames with the agents<br>which are their neighbors in a graph. Recently,<br>ordinal normal form games have been proposed as a<br>framework for game theory where agents\u2019 utilities are<br>ordinal. This paper presents the first definition of<br>Ordinal Graphical Games (OGG), Ordinal<br>Hypergraphical Games (OHG), and Ordinal Polymatrix Games<br>(OPG). We show that, as for classical graph-based<br>games, determining whether a pure NE exists is also<br>NP-hard. We propose an original CSP model to...","title_summary":" Ordinal Graph-Based Games","x":-23.5732002258,"y":42.5726318359,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.5732002258,"tsne_y":42.5726318359,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"xtd6w8bi","source_x":"PMC","title":"From Truth Degree Comparison Games to Sequents-of-Relations Calculi for G\u00f6del Logic","doi":"10.1007\/978-3-030-50146-4_20","abstract":"We introduce a game for (extended) G\u00f6del logic where the players\u2019 interaction stepwise reduces claims about the relative order of truth degrees of complex formulas to atomic truth comparison claims. Using the concept of disjunctive game states this semantic game is lifted to a provability game, where winning strategies correspond to proofs in a sequents-of-relations calculus.","publish_time":1589760000000,"author_summary":" Ferm\u00fcller, Christian; Lang, Timo; Pavlova,<br>Alexandra","abstract_summary":" We introduce a game for (extended) G\u00f6del logic<br>where the players\u2019 interaction stepwise reduces<br>claims about the relative order of truth degrees of<br>complex formulas to atomic truth comparison claims.<br>Using the concept of disjunctive game states this<br>semantic game is lifted to a provability game, where<br>winning strategies correspond to proofs in a<br>sequents-of-relations calculus.","title_summary":" From Truth Degree Comparison Games to<br>Sequents-of-Relations Calculi for G\u00f6del Logic","x":-24.599489212,"y":45.5123558044,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.599489212,"tsne_y":45.5123558044,"subcluster":14,"subcluster_description":"Orienting Combinator Equationsshort Q-Resolution","shape":"p"},{"cord_uid":"2nqdmunr","source_x":"PMC","title":"On Compatibility of Two Approaches to Generalization of the Lov\u00e1sz Extension Formula","doi":"10.1007\/978-3-030-50143-3_33","abstract":"We present a method of generalization of the Lov\u00e1sz extension formula combining two known approaches - the first of them based on the replacement of the product operator by some suitable binary function F and the second one based on the replacement of the minimum operator by a suitable aggregation function A. We propose generalization by simultaneous replacement of both product and minimum operators and investigate pairs (F, A) yielding an aggregation function for all capacities.","publish_time":1589500800000,"author_summary":" Horansk\u00e1, \u013dubom\u00edra","abstract_summary":" We present a method of generalization of the<br>Lov\u00e1sz extension formula combining two known<br>approaches - the first of them based on the replacement of<br>the product operator by some suitable binary<br>function F and the second one based on the replacement of<br>the minimum operator by a suitable aggregation<br>function A. We propose generalization by simultaneous<br>replacement of both product and minimum operators and<br>investigate pairs (F, A) yielding an aggregation function<br>for all capacities.","title_summary":" On Compatibility of Two Approaches to<br>Generalization of the Lov\u00e1sz Extension Formula","x":-22.3677501678,"y":46.0266571045,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.3677501678,"tsne_y":46.0266571045,"subcluster":32,"subcluster_description":"Efficient Normalizers","shape":"p"},{"cord_uid":"obx3pobo","source_x":"PMC","title":"Construction of Nullnorms Based on Closure and Interior Operators on Bounded Lattices","doi":"10.1007\/978-3-030-50143-3_37","abstract":"In this paper, we introduce two rather effective methods for constructing new families of nullnorms with a zero element on the basis of the closure operators and interior operators on a bounded lattice under some additional conditions. Our constructions can be seen as a generalization of the ones in [28]. As a by-product, two types of idempotent nullnorms on bounded lattices are obtained. Several interesting examples are included to get a better understanding of the structure of new families of nullnorms.","publish_time":1589500800000,"author_summary":" \u00c7ayl\u0131, G\u00fcl Deniz","abstract_summary":" In this paper, we introduce two rather<br>effective methods for constructing new families of<br>nullnorms with a zero element on the basis of the closure<br>operators and interior operators on a bounded lattice<br>under some additional conditions. Our<br>constructions can be seen as a generalization of the ones in<br>[28]. As a by-product, two types of idempotent<br>nullnorms on bounded lattices are obtained. Several<br>interesting examples are included to get a better<br>understanding of the structure of new families of nullnorms.","title_summary":" Construction of Nullnorms Based on Closure and<br>Interior Operators on Bounded Lattices","x":-21.4734916687,"y":45.7951774597,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.4734916687,"tsne_y":45.7951774597,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"l2gmwvua","source_x":"PMC","title":"On the Logic of Left-Continuous t-Norms and Right-Continuous t-Conorms","doi":"10.1007\/978-3-030-50153-2_48","abstract":"Double residuated lattices are expansions of residuated lattices with an extra monoidal operator, playing the role of a strong disjunction operation, together with its dual residuum. They were introduced by Or\u0142owska and Radzikowska. In this paper we consider the subclass of double residuated structures that are expansions of MTL-algebras, that is, prelinear, bounded, commutative and integral residuated lattices. MTL-algebras constitute the algebraic semantics for the MTL logic, the system of mathematical fuzzy logic that is complete w.r.t. the class of residuated lattices on the real unit interval [0, 1] induced by left-continuous t-norms. Our aim is to axiomatise the logic whose intended semantics are commutative and integral double residuated structures on [0, 1], that are induced by an arbitrary left-continuous t-norm, an arbitrary right-continuous t-conorm, and their corresponding residual operations.","publish_time":1589587200000,"author_summary":" Godo, Llu\u00eds; S\u00f3cola-Ramos, Mart\u00edn; Esteva,<br>Francesc","abstract_summary":" Double residuated lattices are expansions of<br>residuated lattices with an extra monoidal operator,<br>playing the role of a strong disjunction operation,<br>together with its dual residuum. They were introduced by<br>Or\u0142owska and Radzikowska. In this paper we consider the<br>subclass of double residuated structures that are<br>expansions of MTL-algebras, that is, prelinear, bounded,<br>commutative and integral residuated lattices.<br>MTL-algebras constitute the algebraic semantics for the MTL<br>logic, the system of mathematical fuzzy logic that is<br>complete w.r.t. the class of residuated lattices on the<br>real unit interval [0, 1] induced by<br>left-continuous t-norms. Our aim is to axiomatise the logic...","title_summary":" On the Logic of Left-Continuous t-Norms and<br>Right-Continuous t-Conorms","x":-23.6589202881,"y":45.262386322,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.6589202881,"tsne_y":45.262386322,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"l34czstx","source_x":"PMC","title":"Classification of Hyperbolic Singularities in Interval 3-Dimensional Linear Differential Systems","doi":"10.1007\/978-3-030-50143-3_2","abstract":"We study the classification of the hyperbolic singularities to 3-dimensional interval linear differential equations as an application of interval eigenvalues using the Constraint Interval Arithmetic (CIA). We also present the ideas to calculate the interval eigenvalues using the standard interval arithmetic.","publish_time":1589500800000,"author_summary":" Mizukoshi, Marina Tuyako; Jacquemard, Alain;<br>Lodwick, Weldon Alexander","abstract_summary":" We study the classification of the hyperbolic<br>singularities to 3-dimensional interval linear<br>differential equations as an application of interval<br>eigenvalues using the Constraint Interval Arithmetic<br>(CIA). We also present the ideas to calculate the<br>interval eigenvalues using the standard interval<br>arithmetic.","title_summary":" Classification of Hyperbolic Singularities<br>in Interval 3-Dimensional Linear Differential<br>Systems","x":-21.0537700653,"y":46.5114746094,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.0537700653,"tsne_y":46.5114746094,"subcluster":19,"subcluster_description":"Interval 3-Dimensional Linear Differential","shape":"p"},{"cord_uid":"sv1bqwym","source_x":"PMC","title":"Galois Connections Between Unbalanced Structures in a Fuzzy Framework","doi":"10.1007\/978-3-030-50153-2_54","abstract":"The construction of Galois connections between unbalanced structures has received considerable attention in the recent years. In a nutshell, the problem is to find a right adjoint of a mapping defined between sets with unbalanced structure; in this paper we survey recent results obtained in this framework, focusing specially on the fuzzy structures that have been considered so far in this context: fuzzy preposets, fuzzy preordered structures, and fuzzy T-digraphs.","publish_time":1589587200000,"author_summary":" Cabrera, Inma P.; Cordero, Pablo;<br>Mu\u00f1oz-Velasco, Emilio; Ojeda-Aciego, Manuel","abstract_summary":" The construction of Galois connections<br>between unbalanced structures has received<br>considerable attention in the recent years. In a nutshell,<br>the problem is to find a right adjoint of a mapping<br>defined between sets with unbalanced structure; in<br>this paper we survey recent results obtained in this<br>framework, focusing specially on the fuzzy structures<br>that have been considered so far in this context:<br>fuzzy preposets, fuzzy preordered structures, and<br>fuzzy T-digraphs.","title_summary":" Galois Connections Between Unbalanced<br>Structures in a Fuzzy Framework","x":-21.6481552124,"y":45.9007339478,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.6481552124,"tsne_y":45.9007339478,"subcluster":26,"subcluster_description":"Symmetrykauffman Bracket Skein Module","shape":"p"},{"cord_uid":"zi109bg1","source_x":"PMC","title":"BIOWA Operators","doi":"10.1007\/978-3-030-50143-3_32","abstract":"Based on bi-capacities and related Choquet integral introduced by Grabisch and Labreuche, a new generalization of OWA operators, namely BIOWA operators are introduced. Our approach is exemplified by several examples. Bi-capacities leading to the standard Yager\u2019s OWA operators on real line are completely characterized.","publish_time":1589500800000,"author_summary":" Stup\u0148anov\u00e1, Andrea; Jin, LeSheng","abstract_summary":" Based on bi-capacities and related Choquet<br>integral introduced by Grabisch and Labreuche, a new<br>generalization of OWA operators, namely BIOWA operators are<br>introduced. Our approach is exemplified by several<br>examples. Bi-capacities leading to the standard Yager\u2019s<br>OWA operators on real line are completely<br>characterized.","title_summary":" BIOWA Operators","x":-21.9007835388,"y":46.5634155273,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.9007835388,"tsne_y":46.5634155273,"subcluster":31,"subcluster_description":"Algebraic Surfacesa Convex Programming","shape":"p"},{"cord_uid":"e96dkdyt","source_x":"PMC","title":"Two Dualities for Weakly Pseudo-complemented quasi-Kleene Algebras","doi":"10.1007\/978-3-030-50153-2_47","abstract":"Quasi-Nelson algebras are a non-involutive generalisation of Nelson algebras that can be characterised in several ways, e.g. as (i) the variety of bounded commutative integral (not necessarily involutive) residuated lattices that satisfy the Nelson identity; (ii) the class of (0, 1)-congruence orderable commutative integral residuated lattices; (iii) the algebraic counterpart of quasi-Nelson logic, i.e. the (algebraisable) extension of the substructural logic [Formula: see text] by the Nelson axiom. In the present paper we focus on the subreducts of quasi-Nelson algebras obtained by eliding the implication while keeping the two term-definable negations. These form a variety that (following A. Sendlewski, who studied the corresponding fragment of Nelson algebras) we dub weakly pseudo-complemented quasi-Kleene algebras. We develop a Priestley-style duality for these algebras (in two different guises) which is essentially an application of the general approach proposed in the paper A duality for two-sorted lattices by A. Jung and U. Rivieccio.","publish_time":1589587200000,"author_summary":" Rivieccio, Umberto; Jansana, Ramon;<br>Nascimento, Thiago","abstract_summary":" Quasi-Nelson algebras are a non-involutive<br>generalisation of Nelson algebras that can be characterised in<br>several ways, e.g. as (i) the variety of bounded<br>commutative integral (not necessarily involutive)<br>residuated lattices that satisfy the Nelson identity;<br>(ii) the class of (0, 1)-congruence orderable<br>commutative integral residuated lattices; (iii) the<br>algebraic counterpart of quasi-Nelson logic, i.e. the<br>(algebraisable) extension of the substructural logic<br>[Formula: see text] by the Nelson axiom. In the present<br>paper we focus on the subreducts of quasi-Nelson<br>algebras obtained by eliding the implication while<br>keeping the two term-definable negations. These form a<br>variety that (following A. Sendlewski, who...","title_summary":" Two Dualities for Weakly Pseudo-complemented<br>quasi-Kleene Algebras","x":-23.6664981842,"y":45.1670799255,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.6664981842,"tsne_y":45.1670799255,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"8rvfr59b","source_x":"PMC","title":"Impact of Local Congruences in Attribute Reduction","doi":"10.1007\/978-3-030-50153-2_55","abstract":"Local congruences are equivalence relations whose equivalence classes are convex sublattices of the original lattice. In this paper, we present a study that relates local congruences to attribute reduction in FCA. Specifically, we will analyze the impact in the context of the use of local congruences, when they are used for complementing an attribute reduction.","publish_time":1589587200000,"author_summary":" Arag\u00f3n, Roberto G.; Medina, Jes\u00fas;<br>Ram\u00edrez-Poussa, Elo\u00edsa","abstract_summary":" Local congruences are equivalence relations<br>whose equivalence classes are convex sublattices of<br>the original lattice. In this paper, we present a<br>study that relates local congruences to attribute<br>reduction in FCA. Specifically, we will analyze the<br>impact in the context of the use of local congruences,<br>when they are used for complementing an attribute<br>reduction.","title_summary":" Impact of Local Congruences in Attribute<br>Reduction","x":-22.6835765839,"y":46.1013832092,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.6835765839,"tsne_y":46.1013832092,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"gqjsuqid","source_x":"PMC","title":"Unification in \u0141ukasiewicz Logic with a Finite Number of Variables","doi":"10.1007\/978-3-030-50153-2_46","abstract":"We prove that the unification type of \u0141ukasiewicz logic with a finite number of variables is either infinitary or nullary. To achieve this result we use Ghilardi\u2019s categorical characterisation of unification types in terms of projective objects, the categorical duality between finitely presented MV-algebras and rational polyhedra, and a homotopy-theoretic argument.","publish_time":1589587200000,"author_summary":" Abbadini, Marco; Di Stefano, Federica; Spada,<br>Luca","abstract_summary":" We prove that the unification type of<br>\u0141ukasiewicz logic with a finite number of variables is<br>either infinitary or nullary. To achieve this result<br>we use Ghilardi\u2019s categorical characterisation<br>of unification types in terms of projective<br>objects, the categorical duality between finitely<br>presented MV-algebras and rational polyhedra, and a<br>homotopy-theoretic argument.","title_summary":" Unification in \u0141ukasiewicz Logic with a Finite<br>Number of Variables","x":-23.5771751404,"y":45.9571685791,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.5771751404,"tsne_y":45.9571685791,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"d771fcyl","source_x":"PMC","title":"Automorphism Groups of Finite BL-Algebras","doi":"10.1007\/978-3-030-50153-2_49","abstract":"Using a category dual to finite [Formula: see text]-algebras and their homomorphisms, in this paper we characterise the structure of the automorphism group of any given finite [Formula: see text]-algebra. Further, we specialise our result to the case of the variety generated by the k-element [Formula: see text]-algebra, for each [Formula: see text].","publish_time":1589587200000,"author_summary":" Aguzzoli, Stefano; Gerla, Brunella","abstract_summary":" Using a category dual to finite [Formula: see<br>text]-algebras and their homomorphisms, in this paper we<br>characterise the structure of the automorphism group of any<br>given finite [Formula: see text]-algebra. Further,<br>we specialise our result to the case of the variety<br>generated by the k-element [Formula: see text]-algebra,<br>for each [Formula: see text].","title_summary":" Automorphism Groups of Finite BL-Algebras","x":-22.1532554626,"y":45.6879348755,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.1532554626,"tsne_y":45.6879348755,"subcluster":32,"subcluster_description":"Efficient Normalizers","shape":"p"},{"cord_uid":"mj3s5iav","source_x":"PMC","title":"Depth-Bounded Approximations of Probability","doi":"10.1007\/978-3-030-50153-2_45","abstract":"We introduce measures of uncertainty that are based on Depth-Bounded Logics [4] and resemble belief functions. We show that our measures can be seen as approximation of classical probability measures over classical logic, and that a variant of the PSAT [10] problem for them is solvable in polynomial time.","publish_time":1589587200000,"author_summary":" Baldi, Paolo; D\u2019Agostino, Marcello; Hosni,<br>Hykel","abstract_summary":" We introduce measures of uncertainty that are<br>based on Depth-Bounded Logics [4] and resemble<br>belief functions. We show that our measures can be seen<br>as approximation of classical probability<br>measures over classical logic, and that a variant of the<br>PSAT [10] problem for them is solvable in polynomial<br>time.","title_summary":" Depth-Bounded Approximations of Probability","x":-23.8098392487,"y":46.3176040649,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.8098392487,"tsne_y":46.3176040649,"subcluster":18,"subcluster_description":"Capturing Complexity Classes","shape":"p"},{"cord_uid":"lrzlmipp","source_x":"PMC","title":"On the Properties of Intermediate Quantifiers and the Quantifier \u201cMORE-THAN\u201d","doi":"10.1007\/978-3-030-50153-2_12","abstract":"This paper continues the research in formal theory of intermediate quantifiers. We present some new properties, introduce intermediate quantifiers of type [Formula: see text], and also new quantifiers MORE-THAN and LESS-THAN.","publish_time":1589587200000,"author_summary":" Nov\u00e1k, Vil\u00e9m; Murinov\u00e1, Petra; Boffa,<br>Stefania","abstract_summary":" This paper continues the research in formal<br>theory of intermediate quantifiers. We present some<br>new properties, introduce intermediate<br>quantifiers of type [Formula: see text], and also new<br>quantifiers MORE-THAN and LESS-THAN.","title_summary":" On the Properties of Intermediate Quantifiers<br>and the Quantifier \u201cMORE-THAN\u201d","x":-24.0780029297,"y":46.0947341919,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0780029297,"tsne_y":46.0947341919,"subcluster":17,"subcluster_description":"Quantum Finite Automatainsertion-Deletion Systems","shape":"p"},{"cord_uid":"w086mze0","source_x":"PMC","title":"Towards Hypervisor Support for Enhancing the Performance of Virtual Machine Introspection","doi":"10.1007\/978-3-030-50323-9_3","abstract":"Virtual machine introspection (VMI) is the process of external monitoring of virtual machines. Previous work has demonstrated that VMI can contribute to the security of cloud environments and distributed systems, as it enables, for example, stealthy intrusion detection. One of the biggest challenges for applying VMI in production environments is the performance overhead that certain tracing operations impose on the monitored virtual machine. In this paper, we show how this performance overhead can be significantly minimized by incorporating minor extensions for VMI operations into the hypervisor. In a proof-of-concept implementation, we demonstrate that the pre-processing of VMI events in the Xen hypervisor reduces the monitoring overhead for the use case of VMI-based process-bound monitoring by a factor of 18.","publish_time":1589500800000,"author_summary":" Taubmann, Benjamin; Reiser, Hans P.","abstract_summary":" Virtual machine introspection (VMI) is the<br>process of external monitoring of virtual machines.<br>Previous work has demonstrated that VMI can contribute<br>to the security of cloud environments and<br>distributed systems, as it enables, for example, stealthy<br>intrusion detection. One of the biggest challenges for<br>applying VMI in production environments is the<br>performance overhead that certain tracing operations<br>impose on the monitored virtual machine. In this<br>paper, we show how this performance overhead can be<br>significantly minimized by incorporating minor extensions<br>for VMI operations into the hypervisor. In a<br>proof-of-concept implementation, we demonstrate that the<br>pre-processing of VMI events in the...","title_summary":" Towards Hypervisor Support for Enhancing the<br>Performance of Virtual Machine Introspection","x":-27.4028148651,"y":41.1022872925,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.4028148651,"tsne_y":41.1022872925,"subcluster":3,"subcluster_description":"Polyglot Data Access Layer","shape":"p"},{"cord_uid":"elo5lr4z","source_x":"PMC","title":"Building a Polyglot Data Access Layer for a Low-Code Application Development Platform: (Experience Report)","doi":"10.1007\/978-3-030-50323-9_6","abstract":"Low-code application development as proposed by the OutSystems Platform enables fast mobile and desktop application development and deployment. It hinges on visual development of the interface and business logic but also on easy integration with data stores and services while delivering robust applications that scale. Data integration increasingly means accessing a variety of NoSQL stores. Unfortunately, the diversity of data and processing models, that make them useful in the first place, is difficult to reconcile with the simplification of abstractions exposed to developers in a low-code platform. Moreover, NoSQL data stores also rely on a variety of general purpose and custom scripting languages as their main interfaces. In this paper we report on building a polyglot data access layer for the OutSystems Platform that uses SQL with optional embedded script snippets to bridge the gap between low-code and full access to NoSQL stores.","publish_time":1589500800000,"author_summary":" Nunes Alonso, Ana; Abreu, Jo\u00e3o; Nunes, David;<br>Vieira, Andr\u00e9; Santos, Luiz; Soares, T\u00e9rcio; Pereira,<br>Jos\u00e9","abstract_summary":" Low-code application development as proposed<br>by the OutSystems Platform enables fast mobile<br>and desktop application development and<br>deployment. It hinges on visual development of the<br>interface and business logic but also on easy integration<br>with data stores and services while delivering<br>robust applications that scale. Data integration<br>increasingly means accessing a variety of NoSQL stores.<br>Unfortunately, the diversity of data and processing models,<br>that make them useful in the first place, is<br>difficult to reconcile with the simplification of<br>abstractions exposed to developers in a low-code platform.<br>Moreover, NoSQL data stores also rely on a variety of<br>general purpose and...","title_summary":" Building a Polyglot Data Access Layer for a<br>Low-Code Application Development Platform:<br>(Experience Report)","x":-27.3270168304,"y":40.8418273926,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.3270168304,"tsne_y":40.8418273926,"subcluster":3,"subcluster_description":"Polyglot Data Access Layer","shape":"p"},{"cord_uid":"budhtlxv","source_x":"PMC","title":"Self-tunable DBMS Replication with Reinforcement Learning","doi":"10.1007\/978-3-030-50323-9_9","abstract":"Fault-tolerance is a core feature in distributed database systems, particularly the ones deployed in cloud environments. The dependability of these systems often relies in middleware components that abstract the DBMS logic from the replication itself. The highly configurable nature of these systems makes their throughput very dependent on the correct tuning for a given workload. Given the high complexity involved, machine learning techniques are often considered to guide the tuning process and decompose the relations established between tuning variables. This paper presents a machine learning mechanism based on reinforcement learning that attaches to a hybrid replication middleware connected to a DBMS to dynamically live-tune the configuration of the middleware according to the workload being processed. Along with the vision for the system, we present a study conducted over a prototype of the self-tuned replication middleware, showcasing the achieved performance improvements and showing that we were able to achieve an improvement of 370.99% on some of the considered metrics.","publish_time":1589500800000,"author_summary":" Ferreira, Lu\u00eds; Coelho, F\u00e1bio; Pereira, Jos\u00e9","abstract_summary":" Fault-tolerance is a core feature in<br>distributed database systems, particularly the ones<br>deployed in cloud environments. The dependability of<br>these systems often relies in middleware components<br>that abstract the DBMS logic from the replication<br>itself. The highly configurable nature of these<br>systems makes their throughput very dependent on the<br>correct tuning for a given workload. Given the high<br>complexity involved, machine learning techniques are<br>often considered to guide the tuning process and<br>decompose the relations established between tuning<br>variables. This paper presents a machine learning<br>mechanism based on reinforcement learning that attaches<br>to a hybrid replication middleware connected to a...","title_summary":" Self-tunable DBMS Replication with<br>Reinforcement Learning","x":-26.3515930176,"y":39.2168731689,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.3515930176,"tsne_y":39.2168731689,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"lqvradqi","source_x":"PMC","title":"A Comparison of Message Exchange Patterns in BFT Protocols: (Experience Report)","doi":"10.1007\/978-3-030-50323-9_7","abstract":"The performance and scalability of byzantine fault-tolerant (BFT) protocols for state machine replication (SMR) have recently come under scrutiny due to their application in the consensus mechanism of blockchain implementations. This led to a proliferation of proposals that provide different trade-offs that are not easily compared as, even if these are all based on message passing, multiple design and implementation factors besides the message exchange pattern differ between each of them. In this paper we focus on the impact of different combinations of cryptographic primitives and the message exchange pattern used to collect and disseminate votes, a key aspect for performance and scalability. By measuring this aspect in isolation and in a common framework, we characterise the design space and point out research directions for adaptive protocols that provide the best trade-off for each environment and workload combination.","publish_time":1589500800000,"author_summary":" Silva, F\u00e1bio; Alonso, Ana; Pereira, Jos\u00e9;<br>Oliveira, Rui","abstract_summary":" The performance and scalability of byzantine<br>fault-tolerant (BFT) protocols for state machine replication<br>(SMR) have recently come under scrutiny due to their<br>application in the consensus mechanism of blockchain<br>implementations. This led to a proliferation of proposals that<br>provide different trade-offs that are not easily<br>compared as, even if these are all based on message<br>passing, multiple design and implementation factors<br>besides the message exchange pattern differ between<br>each of them. In this paper we focus on the impact of<br>different combinations of cryptographic primitives and<br>the message exchange pattern used to collect and<br>disseminate votes, a key aspect for...","title_summary":" A Comparison of Message Exchange Patterns in<br>BFT Protocols: (Experience Report)","x":-27.3515110016,"y":42.1258964539,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.3515110016,"tsne_y":42.1258964539,"subcluster":4,"subcluster_description":"Persistent Software Transactional","shape":"p"},{"cord_uid":"my88thxx","source_x":"PMC","title":"TailX: Scheduling Heterogeneous Multiget Queries to Improve Tail Latencies in Key-Value Stores","doi":"10.1007\/978-3-030-50323-9_5","abstract":"Users of interactive services such as e-commerce platforms have high expectations for the performance and responsiveness of these services. Tail latency, denoting the worst service times, contributes greatly to user dissatisfaction and should be minimized. Maintaining low tail latency for interactive services is challenging because a request is not complete until all its operations are completed. The challenge is to identify bottleneck operations and schedule them on uncoordinated backend servers with minimal overhead, when the duration of these operations are heterogeneous and unpredictable. In this paper, we focus on improving the latency of multiget operations in cloud data stores. We present TailX, a task-aware multiget scheduling algorithm that improves tail latencies under heterogeneous workloads. TailX schedules operations according to an estimation of the size of the corresponding data, and allows itself to procrastinate some operations to give way to higher priority ones. We implement TailX in Cassandra, a widely used key-value store. The result is an improved overall performance of the cloud data stores for a wide variety of heterogeneous workloads. Specifically, our experiments under heterogeneous YCSB workloads show that TailX outperforms state-of-the-art solutions and reduces tail latencies by up to 70% and median latencies by up to 75%.","publish_time":1589500800000,"author_summary":" Jaiman, Vikas; Ben Mokhtar, Sonia; Rivi\u00e8re,<br>Etienne","abstract_summary":" Users of interactive services such as<br>e-commerce platforms have high expectations for the<br>performance and responsiveness of these services. Tail<br>latency, denoting the worst service times, contributes<br>greatly to user dissatisfaction and should be<br>minimized. Maintaining low tail latency for interactive<br>services is challenging because a request is not<br>complete until all its operations are completed. The<br>challenge is to identify bottleneck operations and<br>schedule them on uncoordinated backend servers with<br>minimal overhead, when the duration of these<br>operations are heterogeneous and unpredictable. In this<br>paper, we focus on improving the latency of multiget<br>operations in cloud data stores. We...","title_summary":" TailX: Scheduling Heterogeneous Multiget<br>Queries to Improve Tail Latencies in Key-Value Stores","x":-26.6936302185,"y":39.3663406372,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6936302185,"tsne_y":39.3663406372,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"zm84yipu","source_x":"PMC","title":"Fed-DIC: Diagonally Interleaved Coding in a Federated Cloud Environment","doi":"10.1007\/978-3-030-50323-9_4","abstract":"Coping with failures in modern distributed storage systems that handle massive volumes of heterogeneous and potentially rapidly changing data, has become a very important challenge. A common practice is to utilize fault tolerance methods like Replication and Erasure Coding for maximizing data availability. However, while erasure codes provide better fault tolerance compared to replication with a more affordable storage overhead, they frequently suffer from high reconstruction cost as they require to access all available nodes when a data block needs to be repaired, and also can repair up to a limited number of unavailable data blocks, depending on the number of the code\u2019s parity block capabilities. Furthermore, storing and placing the encoded data in the federated storage system also remains a challenge. In this paper we present Fed-DIC, a framework which combines Diagonally Interleaved Coding on client devices at the edge of the network with organized storage of encoded data in a federated cloud system comprised of multiple independent storage clusters. The erasure coding operations are performed on client devices at the edge while they interact with the federated cloud to store the encoded data. We describe how our solution integrates the functionality of federated clouds alongside erasure coding implemented on edge devices for maximizing data availability and we evaluate the working and benefits of our approach in terms of read access cost, data availability, storage overhead, load balancing and network bandwidth rate compared to popular Replication and Erasure Coding schemes.","publish_time":1589500800000,"author_summary":" Tzouros, Giannis; Kalogeraki, Vana","abstract_summary":" Coping with failures in modern distributed<br>storage systems that handle massive volumes of<br>heterogeneous and potentially rapidly changing data, has<br>become a very important challenge. A common practice<br>is to utilize fault tolerance methods like<br>Replication and Erasure Coding for maximizing data<br>availability. However, while erasure codes provide better<br>fault tolerance compared to replication with a more<br>affordable storage overhead, they frequently suffer from<br>high reconstruction cost as they require to access<br>all available nodes when a data block needs to be<br>repaired, and also can repair up to a limited number of<br>unavailable data blocks, depending on the number...","title_summary":" Fed-DIC: Diagonally Interleaved Coding in a<br>Federated Cloud Environment","x":-26.3233337402,"y":39.3024635315,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.3233337402,"tsne_y":39.3024635315,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"3jxi0dj2","source_x":"PMC","title":"A Self-stabilizing One-To-Many Node Disjoint Paths Routing Algorithm in Star Networks","doi":"10.1007\/978-3-030-50323-9_12","abstract":"The purpose of the paper is to present the first self-stabilizing algorithm for finding [Formula: see text] one-to-many node-disjoint paths in message passing model. Two paths in a network are said to be node disjoint if they do not share any nodes except for the endpoints. Our proposed algorithm works on n-dimensional star networks [Formula: see text]. Given a source node s and a set of [Formula: see text] of [Formula: see text] destination nodes in the n-dimensional star network, our algorithm constructs [Formula: see text] node-disjoints paths [Formula: see text], where [Formula: see text] is a path from s to [Formula: see text], [Formula: see text]. Since the proposed solution is self-stabilizing [7], it does not require initialization and withstands transient faults. The stabilization time of our algorithm is [Formula: see text] rounds.","publish_time":1589500800000,"author_summary":" Hadid, Rachid; Villain, Vincent","abstract_summary":" The purpose of the paper is to present the first<br>self-stabilizing algorithm for finding [Formula: see text]<br>one-to-many node-disjoint paths in message passing model.<br>Two paths in a network are said to be node disjoint if<br>they do not share any nodes except for the endpoints.<br>Our proposed algorithm works on n-dimensional<br>star networks [Formula: see text]. Given a source<br>node s and a set of [Formula: see text] of [Formula:<br>see text] destination nodes in the n-dimensional<br>star network, our algorithm constructs [Formula:<br>see text] node-disjoints paths [Formula: see<br>text], where [Formula: see text] is a path from s...","title_summary":" A Self-stabilizing One-To-Many Node Disjoint<br>Paths Routing Algorithm in Star Networks","x":-22.3813552856,"y":43.3538970947,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.3813552856,"tsne_y":43.3538970947,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"tsuoo7p2","source_x":"PMC","title":"Towards a Hybrid Verification Methodology for Communication Protocols (Short Paper)","doi":"10.1007\/978-3-030-50086-3_13","abstract":"We present our preliminary work towards a comprehensive solution for the hybrid (static + dynamic) verification of open distributed systems, using session types. We automate a solution for binary sessions where one endpoint is statically checked, and the other endpoint is dynamically checked by a monitor acting as an intermediary between typed and untyped components. We outline our theory, and illustrate a tool that automatically synthesises type-checked session monitors, based on the Scala language and its session programming library (lchannels).","publish_time":1589328000000,"author_summary":" Bartolo Burl\u00f2, Christian; Francalanza,<br>Adrian; Scalas, Alceste","abstract_summary":" We present our preliminary work towards a<br>comprehensive solution for the hybrid (static + dynamic)<br>verification of open distributed systems, using session<br>types. We automate a solution for binary sessions<br>where one endpoint is statically checked, and the<br>other endpoint is dynamically checked by a monitor<br>acting as an intermediary between typed and untyped<br>components. We outline our theory, and illustrate a tool<br>that automatically synthesises type-checked<br>session monitors, based on the Scala language and its<br>session programming library (lchannels).","title_summary":" Towards a Hybrid Verification Methodology for<br>Communication Protocols (Short Paper)","x":-27.0889034271,"y":43.358253479,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.0889034271,"tsne_y":43.358253479,"subcluster":23,"subcluster_description":"Finite State Processesa Fast","shape":"p"},{"cord_uid":"1odkcgi8","source_x":"PMC","title":"Derivation of Heard-of Predicates from Elementary Behavioral Patterns","doi":"10.1007\/978-3-030-50086-3_8","abstract":"There are many models of distributed computing, and no unifying mathematical framework for considering them all. One way to sidestep this issue is to start with simple communication and fault models, and use them as building blocks to derive the complex models studied in the field. We thus define operations like union, succession or repetition, which makes it easier to build complex models from simple ones while retaining expressivity. To formalize this approach, we abstract away the complex models and operations in the Heard-Of model. This model relies on (possibly asynchronous) rounds; sequence of digraphs, one for each round, capture which messages sent at a given round are received before the receiver goes to the next round. A set of sequences, called a heard-of predicate, defines the legal communication behaviors \u2013 that is to say, a model of communication. Because the proposed operations behave well with this transformation of operational models into heard-of predicates, we can derive bounds, characterizations, and implementations of the heard-of predicates for the constructions.","publish_time":1589328000000,"author_summary":" Shimi, Adam; Hurault, Aur\u00e9lie; Queinnec,<br>Philippe","abstract_summary":" There are many models of distributed<br>computing, and no unifying mathematical framework for<br>considering them all. One way to sidestep this issue is to<br>start with simple communication and fault models,<br>and use them as building blocks to derive the<br>complex models studied in the field. We thus define<br>operations like union, succession or repetition, which<br>makes it easier to build complex models from simple<br>ones while retaining expressivity. To formalize<br>this approach, we abstract away the complex models<br>and operations in the Heard-Of model. This model<br>relies on (possibly asynchronous) rounds; sequence<br>of digraphs, one for each round, capture...","title_summary":" Derivation of Heard-of Predicates from<br>Elementary Behavioral Patterns","x":-26.1761512756,"y":43.9117546082,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.1761512756,"tsne_y":43.9117546082,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"kprvifq2","source_x":"PMC","title":"Trace Equivalence and Epistemic Logic to Express Security Properties","doi":"10.1007\/978-3-030-50086-3_7","abstract":"In process algebra, we can express security properties using an equivalence on processes. However, it is not clear which equivalence is the most suitable for the purpose. Indeed, several definitions of some properties are proposed. For example, the definition of privacy is not unique. This situation means that we are not certain how to express an intuitive security notion. Namely, there is a gap between an intuitive security notion and the formulation. Proper formalization is essential for verification, and our purpose is to bridge this gap. In the case of the applied pi calculus, an outputted message is not explicitly expressed. This feature suggests that trace equivalence appropriately expresses indistinguishability for attackers in the applied pi calculus. By chasing interchanging bound names and scope extrusions, we prove that trace equivalence is a congruence. Therefore, a security property expressed using trace equivalence is preserved by application of contexts. Moreover, we construct an epistemic logic for the applied pi calculus. We show that its logical equivalence agrees with trace equivalence. It means that trace equivalence is suitable in the presence of a non-adaptive attacker. Besides, we define several security properties to use our epistemic logic.","publish_time":1589328000000,"author_summary":" Minami, Kiraku","abstract_summary":" In process algebra, we can express security<br>properties using an equivalence on processes. However, it<br>is not clear which equivalence is the most<br>suitable for the purpose. Indeed, several definitions<br>of some properties are proposed. For example, the<br>definition of privacy is not unique. This situation means<br>that we are not certain how to express an intuitive<br>security notion. Namely, there is a gap between an<br>intuitive security notion and the formulation. Proper<br>formalization is essential for verification, and our purpose<br>is to bridge this gap. In the case of the applied pi<br>calculus, an outputted message is not explicitly...","title_summary":" Trace Equivalence and Epistemic Logic to<br>Express Security Properties","x":-26.00756073,"y":44.2619094849,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.00756073,"tsne_y":44.2619094849,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"6hurfri9","source_x":"PMC","title":"Defining and Verifying Durable Opacity: Correctness for Persistent Software Transactional Memory","doi":"10.1007\/978-3-030-50086-3_3","abstract":"Non-volatile memory (NVM), aka persistent memory, is a new paradigm for memory that preserves its contents even after power loss. The expected ubiquity of NVM has stimulated interest in the design of novel concepts ensuring correctness of concurrent programming abstractions in the face of persistency. So far, this has lead to the design of a number of persistent concurrent data structures, built to satisfy an associated notion of correctness: durable linearizability. In this paper, we transfer the principle of durable concurrent correctness to the area of software transactional memory (STM). Software transactional memory algorithms allow for concurrent access to shared state. Like linearizability for concurrent data structures, opacity is the established notion of correctness for STMs. First, we provide a novel definition of durable opacity extending opacity to handle crashes and recovery in the context of NVM. Second, we develop a durably opaque version of an existing STM algorithm, namely the Transactional Mutex Lock (TML). Third, we design a proof technique for durable opacity based on refinement between TML and an operational characterisation of durable opacity by adapting the TMS2 specification. Finally, we apply this proof technique to show that the durable version of TML is indeed durably opaque. The correctness proof is mechanized within Isabelle.","publish_time":1589328000000,"author_summary":" Bila, Eleni; Doherty, Simon; Dongol, Brijesh;<br>Derrick, John; Schellhorn, Gerhard; Wehrheim, Heike","abstract_summary":" Non-volatile memory (NVM), aka persistent<br>memory, is a new paradigm for memory that preserves its<br>contents even after power loss. The expected ubiquity of<br>NVM has stimulated interest in the design of novel<br>concepts ensuring correctness of concurrent<br>programming abstractions in the face of persistency. So<br>far, this has lead to the design of a number of<br>persistent concurrent data structures, built to satisfy<br>an associated notion of correctness: durable<br>linearizability. In this paper, we transfer the principle of<br>durable concurrent correctness to the area of software<br>transactional memory (STM). Software transactional memory<br>algorithms allow for concurrent access to shared...","title_summary":" Defining and Verifying Durable Opacity:<br>Correctness for Persistent Software Transactional Memory","x":-27.1709861755,"y":41.9720420837,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.1709861755,"tsne_y":41.9720420837,"subcluster":4,"subcluster_description":"Persistent Software Transactional","shape":"p"},{"cord_uid":"c8pbn8m1","source_x":"PMC","title":"Tutorial: Parameterized Verification with Byzantine Model Checker","doi":"10.1007\/978-3-030-50086-3_11","abstract":"Threshold guards are a basic primitive of many fault-tolerant algorithms that solve classical problems of distributed computing, such as reliable broadcast, two-phase commit, and consensus. Moreover, threshold guards can be found in recent blockchain algorithms such as Tendermint consensus. In this tutorial, we give an overview of the techniques implemented in Byzantine Model Checker (ByMC). ByMC implements several techniques for automatic verification of threshold-guarded distributed algorithms. These algorithms have the following features: (1) up to t of processes may crash or behave Byzantine; (2) the correct processes count messages and make progress when they receive sufficiently many messages, e.g., at least [Formula: see text]; (3) the number n of processes in the system is a parameter, as well as t; (4) and the parameters are restricted by a resilience condition, e.g., [Formula: see text]. Traditionally, these algorithms were implemented in distributed systems with up to ten participating processes. Nowadays, they are implemented in distributed systems that involve hundreds or thousands of processes. To make sure that these algorithms are still correct for that scale, it is imperative to verify them for all possible values of the parameters.","publish_time":1589328000000,"author_summary":" Konnov, Igor; Lazi\u0107, Marijana; Stoilkovska,<br>Ilina; Widder, Josef","abstract_summary":" Threshold guards are a basic primitive of many<br>fault-tolerant algorithms that solve classical problems of<br>distributed computing, such as reliable broadcast,<br>two-phase commit, and consensus. Moreover, threshold<br>guards can be found in recent blockchain algorithms<br>such as Tendermint consensus. In this tutorial, we<br>give an overview of the techniques implemented in<br>Byzantine Model Checker (ByMC). ByMC implements several<br>techniques for automatic verification of<br>threshold-guarded distributed algorithms. These algorithms<br>have the following features: (1) up to t of processes<br>may crash or behave Byzantine; (2) the correct<br>processes count messages and make progress when they<br>receive sufficiently many messages, e.g., at...","title_summary":" Tutorial: Parameterized Verification with<br>Byzantine Model Checker","x":-26.5677890778,"y":43.2899971008,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5677890778,"tsne_y":43.2899971008,"subcluster":22,"subcluster_description":"Metric Temporal Graph Logic","shape":"p"},{"cord_uid":"7spcne41","source_x":"PMC","title":"Typechecking Java Protocols with [St]Mungo","doi":"10.1007\/978-3-030-50086-3_12","abstract":"This is a tutorial paper on [St]Mungo, a toolchain based on multiparty session types and their connection to typestates for safe distributed programming in Java language. The StMungo (\u201cScribble-to-Mungo\u201d) tool is a bridge between multiparty session types and typestates. StMungo translates a communication protocol, namely a sequence of sends and receives of messages, given as a multiparty session type in the Scribble language, into a typestate specification and a Java API skeleton. The generated API skeleton is then further extended with the necessary logic, and finally typechecked by Mungo. The Mungo tool extends Java with (optional) typestate specifications. A typestate is a state machine specifying a Java object protocol, namely the permitted sequence of method calls of that object. Mungo statically typechecks that method calls follow the object\u2019s protocol, as defined by its typestate specification. Finally, if no errors are reported, the code is compiled with javac and run as standard Java code. In this tutorial paper we give an overview of the stages of the [St]Mungo toolchain, starting from Scribble communication protocols, translating to Java classes with typestates, and finally to typechecking method calls with Mungo. We illustrate the [St]Mungo toolchain via a real-world case study, the HTTP client-server request-response protocol over TCP. During the tutorial session, we will apply [St]Mungo to a range of examples having increasing complexity, with HTTP being one of them.","publish_time":1589328000000,"author_summary":" Voinea, A. Laura; Dardha, Ornela; Gay, Simon J.","abstract_summary":" This is a tutorial paper on [St]Mungo, a<br>toolchain based on multiparty session types and their<br>connection to typestates for safe distributed<br>programming in Java language. The StMungo<br>(\u201cScribble-to-Mungo\u201d) tool is a bridge between multiparty session<br>types and typestates. StMungo translates a<br>communication protocol, namely a sequence of sends and<br>receives of messages, given as a multiparty session type<br>in the Scribble language, into a typestate<br>specification and a Java API skeleton. The generated API<br>skeleton is then further extended with the necessary<br>logic, and finally typechecked by Mungo. The Mungo<br>tool extends Java with (optional) typestate<br>specifications. A typestate...","title_summary":" Typechecking Java Protocols with [St]Mungo","x":-26.7946491241,"y":43.2494010925,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7946491241,"tsne_y":43.2494010925,"subcluster":23,"subcluster_description":"Finite State Processesa Fast","shape":"p"},{"cord_uid":"3myuf5q2","source_x":"PMC","title":"On Implementable Timed Automata","doi":"10.1007\/978-3-030-50086-3_5","abstract":"Generating code from networks of timed automata is a well-researched topic with many proposed approaches, which have in common that they not only generate code for the processes in the network, but necessarily generate additional code for a global scheduler which implements the timed automata semantics. For distributed systems without shared memory, this additional component is, in general, undesired. In this work, we present a new approach to the generation of correct code (without global scheduler) for distributed systems without shared memory yet with (almost) synchronous clocks if the source model does not depend on a global scheduler. We characterise a set of implementable timed automata models and provide a translation to a timed while language. We show that each computation of the generated program has a network computation path with the same observable behaviour.","publish_time":1589328000000,"author_summary":" Feo-Arenis, Sergio; Vujinovi\u0107, Milan;<br>Westphal, Bernd","abstract_summary":" Generating code from networks of timed<br>automata is a well-researched topic with many proposed<br>approaches, which have in common that they not only generate<br>code for the processes in the network, but<br>necessarily generate additional code for a global<br>scheduler which implements the timed automata<br>semantics. For distributed systems without shared<br>memory, this additional component is, in general,<br>undesired. In this work, we present a new approach to the<br>generation of correct code (without global scheduler) for<br>distributed systems without shared memory yet with<br>(almost) synchronous clocks if the source model does not<br>depend on a global scheduler. We characterise...","title_summary":" On Implementable Timed Automata","x":-26.7205066681,"y":44.360004425,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7205066681,"tsne_y":44.360004425,"subcluster":36,"subcluster_description":"Parametric Component-Based Systemsproceedings Eighth","shape":"p"},{"cord_uid":"yakk8rru","source_x":"PMC","title":"Probabilistic Timed Automata with One Clock and Initialised Clock-Dependent Probabilities","doi":"10.1007\/978-3-030-50086-3_9","abstract":"Clock-dependent probabilistic timed automata extend classical timed automata with discrete probabilistic choice, where the probabilities are allowed to depend on the exact values of the clocks. Previous work has shown that the quantitative reachability problem for clock-dependent probabilistic timed automata with at least three clocks is undecidable. In this paper, we consider the subclass of clock-dependent probabilistic timed automata that have one clock, that have clock dependencies described by affine functions, and that satisfy an initialisation condition requiring that, at some point between taking edges with non-trivial clock dependencies, the clock must have an integer value. We present an approach for solving in polynomial time quantitative and qualitative reachability problems of such one-clock initialised clock-dependent probabilistic timed automata. Our results are obtained by a transformation to interval Markov decision processes.","publish_time":1589328000000,"author_summary":" Sproston, Jeremy","abstract_summary":" Clock-dependent probabilistic timed<br>automata extend classical timed automata with discrete<br>probabilistic choice, where the probabilities are allowed to<br>depend on the exact values of the clocks. Previous work<br>has shown that the quantitative reachability<br>problem for clock-dependent probabilistic timed<br>automata with at least three clocks is undecidable. In<br>this paper, we consider the subclass of<br>clock-dependent probabilistic timed automata that have one<br>clock, that have clock dependencies described by<br>affine functions, and that satisfy an initialisation<br>condition requiring that, at some point between taking<br>edges with non-trivial clock dependencies, the<br>clock must have an integer value. We present an<br>approach...","title_summary":" Probabilistic Timed Automata with One Clock<br>and Initialised Clock-Dependent Probabilities","x":-26.9008102417,"y":44.6895866394,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.9008102417,"tsne_y":44.6895866394,"subcluster":37,"subcluster_description":"Coloured Petri Nets","shape":"p"},{"cord_uid":"n6uribdn","source_x":"PMC","title":"Team Automata@Work: On Safe Communication","doi":"10.1007\/978-3-030-50029-0_5","abstract":"We study requirements for safe communication in systems of reactive components in which components communicate via synchronised execution of common actions. These systems are modelled in the framework of team automata in which any number of components can participate\u2014as a sender or as a receiver\u2014in the execution of a communication action. Moreover, there is no fixed synchronisation policy as these policies in general depend on the application. In this short paper, we reconsider the concept of safe communication in terms of reception and responsiveness requirements, originally defined for synchronisation policies determined by a synchronisation type. Illustrated by a motivating example, we propose three extensions. First, compliance, i.e. satisfaction of communication requirements, does not have to be immediate. Second, the synchronisation type (and hence the communication requirements) no longer has to be uniform, but can be specified per action. Third, we introduce final states to be able to distinguish between possible and guaranteed executions of actions.","publish_time":1589328000000,"author_summary":" ter Beek, Maurice H.; Hennicker, Rolf; Kleijn,<br>Jetty","abstract_summary":" We study requirements for safe communication<br>in systems of reactive components in which<br>components communicate via synchronised execution of<br>common actions. These systems are modelled in the<br>framework of team automata in which any number of<br>components can participate\u2014as a sender or as a receiver\u2014in<br>the execution of a communication action.<br>Moreover, there is no fixed synchronisation policy as<br>these policies in general depend on the application.<br>In this short paper, we reconsider the concept of<br>safe communication in terms of reception and<br>responsiveness requirements, originally defined for<br>synchronisation policies determined by a synchronisation<br>type. Illustrated by a motivating example,...","title_summary":" Team Automata@Work: On Safe Communication","x":-27.1901073456,"y":43.8962669373,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.1901073456,"tsne_y":43.8962669373,"subcluster":15,"subcluster_description":"Unfolding Colored Petri Nets","shape":"p"},{"cord_uid":"5htblpnl","source_x":"PMC","title":"Formal Modeling and Analysis of Medical Systems","doi":"10.1007\/978-3-030-50029-0_24","abstract":"Medical systems are composed of medical devices and apps which are developed independently by different vendors. A set of communication patterns, based on asynchronous message-passing, has been proposed to loosely integrate medical devices and apps. These patterns guarantee the point-to-point quality of communication service (QoS) by local inspection of messages at its constituent components. These local mechanisms inspect the property of messages to enforce a set of parametrized local QoS properties. Adjusting these parameters to achieve the required point-to-point QoS is non-trivial and depends on the involved components and the underlying network. We use Timed Rebeca, an actor-based formal modeling language, to model such systems and asses their QoS properties by model checking. We model the components of communication patterns as distinct actors. A composite medical system using several instances of patterns is subject to state-space explosion. We propose a reduction technique preserving QoS properties. We prove that our technique is sound and show the applicability of our approach in reducing the state space by modeling a clinical scenario made of several instances of patterns.","publish_time":1589328000000,"author_summary":" Zarneshan, Mahsa; Ghassemi, Fatemeh;<br>Sirjani, Marjan","abstract_summary":" Medical systems are composed of medical<br>devices and apps which are developed independently by<br>different vendors. A set of communication patterns,<br>based on asynchronous message-passing, has been<br>proposed to loosely integrate medical devices and apps.<br>These patterns guarantee the point-to-point<br>quality of communication service (QoS) by local<br>inspection of messages at its constituent components.<br>These local mechanisms inspect the property of<br>messages to enforce a set of parametrized local QoS<br>properties. Adjusting these parameters to achieve the<br>required point-to-point QoS is non-trivial and depends<br>on the involved components and the underlying<br>network. We use Timed Rebeca, an actor-based formal<br>modeling...","title_summary":" Formal Modeling and Analysis of Medical<br>Systems","x":-27.978099823,"y":43.4253845215,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.978099823,"tsne_y":43.4253845215,"subcluster":13,"subcluster_description":"Hybrid Programs","shape":"p"},{"cord_uid":"b7n7si3g","source_x":"PMC","title":"Towards a Formally Verified EVM in Production Environment","doi":"10.1007\/978-3-030-50029-0_21","abstract":"Among dozens of decentralized computing platforms, Ethereum attracts widespread attention for its native support of smart contracts by means of a virtual machine called Ethereum Virtual Machine (EVM). Programs can be developed in various front-end languages. For example, Solidity can be deployed to the blockchain in the form of compiled EVM opcodes. However, such flexibility leads to critical safety challenges. In this paper, we formally define the behavior of EVM in Why3, a platform for deductive program verification, which facilitates the verification of different properties. The extracted implementation in OCaml can be directly integrated into the production environment and tested against the standard test suite. The combination of proofs and testing in our framework serves as a powerful analysis basis for EVM and smart contracts.","publish_time":1589328000000,"author_summary":" Zhang, Xiyue; Li, Yi; Sun, Meng","abstract_summary":" Among dozens of decentralized computing<br>platforms, Ethereum attracts widespread attention for<br>its native support of smart contracts by means of a<br>virtual machine called Ethereum Virtual Machine<br>(EVM). Programs can be developed in various front-end<br>languages. For example, Solidity can be deployed to the<br>blockchain in the form of compiled EVM opcodes. However,<br>such flexibility leads to critical safety<br>challenges. In this paper, we formally define the behavior<br>of EVM in Why3, a platform for deductive program<br>verification, which facilitates the verification of<br>different properties. The extracted implementation in<br>OCaml can be directly integrated into the production<br>environment and tested...","title_summary":" Towards a Formally Verified EVM in Production<br>Environment","x":-27.3906440735,"y":43.0382270813,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.3906440735,"tsne_y":43.0382270813,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"oyvtx84b","source_x":"PMC","title":"Weighted PCL over Product Valuation Monoids","doi":"10.1007\/978-3-030-50029-0_19","abstract":"We introduce a weighted propositional configuration logic over a product valuation monoid. Our logic is intended to serve as a specification language for software architectures with quantitative features such as the average of all interactions\u2019 costs of the architecture and the maximum cost among all costs occurring most frequently within a specific number of components in an architecture. We provide formulas of our logic which describe well-known architectures equipped with quantitative characteristics. Moreover, we prove an efficient construction of a full normal form which leads to decidability of equivalence of formulas in this logic.","publish_time":1589328000000,"author_summary":" Karyoti, Vagia; Paraponiari, Paulina","abstract_summary":" We introduce a weighted propositional<br>configuration logic over a product valuation monoid. Our<br>logic is intended to serve as a specification<br>language for software architectures with quantitative<br>features such as the average of all interactions\u2019 costs<br>of the architecture and the maximum cost among all<br>costs occurring most frequently within a specific<br>number of components in an architecture. We provide<br>formulas of our logic which describe well-known<br>architectures equipped with quantitative characteristics.<br>Moreover, we prove an efficient construction of a full<br>normal form which leads to decidability of<br>equivalence of formulas in this logic.","title_summary":" Weighted PCL over Product Valuation Monoids","x":-25.078168869,"y":45.1162872314,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.078168869,"tsne_y":45.1162872314,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"fm0v6gv7","source_x":"PMC","title":"SFJ: An Implementation of Semantic Featherweight Java","doi":"10.1007\/978-3-030-50029-0_10","abstract":"There are two approaches to defining subtyping relations: the syntactic and the semantic approach. In semantic subtyping, one defines a model of the language and an interpretation of types as subsets of this model. Subtyping is defined as inclusion of subsets denoting types. An orthogonal subtyping question, typical of object-oriented languages, is the nominal versus the structural subtyping. Dardha et al. [11, 12] defined boolean types and semantic subtyping for Featherweight Java (FJ) and integrated both nominal and structural subtyping, thus exploiting the benefits of both approaches. However, these benefits were illustrated only at a theoretical level, but not exploited practically. We present SFJ\u2014Semantic Featherweight Java, an implementation of FJ which features boolean types, semantic subtyping and integrates nominal as well as structural subtyping. The benefits of SFJ, illustrated in the paper and the accompanying video (with audio\/subtitles) [27], show how static type-checking of boolean types and semantic subtyping gives higher guarantees of program correctness, more flexibility and compactness of program writing.","publish_time":1589328000000,"author_summary":" Usov, Artem; Dardha, Ornela","abstract_summary":" There are two approaches to defining subtyping<br>relations: the syntactic and the semantic approach. In<br>semantic subtyping, one defines a model of the language<br>and an interpretation of types as subsets of this<br>model. Subtyping is defined as inclusion of subsets<br>denoting types. An orthogonal subtyping question,<br>typical of object-oriented languages, is the nominal<br>versus the structural subtyping. Dardha et al. [11,<br>12] defined boolean types and semantic subtyping<br>for Featherweight Java (FJ) and integrated both<br>nominal and structural subtyping, thus exploiting the<br>benefits of both approaches. However, these benefits<br>were illustrated only at a theoretical level, but<br>not exploited...","title_summary":" SFJ: An Implementation of Semantic<br>Featherweight Java","x":-26.3170833588,"y":43.6247253418,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.3170833588,"tsne_y":43.6247253418,"subcluster":22,"subcluster_description":"Metric Temporal Graph Logic","shape":"p"},{"cord_uid":"aduhvcms","source_x":"PMC","title":"GoPi: Compiling Linear and Static Channels in Go","doi":"10.1007\/978-3-030-50029-0_9","abstract":"We identify two important features to enhance the design of communication protocols specified in the pi-calculus, that are linear and static channels, and present a compiler, named GoPi, that maps high level specifications into executable Go programs. Channels declared as linear are deadlock-free, while the scope of static channels, which are bound by a hide declaration, does not enlarge at runtime; this is enforced statically by means of type inference, while specifications do not include annotations. Well-behaved processes are transformed into Go code that supports non-deterministic synchronizations and race-freedom. We sketch two main examples involving protection against message forwarding, and forward secrecy, and discuss the features of the tool, and the generated code. We argue that GoPi can support academic activities involving process algebras and formal models, which range from the analysis and testing of concurrent processes for research purposes to teaching formal languages and concurrent systems.","publish_time":1589328000000,"author_summary":" Giunti, Marco","abstract_summary":" We identify two important features to enhance<br>the design of communication protocols specified<br>in the pi-calculus, that are linear and static<br>channels, and present a compiler, named GoPi, that maps<br>high level specifications into executable Go<br>programs. Channels declared as linear are<br>deadlock-free, while the scope of static channels, which are<br>bound by a hide declaration, does not enlarge at<br>runtime; this is enforced statically by means of type<br>inference, while specifications do not include<br>annotations. Well-behaved processes are transformed into<br>Go code that supports non-deterministic<br>synchronizations and race-freedom. We sketch two main examples<br>involving protection against message forwarding, and...","title_summary":" GoPi: Compiling Linear and Static Channels in<br>Go","x":-26.8030433655,"y":43.276966095,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.8030433655,"tsne_y":43.276966095,"subcluster":23,"subcluster_description":"Finite State Processesa Fast","shape":"p"},{"cord_uid":"igg7vvym","source_x":"PMC","title":"Combining SLiVER with CADP to Analyze Multi-agent Systems","doi":"10.1007\/978-3-030-50029-0_23","abstract":"We present an automated workflow for the analysis of multi-agent systems described in a simple specification language. The procedure is based on a structural encoding of the input system and the property of interest into an LNT program, and relies on the CADP software toolbox to either verify the given property or simulate the encoded system. Counterexamples to properties under verification, as well as simulation traces, are translated into a syntax similar to that of the input language: therefore, no knowledge of CADP is required. The workflow is implemented as a module of the verification tool SLiVER. We present the input specification language, describe the analysis workflow, and show how to invoke SLiVER to verify or simulate two example systems. Then, we provide details on the LNT encoding and the verification procedure.","publish_time":1589328000000,"author_summary":" Di Stefano, Luca; Lang, Fr\u00e9d\u00e9ric; Serwe,<br>Wendelin","abstract_summary":" We present an automated workflow for the<br>analysis of multi-agent systems described in a simple<br>specification language. The procedure is based on a<br>structural encoding of the input system and the property of<br>interest into an LNT program, and relies on the CADP<br>software toolbox to either verify the given property or<br>simulate the encoded system. Counterexamples to<br>properties under verification, as well as simulation<br>traces, are translated into a syntax similar to that of<br>the input language: therefore, no knowledge of<br>CADP is required. The workflow is implemented as a<br>module of the verification tool SLiVER. We present the...","title_summary":" Combining SLiVER with CADP to Analyze<br>Multi-agent Systems","x":-27.840795517,"y":43.7249488831,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.840795517,"tsne_y":43.7249488831,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"kbyq2la0","source_x":"PMC","title":"Architecture Modelling of Parametric Component-Based Systems","doi":"10.1007\/978-3-030-50029-0_18","abstract":"We study formal modelling of architectures applied on parametric component-based systems consisting of an unknown number of instances of each component. Architecture modelling is achieved by means of logics. We introduce an extended propositional interaction logic and investigate its first-order level which serves as a formal language for the interactions of parametric systems. Our logic effectively describes the execution order of interactions which is a main feature in several important architectures. We state the decidability of equivalence, satisfiability, and validity of first-order extended interaction logic formulas, and provide several examples of formulas describing well-known architectures.","publish_time":1589328000000,"author_summary":" Pittou, Maria; Rahonis, George","abstract_summary":" We study formal modelling of architectures<br>applied on parametric component-based systems<br>consisting of an unknown number of instances of each<br>component. Architecture modelling is achieved by means of<br>logics. We introduce an extended propositional<br>interaction logic and investigate its first-order level<br>which serves as a formal language for the<br>interactions of parametric systems. Our logic effectively<br>describes the execution order of interactions which is a<br>main feature in several important architectures.<br>We state the decidability of equivalence,<br>satisfiability, and validity of first-order extended<br>interaction logic formulas, and provide several examples<br>of formulas describing well-known<br>architectures.","title_summary":" Architecture Modelling of Parametric<br>Component-Based Systems","x":-26.7317810059,"y":44.4268569946,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7317810059,"tsne_y":44.4268569946,"subcluster":36,"subcluster_description":"Parametric Component-Based Systemsproceedings Eighth","shape":"p"},{"cord_uid":"z2ifu1d6","source_x":"PMC","title":"Implementing Multiparty Session Types in Rust","doi":"10.1007\/978-3-030-50029-0_8","abstract":"Multiparty Session Types (MPST) is a typing discipline for distributed protocols, which ensures communication safety and deadlock-freedom for more than two participants. This paper reports on our research project, implementing multiparty session types in Rust. Current Rust implementations of session types are limited to binary (two-party communications). We extend an existing library for binary session types to MPST. We have implemented a simplified Amazon Prime Video Streaming protocol using our library for both shared and distributed communication transports.","publish_time":1589328000000,"author_summary":" Lagaillardie, Nicolas; Neykova, Rumyana;<br>Yoshida, Nobuko","abstract_summary":" Multiparty Session Types (MPST) is a typing<br>discipline for distributed protocols, which ensures<br>communication safety and deadlock-freedom for more than two<br>participants. This paper reports on our research project,<br>implementing multiparty session types in Rust. Current Rust<br>implementations of session types are limited to binary<br>(two-party communications). We extend an existing<br>library for binary session types to MPST. We have<br>implemented a simplified Amazon Prime Video Streaming<br>protocol using our library for both shared and<br>distributed communication transports.","title_summary":" Implementing Multiparty Session Types in Rust","x":-27.0618095398,"y":42.9949951172,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.0618095398,"tsne_y":42.9949951172,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"a53ofpe5","source_x":"PMC","title":"Operational Representation of Dependencies in Context-Dependent Event Structures","doi":"10.1007\/978-3-030-50029-0_20","abstract":"The execution of an event in a complex and distributed system where the dependencies vary during the evolution of the system can be represented in many ways, and one of them is to use Context-Dependent Event structures. Many kinds of event structures are related to various kind of Petri nets. The aim of this paper is to find the appropriate kind of Petri net that can be used to give an operational flavour to the dependencies represented in a Context\/Dependent Event structure.","publish_time":1589328000000,"author_summary":" Pinna, G. Michele","abstract_summary":" The execution of an event in a complex and<br>distributed system where the dependencies vary during the<br>evolution of the system can be represented in many ways,<br>and one of them is to use Context-Dependent Event<br>structures. Many kinds of event structures are related to<br>various kind of Petri nets. The aim of this paper is to<br>find the appropriate kind of Petri net that can be<br>used to give an operational flavour to the<br>dependencies represented in a Context\/Dependent Event<br>structure.","title_summary":" Operational Representation of Dependencies<br>in Context-Dependent Event Structures","x":-28.7247200012,"y":42.6259727478,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.7247200012,"tsne_y":42.6259727478,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"ebtjp306","source_x":"PMC","title":"On Implementing Symbolic Controllability","doi":"10.1007\/978-3-030-50029-0_22","abstract":"Runtime Monitors observe the execution of a system with the aim of reaching a verdict about it. One property that is expected of monitors is consistent verdict detections; this property was characterised in prior work via a symbolic analysis called symbolic controllability. This paper explores whether the proposed symbolic analysis lends itself well to the construction of a tool that checks monitors for this deterministic behaviour. We implement a prototype that automates this symbolic analysis, and establish complexity upper bounds for the algorithm used. We also consider a number of optimisations for the implemented prototype, and assess the potential gains against benchmark monitors.","publish_time":1589328000000,"author_summary":" Francalanza, Adrian; Xuereb, Jasmine","abstract_summary":" Runtime Monitors observe the execution of a<br>system with the aim of reaching a verdict about it. One<br>property that is expected of monitors is consistent<br>verdict detections; this property was characterised<br>in prior work via a symbolic analysis called<br>symbolic controllability. This paper explores whether<br>the proposed symbolic analysis lends itself well<br>to the construction of a tool that checks monitors<br>for this deterministic behaviour. We implement a<br>prototype that automates this symbolic analysis, and<br>establish complexity upper bounds for the algorithm<br>used. We also consider a number of optimisations for<br>the implemented prototype, and assess the<br>potential gains...","title_summary":" On Implementing Symbolic Controllability","x":-27.1339492798,"y":44.0560150146,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.1339492798,"tsne_y":44.0560150146,"subcluster":15,"subcluster_description":"Unfolding Colored Petri Nets","shape":"p"},{"cord_uid":"mjdu7hq1","source_x":"PMC","title":"Choreography Automata","doi":"10.1007\/978-3-030-50029-0_6","abstract":"Automata models are well-established in many areas of computer science and are supported by a wealth of theoretical results including a wide range of algorithms and techniques to specify and analyse systems. We introduce choreography automata for the choreographic modelling of communicating systems. The projection of a choreography automaton yields a system of communicating finite-state machines. We consider both the standard asynchronous semantics of communicating systems and a synchronous variant of it. For both, the projections of well-formed automata are proved to be live as well as lock- and deadlock-free.","publish_time":1589328000000,"author_summary":" Barbanera, Franco; Lanese, Ivan; Tuosto,<br>Emilio","abstract_summary":" Automata models are well-established in many<br>areas of computer science and are supported by a<br>wealth of theoretical results including a wide range<br>of algorithms and techniques to specify and<br>analyse systems. We introduce choreography automata<br>for the choreographic modelling of communicating<br>systems. The projection of a choreography automaton<br>yields a system of communicating finite-state<br>machines. We consider both the standard asynchronous<br>semantics of communicating systems and a synchronous<br>variant of it. For both, the projections of well-formed<br>automata are proved to be live as well as lock- and<br>deadlock-free.","title_summary":" Choreography Automata","x":-26.6458969116,"y":44.620300293,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6458969116,"tsne_y":44.620300293,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"n0yth008","source_x":"PMC","title":"ARx: Reactive Programming for Synchronous Connectors","doi":"10.1007\/978-3-030-50029-0_3","abstract":"Reactive programming (RP) languages and Synchronous Coordination (SC) languages share the goal of orchestrating the execution of computational tasks, by imposing dependencies on their execution order and controlling how they share data. RP is often implemented as libraries for existing programming languages, lifting operations over values to operations over streams of values, and providing efficient solutions to manage how updates to such streams trigger reactions, i.e., the execution of dependent tasks. SC is often implemented as a standalone formalism to specify existing component-based architectures, used to analyse, verify, transform, or generate code. These two approaches target different audiences, and it is non-trivial to combine the programming style of RP with the expressive power of synchronous languages. This paper proposes a lightweight programming language to describe component-based Architectures for Reactive systems, dubbed ARx, which blends concepts from RP and SC, mainly inspired to the Reo coordination language and its composition operation, and with tailored constructs for reactive programs such as the ones found in ReScala. ARx is enriched with a type system and with algebraic data types, and has a reactive semantics inspired in RP. We provide typical examples from both the RP and SC literature, illustrate how these can be captured by the proposed language, and describe a web-based prototype tool to edit, parse, and type check programs, and to animate their semantics.","publish_time":1589328000000,"author_summary":" Proen\u00e7a, Jos\u00e9; Cledou, Guillermina","abstract_summary":" Reactive programming (RP) languages and<br>Synchronous Coordination (SC) languages share the goal of<br>orchestrating the execution of computational tasks, by<br>imposing dependencies on their execution order and<br>controlling how they share data. RP is often implemented as<br>libraries for existing programming languages, lifting<br>operations over values to operations over streams of<br>values, and providing efficient solutions to manage<br>how updates to such streams trigger reactions,<br>i.e., the execution of dependent tasks. SC is often<br>implemented as a standalone formalism to specify existing<br>component-based architectures, used to analyse, verify,<br>transform, or generate code. These two approaches target<br>different audiences, and it...","title_summary":" ARx: Reactive Programming for Synchronous<br>Connectors","x":-27.0076274872,"y":43.2666130066,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.0076274872,"tsne_y":43.2666130066,"subcluster":23,"subcluster_description":"Finite State Processesa Fast","shape":"p"},{"cord_uid":"umqoh5xt","source_x":"PMC","title":"Choreographic Development of Message-Passing Applications: A Tutorial","doi":"10.1007\/978-3-030-50029-0_2","abstract":"Choreographic development envisages distributed coordination as determined by interactions that allow peer components to harmoniously realise a given task. Unlike in orchestration-based coordination, there is no special component directing the execution. Recently, choreographic approaches have become popular in industrial contexts where reliability and scalability are crucial factors. This tutorial reviews some recent ideas to harness choreographic development of message-passing software. The key features of the approach are showcased within [Image: see text] , a toolchain which allows software architects to identify defects of message-passing applications at early stages of development.","publish_time":1589328000000,"author_summary":" Coto, Alex; Guanciale, Roberto; Tuosto,<br>Emilio","abstract_summary":" Choreographic development envisages<br>distributed coordination as determined by interactions<br>that allow peer components to harmoniously realise<br>a given task. Unlike in orchestration-based<br>coordination, there is no special component directing the<br>execution. Recently, choreographic approaches have<br>become popular in industrial contexts where<br>reliability and scalability are crucial factors. This<br>tutorial reviews some recent ideas to harness<br>choreographic development of message-passing software. The<br>key features of the approach are showcased within<br>[Image: see text] , a toolchain which allows software<br>architects to identify defects of message-passing<br>applications at early stages of development.","title_summary":" Choreographic Development of<br>Message-Passing Applications: A Tutorial","x":-28.0372428894,"y":42.7998847961,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.0372428894,"tsne_y":42.7998847961,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"i5ixkrd9","source_x":"PMC","title":"A Choreography-Driven Approach to APIs: The OpenDXL Case Study","doi":"10.1007\/978-3-030-50029-0_7","abstract":"We propose a model-driven approach based on formal data-driven choreographies to model message-passing applications. We apply our approach to the threat intelligence exchange (TIE) services provided by McAfee through the OpenDXL industrial platform. We advocate a chain of model transformations that (i) devises a visual presentation of communication protocols, (ii) formalises a global specification from the visual presentation that captures the data flow among services, (iii) enables the automatic derivation of specifications for the single components, and (iv) enables the analysis of software implementations.","publish_time":1589328000000,"author_summary":" Frittelli, Leonardo; Maldonado, Facundo;<br>Melgratti, Hern\u00e1n; Tuosto, Emilio","abstract_summary":" We propose a model-driven approach based on<br>formal data-driven choreographies to model<br>message-passing applications. We apply our approach to the<br>threat intelligence exchange (TIE) services<br>provided by McAfee through the OpenDXL industrial<br>platform. We advocate a chain of model transformations<br>that (i) devises a visual presentation of<br>communication protocols, (ii) formalises a global<br>specification from the visual presentation that captures the<br>data flow among services, (iii) enables the<br>automatic derivation of specifications for the single<br>components, and (iv) enables the analysis of software<br>implementations.","title_summary":" A Choreography-Driven Approach to APIs: The<br>OpenDXL Case Study","x":-28.3169307709,"y":42.745136261,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.3169307709,"tsne_y":42.745136261,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"fssrnl9a","source_x":"PMC","title":"Renegotiation and Recursion in Bitcoin Contracts","doi":"10.1007\/978-3-030-50029-0_17","abstract":"BitML is a process calculus to express smart contracts that can be run on Bitcoin. One of its current limitations is that, once a contract has been stipulated, the participants cannot renegotiate its terms: this prevents expressing common financial contracts, where funds have to be added by participants at run-time. In this paper, we extend BitML with a new primitive for contract renegotiation. At the same time, the new primitive can be used to write recursive contracts, which was not possible in the original BitML. We show that, despite the increased expressiveness, it is still possible to execute BitML on standard Bitcoin, preserving the security guarantees of BitML.","publish_time":1589328000000,"author_summary":" Bartoletti, Massimo; Murgia, Maurizio;<br>Zunino, Roberto","abstract_summary":" BitML is a process calculus to express smart<br>contracts that can be run on Bitcoin. One of its current<br>limitations is that, once a contract has been stipulated,<br>the participants cannot renegotiate its terms:<br>this prevents expressing common financial<br>contracts, where funds have to be added by participants at<br>run-time. In this paper, we extend BitML with a new<br>primitive for contract renegotiation. At the same time,<br>the new primitive can be used to write recursive<br>contracts, which was not possible in the original BitML. We<br>show that, despite the increased expressiveness,<br>it is still possible to execute BitML on...","title_summary":" Renegotiation and Recursion in Bitcoin<br>Contracts","x":-26.7707214355,"y":43.1712608337,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7707214355,"tsne_y":43.1712608337,"subcluster":23,"subcluster_description":"Finite State Processesa Fast","shape":"p"},{"cord_uid":"r8a3mfsk","source_x":"PMC","title":"Scalable Hierarchical Aggregation and Reduction Protocol (SHARP)(TM) Streaming-Aggregation Hardware Design and Evaluation","doi":"10.1007\/978-3-030-50743-5_3","abstract":"This paper describes the new hardware-based streaming-aggregation capability added to Mellanox\u2019s Scalable Hierarchical Aggregation and Reduction Protocol in its HDR InfiniBand switches. For large messages, this capability is designed to achieve reduction bandwidths similar to those of point-to-point messages of the same size, and complements the latency-optimized low-latency aggregation reduction capabilities, aimed at small data reductions. MPI_Allreduce() bandwidth measured on an HDR InfiniBand based system achieves about 95% of network bandwidth. For medium and large data reduction this also improves the reduction bandwidth by a factor of 2\u20135 relative to host-based (e.g., software-based) reduction algorithms. Using this capability also increased DL-Poly and PyTorch application performance by as much as 4% and 18%, respectively. This paper describes SHARP Streaming-Aggregation hardware architecture and a set of synthetic and application benchmarks used to study this new reduction capability, and the range of data sizes for which Streaming-Aggregation performs better than the low-latency aggregation algorithm.","publish_time":1590105600000,"author_summary":" Graham, Richard L.; Levi, Lion; Burredy,<br>Devendar; Bloch, Gil; Shainer, Gilad; Cho, David; Elias,<br>George; Klein, Daniel; Ladd, Joshua; Maor, Ophir;<br>Marelli, Ami; Petrov, Valentin; Romlet, Evyatar; Qin,<br>Yong; Zemah, Ido","abstract_summary":" This paper describes the new hardware-based<br>streaming-aggregation capability added to Mellanox\u2019s Scalable<br>Hierarchical Aggregation and Reduction Protocol in its HDR<br>InfiniBand switches. For large messages, this capability<br>is designed to achieve reduction bandwidths<br>similar to those of point-to-point messages of the same<br>size, and complements the latency-optimized<br>low-latency aggregation reduction capabilities, aimed at<br>small data reductions. MPI_Allreduce() bandwidth<br>measured on an HDR InfiniBand based system achieves<br>about 95% of network bandwidth. For medium and large<br>data reduction this also improves the reduction<br>bandwidth by a factor of 2\u20135 relative to host-based (e.g.,<br>software-based) reduction algorithms. Using this capability<br>also increased...","title_summary":" Scalable Hierarchical Aggregation and<br>Reduction Protocol (SHARP)(TM) Streaming-Aggregation<br>Hardware Design and Evaluation","x":-26.6151542664,"y":39.7470092773,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6151542664,"tsne_y":39.7470092773,"subcluster":6,"subcluster_description":"Genomics Data Processing","shape":"p"},{"cord_uid":"321vyww7","source_x":"PMC","title":"FASTHash: FPGA-Based High Throughput Parallel Hash Table","doi":"10.1007\/978-3-030-50743-5_1","abstract":"Hash table is a fundamental data structure that provides efficient data store and access. It is a key component in AI applications which rely on building a model of the environment using observations and performing lookups on the model for newer observations. In this work, we develop FASTHash, a \u201ctruly\u201d high throughput parallel hash table implementation using FPGA on-chip SRAM. Contrary to state-of-the-art hash table implementations on CPU, GPU, and FPGA, the parallelism in our design is data independent, allowing us to support p parallel queries ([Formula: see text]) per clock cycle via p processing engines (PEs) in the worst case. Our novel data organization and query flow techniques allow full utilization of abundant low latency on-chip SRAM and enable conflict free concurrent insertions. Our hash table ensures relaxed eventual consistency - inserts from a PE are visible to all PEs with some latency. We provide theoretical worst case bound on the number of erroneous queries (true negative search, duplicate inserts) due to relaxed eventual consistency. We customize our design to implement both static and dynamic hash tables on state-of-the-art FPGA devices. Our implementations are scalable to 16 PEs and support throughput as high as 5360 million operations per second with PEs running at 335 MHz for static hashing and 4480 million operations per second with PEs running at 280 MHz for dynamic hashing. They outperform state-of-the-art implementations by 5.7x and 8.7x respectively.","publish_time":1590105600000,"author_summary":" Yang, Yang; Kuppannagari, Sanmukh R.;<br>Srivastava, Ajitesh; Kannan, Rajgopal; Prasanna, Viktor<br>K.","abstract_summary":" Hash table is a fundamental data structure that<br>provides efficient data store and access. It is a key<br>component in AI applications which rely on building a<br>model of the environment using observations and<br>performing lookups on the model for newer observations. In<br>this work, we develop FASTHash, a \u201ctruly\u201d high<br>throughput parallel hash table implementation using FPGA<br>on-chip SRAM. Contrary to state-of-the-art hash table<br>implementations on CPU, GPU, and FPGA, the parallelism in our<br>design is data independent, allowing us to support p<br>parallel queries ([Formula: see text]) per clock cycle<br>via p processing engines (PEs) in the worst...","title_summary":" FASTHash: FPGA-Based High Throughput<br>Parallel Hash Table","x":-26.434463501,"y":40.2325897217,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.434463501,"tsne_y":40.2325897217,"subcluster":9,"subcluster_description":"Accelerated Architecturesutilizing Gpu Performance","shape":"p"},{"cord_uid":"axfoktwu","source_x":"PMC","title":"Predicting Job Power Consumption Based on RJMS Submission Data in HPC Systems","doi":"10.1007\/978-3-030-50743-5_4","abstract":"Power-aware scheduling is a promising solution to the resource usage monitoring of High-Performance Computing facility electrical power consumption. This kind of solution needs a reliable estimation of job power consumption to feed the Resources and Jobs Management System at submission time. Available data for inference is restricted in practice because unavailable or even untrustworthy. We propose in this work an instance-based model using only the submission logs and user provided job data. GID and the number of tasks per node appears to be good features for prediction of a job\u2019s average power consumption. Moreover, we extant this model to production context with online computation to make a practical global power prediction from job submission data using instances re-weighting. The performance of the online model are excellent on COBALT\u2019s data. With any doubt this model will be a good candidate for the achievement of consistent power-aware scheduling for other computing centers with similar informative inputs.","publish_time":1590105600000,"author_summary":" Saillant, Th\u00e9o; Weill, Jean-Christophe;<br>Mougeot, Mathilde","abstract_summary":" Power-aware scheduling is a promising<br>solution to the resource usage monitoring of<br>High-Performance Computing facility electrical power<br>consumption. This kind of solution needs a reliable<br>estimation of job power consumption to feed the Resources<br>and Jobs Management System at submission time.<br>Available data for inference is restricted in practice<br>because unavailable or even untrustworthy. We propose<br>in this work an instance-based model using only<br>the submission logs and user provided job data. GID<br>and the number of tasks per node appears to be good<br>features for prediction of a job\u2019s average power<br>consumption. Moreover, we extant this model to production...","title_summary":" Predicting Job Power Consumption Based on RJMS<br>Submission Data in HPC Systems","x":-26.7298851013,"y":39.5663757324,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7298851013,"tsne_y":39.5663757324,"subcluster":6,"subcluster_description":"Genomics Data Processing","shape":"p"},{"cord_uid":"4tb68p4u","source_x":"PMC","title":"Load-Balancing Parallel Relational Algebra","doi":"10.1007\/978-3-030-50743-5_15","abstract":"Relational algebra (RA) comprises a basis of important operations, sufficient to power state-of-the-art reasoning engines for Datalog and related logic-programming languages. Parallel RA implementations can thus play a significant role in extracting parallelism inherent in a wide variety of analytic problems. In general, bottom-up logical inference can be implemented as fixed-point iteration over RA kernels; relations dynamically accumulate new tuples of information according to a set of rules until no new tuples can be discovered from previously inferred tuples and relevant rules (RA kernels). While this strategy has been quite successful in single-node contexts, it poses unique challenges when distributed over many-node, networked clusters\u2014especially regarding how the work-load is balanced across available compute resources. In this paper, we identify two fundamental kinds of load imbalance and present a strategy to address each. We investigate both spatial load imbalance\u2014imbalance across each relation (across compute nodes)\u2014and temporal load imbalance\u2013imbalance in tuples produced across fixed-point iterations. For spatial balancing, we implement refinement and consolidation procedures. For temporal balancing, we implement a technique that permits the residual workload from a busy iteration to roll over to a new iteration. In sum, these techniques permit fully dynamic load-balancing of relational algebra that is robust to changes across time.","publish_time":1590105600000,"author_summary":" Kumar, Sidharth; Gilray, Thomas","abstract_summary":" Relational algebra (RA) comprises a basis of<br>important operations, sufficient to power<br>state-of-the-art reasoning engines for Datalog and related<br>logic-programming languages. Parallel RA implementations can<br>thus play a significant role in extracting<br>parallelism inherent in a wide variety of analytic<br>problems. In general, bottom-up logical inference can be<br>implemented as fixed-point iteration over RA kernels;<br>relations dynamically accumulate new tuples of<br>information according to a set of rules until no new tuples<br>can be discovered from previously inferred tuples<br>and relevant rules (RA kernels). While this<br>strategy has been quite successful in single-node<br>contexts, it poses unique challenges when distributed...","title_summary":" Load-Balancing Parallel Relational Algebra","x":-26.5873355865,"y":40.2828483582,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5873355865,"tsne_y":40.2828483582,"subcluster":8,"subcluster_description":"Hardware-Assisted Mpi Overlap Enginesimplifying","shape":"p"},{"cord_uid":"qn74ij80","source_x":"PMC","title":"Pattern-Aware Staging for Hybrid Memory Systems","doi":"10.1007\/978-3-030-50743-5_24","abstract":"The ever increasing demand for higher memory performance and\u2014at the same time\u2014larger memory capacity is leading the industry towards hybrid main memory designs, i.e., memory systems that consist of multiple different memory technologies. This trend, however, naturally leads to one important question: how can we efficiently utilize such hybrid memories? Our paper proposes a software-based approach to solve this challenge by deploying a pattern-aware staging technique. Our work is based on the following observations: (a) the high-bandwidth fast memory outperforms the large memory for memory intensive tasks; (b) but those tasks can run for much longer than a bulk data copy to\/from the fast memory, especially when the access pattern is more irregular\/sparse. We exploit these observations by applying the following staging technique if the accesses are irregular and sparse: (1) copying a chunk (few GB of sequential data) from large to fast memory; (2) performing a memory intensive task on the chunk; and (3) writing it back to the large memory. To check the regularity\/sparseness of the accesses at runtime with negligible performance impact, we develop a lightweight pattern detection mechanism using a helper threading inspired approach with two different Bloom filters. Our case study using various scientific codes on a real system shows that our approach achieves significant speed-ups compared to executions with using only the large memory or hardware caching: 3[Formula: see text] or 41% speedups in the best, respectively.","publish_time":1590105600000,"author_summary":" Arima, Eishi; Schulz, Martin","abstract_summary":" The ever increasing demand for higher memory<br>performance and\u2014at the same time\u2014larger memory capacity is<br>leading the industry towards hybrid main memory<br>designs, i.e., memory systems that consist of multiple<br>different memory technologies. This trend, however,<br>naturally leads to one important question: how can we<br>efficiently utilize such hybrid memories? Our paper<br>proposes a software-based approach to solve this<br>challenge by deploying a pattern-aware staging<br>technique. Our work is based on the following<br>observations: (a) the high-bandwidth fast memory<br>outperforms the large memory for memory intensive tasks;<br>(b) but those tasks can run for much longer than a<br>bulk data...","title_summary":" Pattern-Aware Staging for Hybrid Memory<br>Systems","x":-26.7580356598,"y":40.2064208984,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7580356598,"tsne_y":40.2064208984,"subcluster":8,"subcluster_description":"Hardware-Assisted Mpi Overlap Enginesimplifying","shape":"p"},{"cord_uid":"n4e7nraa","source_x":"PMC","title":"Understanding HPC Benchmark Performance on Intel Broadwell and Cascade Lake Processors","doi":"10.1007\/978-3-030-50743-5_21","abstract":"Hardware platforms in high performance computing are constantly getting more complex to handle even when considering multicore CPUs alone. Numerous features and configuration options in the hardware and the software environment that are relevant for performance are not even known to most application users or developers. Microbenchmarks, i.e., simple codes that fathom a particular aspect of the hardware, can help to shed light on such issues, but only if they are well understood and if the results can be reconciled with known facts or performance models. The insight gained from microbenchmarks may then be applied to real applications for performance analysis or optimization. In this paper we investigate two modern Intel x86 server CPU architectures in depth: Broadwell EP and Cascade Lake SP. We highlight relevant hardware configuration settings that can have a decisive impact on code performance and show how to properly measure on-chip and off-chip data transfer bandwidths. The new victim L3 cache of Cascade Lake and its advanced replacement policy receive due attention. Finally we use DGEMM, sparse matrix-vector multiplication, and the HPCG benchmark to make a connection to relevant application scenarios.","publish_time":1590105600000,"author_summary":" Alappat, Christie L.; Hofmann, Johannes;<br>Hager, Georg; Fehske, Holger; Bishop, Alan R.;<br>Wellein, Gerhard","abstract_summary":" Hardware platforms in high performance<br>computing are constantly getting more complex to handle<br>even when considering multicore CPUs alone.<br>Numerous features and configuration options in the<br>hardware and the software environment that are relevant<br>for performance are not even known to most<br>application users or developers. Microbenchmarks, i.e.,<br>simple codes that fathom a particular aspect of the<br>hardware, can help to shed light on such issues, but only if<br>they are well understood and if the results can be<br>reconciled with known facts or performance models. The<br>insight gained from microbenchmarks may then be<br>applied to real applications for performance...","title_summary":" Understanding HPC Benchmark Performance on<br>Intel Broadwell and Cascade Lake Processors","x":-26.6777305603,"y":40.2605781555,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6777305603,"tsne_y":40.2605781555,"subcluster":8,"subcluster_description":"Hardware-Assisted Mpi Overlap Enginesimplifying","shape":"p"},{"cord_uid":"tdeveikn","source_x":"PMC","title":"Shared-Memory Parallel Probabilistic Graphical Modeling Optimization: Comparison of Threads, OpenMP, and Data-Parallel Primitives","doi":"10.1007\/978-3-030-50743-5_7","abstract":"This work examines performance characteristics of multiple shared-memory implementations of a probabilistic graphical modeling (PGM) optimization code, which forms the basis for an advanced, state-of-the art image segmentation method. The work is motivated by the need to accelerate scientific image analysis pipelines in use by experimental science, such as at x-ray light sources, and is motivated by the need for platform-portable codes that perform well across many different computational architectures. The primary focus of this work and its main contribution is an in-depth study of shared-memory parallel performance of different implementations, which include those using alternative parallelization approaches such as C11-threads, OpenMP, and data parallel primitives (DPPs). Our results show that, for this complex data-intensive algorithm, the DPP implementation exhibits better runtime performance, but also exhibits less favorable scaling characteristics than the C11-threads and OpenMP counterparts. Based upon a set of experiments that collect hardware performance counters on multiple platforms, the reason for the runtime performance difference appears to be due primarily to algorithmic efficiency gains: the reformulation from the traditional C11-threads and OpenMP expression of the solution into that of data parallel primitives results in significantly fewer instructions being executed. This study is the first of its type to do performance analysis using hardware counters for comparing methods based on VTK-m-based data-parallel primitives with those based on more traditional OpenMP or threads-based parallelism. It is timely, as there is increasing awareness of the need for platform portability in light of increasing node-level parallelism and increasing device heterogeneity.","publish_time":1590105600000,"author_summary":" Perciano, Talita; Heinemann, Colleen; Camp,<br>David; Lessley, Brenton; Bethel, E. Wes","abstract_summary":" This work examines performance<br>characteristics of multiple shared-memory implementations of<br>a probabilistic graphical modeling (PGM)<br>optimization code, which forms the basis for an advanced,<br>state-of-the art image segmentation method. The work is<br>motivated by the need to accelerate scientific image<br>analysis pipelines in use by experimental science, such<br>as at x-ray light sources, and is motivated by the<br>need for platform-portable codes that perform well<br>across many different computational architectures.<br>The primary focus of this work and its main<br>contribution is an in-depth study of shared-memory parallel<br>performance of different implementations, which include<br>those using alternative parallelization<br>approaches such as...","title_summary":" Shared-Memory Parallel Probabilistic<br>Graphical Modeling Optimization: Comparison of<br>Threads, OpenMP, and Data-Parallel Primitives","x":-26.4993877411,"y":40.2506217957,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.4993877411,"tsne_y":40.2506217957,"subcluster":9,"subcluster_description":"Accelerated Architecturesutilizing Gpu Performance","shape":"p"},{"cord_uid":"evmbx65o","source_x":"PMC","title":"Embedding Algorithms for Quantum Annealers with Chimera and Pegasus Connection Topologies","doi":"10.1007\/978-3-030-50743-5_10","abstract":"We propose two new algorithms \u2013 Spring-Based MinorMiner (SPMM) and Clique-Based MinorMiner (CLMM) \u2013 which take as input the connectivity graph of a Quadratic Unconstrained Binary Optimization (QUBO) problem and produce as output an embedding of the input graph on a host graph that models the topology of a quantum computing device. As host graphs, we take the Chimera graph and the Pegasus graph, which are the topology graphs of D-Wave\u2019s 2000 qubit (first introduced in 2017) and 5000 qubit (expected 2020) quantum annealer devices, respectively. We evaluate our algorithms on a large set of random graph QUBO inputs (Erd\u0151s-R\u00e9nyi [Formula: see text], Barab\u00e1si-Albert and d-regular graphs) on both host topologies against other embedding algorithms. For the Pegasus topology, we find that CLMM outperforms all other algorithms at edge densities larger than 0.08, while SPMM wins at edge densities smaller than 0.08 for Erd\u0151s-R\u00e9nyi graphs, with very similar transition densities for the other graph classes. Surprisingly, the standard D-Wave MinorMiner embedding algorithm \u2013 while also getting slightly outperformed by SPMM for sparse and very dense graphs on Chimera \u2013 does not manage to extend its overall good performance on Chimera to Pegasus as it fails to embed even medium-density graphs on 175\u2013180 nodes which are known to have clique embeddings on Pegasus.","publish_time":1590105600000,"author_summary":" Zbinden, Stefanie; B\u00e4rtschi, Andreas;<br>Djidjev, Hristo; Eidenbenz, Stephan","abstract_summary":" We propose two new algorithms \u2013 Spring-Based<br>MinorMiner (SPMM) and Clique-Based MinorMiner (CLMM) \u2013<br>which take as input the connectivity graph of a<br>Quadratic Unconstrained Binary Optimization (QUBO)<br>problem and produce as output an embedding of the input<br>graph on a host graph that models the topology of a<br>quantum computing device. As host graphs, we take the<br>Chimera graph and the Pegasus graph, which are the<br>topology graphs of D-Wave\u2019s 2000 qubit (first<br>introduced in 2017) and 5000 qubit (expected 2020) quantum<br>annealer devices, respectively. We evaluate our<br>algorithms on a large set of random graph QUBO inputs<br>(Erd\u0151s-R\u00e9nyi...","title_summary":" Embedding Algorithms for Quantum Annealers<br>with Chimera and Pegasus Connection Topologies","x":-23.1151237488,"y":41.6775970459,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.1151237488,"tsne_y":41.6775970459,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"sbocx0v4","source_x":"PMC","title":"Offsite Autotuning Approach: Performance Model Driven Autotuning Applied to Parallel Explicit ODE Methods","doi":"10.1007\/978-3-030-50743-5_19","abstract":"Autotuning (AT) is a promising concept to minimize the often tedious manual effort of optimizing scientific applications for a specific target platform. Ideally, an AT approach can reliably identify the most efficient implementation variant(s) for a new platform or new characteristics of the input by applying suitable program transformations and analytic models. In this work, we introduce Offsite, an offline AT approach that automates this selection process at installation time by rating implementation variants based on an analytic performance model without requiring time-consuming runtime tests. From abstract multilevel description languages, Offsite automatically derives optimized, platform-specific and problem-specific code of possible variants and applies the performance model to these variants. We apply Offsite to parallel numerical methods for ordinary differential equations (ODEs). In particular, we investigate tuning a specific class of explicit ODE solvers, PIRK methods, for four different initial value problems (IVPs) on three different shared-memory systems. Our experiments demonstrate that Offsite can reliably identify the set of most efficient implementation variants for different given test configurations (ODE solver, IVP, platform) and effectively handle important AT scenarios.","publish_time":1590105600000,"author_summary":" Seiferth, Johannes; Korch, Matthias; Rauber,<br>Thomas","abstract_summary":" Autotuning (AT) is a promising concept to<br>minimize the often tedious manual effort of optimizing<br>scientific applications for a specific target platform.<br>Ideally, an AT approach can reliably identify the most<br>efficient implementation variant(s) for a new platform<br>or new characteristics of the input by applying<br>suitable program transformations and analytic models.<br>In this work, we introduce Offsite, an offline AT<br>approach that automates this selection process at<br>installation time by rating implementation variants based<br>on an analytic performance model without<br>requiring time-consuming runtime tests. From abstract<br>multilevel description languages, Offsite<br>automatically derives optimized, platform-specific and<br>problem-specific code of possible...","title_summary":" Offsite Autotuning Approach: Performance<br>Model Driven Autotuning Applied to Parallel<br>Explicit ODE Methods","x":-26.5129089355,"y":40.8340110779,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5129089355,"tsne_y":40.8340110779,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"kgoi8miq","source_x":"PMC","title":"Scaling Genomics Data Processing with Memory-Driven Computing to Accelerate Computational Biology","doi":"10.1007\/978-3-030-50743-5_17","abstract":"Research is increasingly becoming data-driven, and natural sciences are not an exception. In both biology and medicine, we are observing an exponential growth of structured data collections from experiments and population studies, enabling us to gain novel insights that would otherwise not be possible. However, these growing data sets pose a challenge for existing compute infrastructures since data is outgrowing limits within compute. In this work, we present the application of a novel approach, Memory-Driven Computing (MDC), in the life sciences. MDC proposes a data-centric approach that has been designed for growing data sizes and provides a composable infrastructure for changing workloads. In particular, we show how a typical pipeline for genomics data processing can be accelerated, and application modifications required to exploit this novel architecture. Furthermore, we demonstrate how the isolated evaluation of individual tasks misses significant overheads of typical pipelines in genomics data processing.","publish_time":1590105600000,"author_summary":" Becker, Matthias; Worlikar, Umesh; Agrawal,<br>Shobhit; Schultze, Hartmut; Ulas, Thomas; Singhal,<br>Sharad; Schultze, Joachim L.","abstract_summary":" Research is increasingly becoming<br>data-driven, and natural sciences are not an exception. In<br>both biology and medicine, we are observing an<br>exponential growth of structured data collections from<br>experiments and population studies, enabling us to gain<br>novel insights that would otherwise not be possible.<br>However, these growing data sets pose a challenge for<br>existing compute infrastructures since data is<br>outgrowing limits within compute. In this work, we present<br>the application of a novel approach,<br>Memory-Driven Computing (MDC), in the life sciences. MDC<br>proposes a data-centric approach that has been designed<br>for growing data sizes and provides a composable<br>infrastructure for...","title_summary":" Scaling Genomics Data Processing with<br>Memory-Driven Computing to Accelerate Computational<br>Biology","x":-26.6259937286,"y":39.8118400574,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6259937286,"tsne_y":39.8118400574,"subcluster":6,"subcluster_description":"Genomics Data Processing","shape":"p"},{"cord_uid":"m00rsjqd","source_x":"PMC","title":"TeaMPI\u2014Replication-Based Resilience Without the (Performance) Pain","doi":"10.1007\/978-3-030-50743-5_23","abstract":"In an era where we can not afford to checkpoint frequently, replication is a generic way forward to construct numerical simulations that can continue to run even if hardware parts fail. Yet, replication often is not employed on larger scales, as na\u00efvely mirroring a computation once effectively halves the machine size, and as keeping replicated simulations consistent with each other is not trivial. We demonstrate for the ExaHyPE engine\u2014a task-based solver for hyperbolic equation systems\u2014that it is possible to realise resiliency without major code changes on the user side, while we introduce a novel algorithmic idea where replication reduces the time-to-solution. The redundant CPU cycles are not burned \u201cfor nothing\u201d. Our work employs a weakly consistent data model where replicas run independently yet inform each other through heartbeat messages whether they are still up and running. Our key performance idea is to let the tasks of the replicated simulations share some of their outcomes, while we shuffle the actual task execution order per replica. This way, replicated ranks can skip some local computations and automatically start to synchronise with each other. Our experiments with a production-level seismic wave-equation solver provide evidence that this novel concept has the potential to make replication affordable for large-scale simulations in high-performance computing.","publish_time":1590105600000,"author_summary":" Samfass, Philipp; Weinzierl, Tobias;<br>Hazelwood, Benjamin; Bader, Michael","abstract_summary":" In an era where we can not afford to checkpoint<br>frequently, replication is a generic way forward to<br>construct numerical simulations that can continue to run<br>even if hardware parts fail. Yet, replication often<br>is not employed on larger scales, as na\u00efvely<br>mirroring a computation once effectively halves the<br>machine size, and as keeping replicated simulations<br>consistent with each other is not trivial. We demonstrate<br>for the ExaHyPE engine\u2014a task-based solver for<br>hyperbolic equation systems\u2014that it is possible to<br>realise resiliency without major code changes on the<br>user side, while we introduce a novel algorithmic<br>idea where replication reduces the...","title_summary":" TeaMPI\u2014Replication-Based Resilience<br>Without the (Performance) Pain","x":-26.266122818,"y":39.4611930847,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.266122818,"tsne_y":39.4611930847,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"6vjg386e","source_x":"PMC","title":"HyPar-Flow: Exploiting MPI and Keras for Scalable Hybrid-Parallel DNN Training with TensorFlow","doi":"10.1007\/978-3-030-50743-5_5","abstract":"To reduce the training time of large-scale Deep Neural Networks (DNNs), Deep Learning (DL) scientists have started to explore parallelization strategies like data-parallelism, model-parallelism, and hybrid-parallelism. While data-parallelism has been extensively studied and developed, several problems exist in realizing model-parallelism and hybrid-parallelism efficiently. Four major problems we focus on are: 1) defining a notion of a distributed model across processes, 2) implementing forward\/back-propagation across process boundaries that requires explicit communication, 3) obtaining parallel speedup on an inherently sequential task, and 4) achieving scalability without losing out on a model\u2019s accuracy. To address these problems, we create HyPar-Flow\u2014a model-size and model-type agnostic, scalable, practical, and user-transparent system for hybrid-parallel training by exploiting MPI, Keras, and TensorFlow. HyPar-Flow provides a single API that can be used to perform data, model, and hybrid parallel training of any Keras model at scale. We create an internal distributed representation of the user-provided Keras model, utilize TF\u2019s Eager execution features for distributed forward\/back-propagation across processes, exploit pipelining to improve performance and leverage efficient MPI primitives for scalable communication. Between model partitions, we use send and recv to exchange layer-data\/partial-errors while allreduce is used to accumulate\/average gradients across model replicas. Beyond the design and implementation of HyPar-Flow, we also provide comprehensive correctness and performance results on three state-of-the-art HPC systems including TACC Frontera (#5 on Top500.org). For ResNet-1001, an ultra-deep model, HyPar-Flow provides: 1) Up to 1.6[Formula: see text] speedup over Horovod-based data-parallel training, 2) 110[Formula: see text] speedup over single-node on 128 Stampede2 nodes, and 3) 481[Formula: see text] speedup over single-node on 512 Frontera nodes.","publish_time":1590105600000,"author_summary":" Awan, Ammar Ahmad; Jain, Arpan; Anthony,<br>Quentin; Subramoni, Hari; Panda, Dhabaleswar K.","abstract_summary":" To reduce the training time of large-scale Deep<br>Neural Networks (DNNs), Deep Learning (DL)<br>scientists have started to explore parallelization<br>strategies like data-parallelism, model-parallelism,<br>and hybrid-parallelism. While data-parallelism<br>has been extensively studied and developed,<br>several problems exist in realizing<br>model-parallelism and hybrid-parallelism efficiently. Four<br>major problems we focus on are: 1) defining a notion of<br>a distributed model across processes, 2)<br>implementing forward\/back-propagation across process<br>boundaries that requires explicit communication, 3)<br>obtaining parallel speedup on an inherently sequential<br>task, and 4) achieving scalability without losing<br>out on a model\u2019s accuracy. To address these<br>problems, we create HyPar-Flow\u2014a model-size and<br>model-type...","title_summary":" HyPar-Flow: Exploiting MPI and Keras for<br>Scalable Hybrid-Parallel DNN Training with TensorFlow","x":-26.2090034485,"y":39.8397903442,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.2090034485,"tsne_y":39.8397903442,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"naj37e0m","source_x":"PMC","title":"Enabling Execution of a Legacy CFD Mini Application on Accelerators Using OpenMP","doi":"10.1007\/978-3-030-50743-5_14","abstract":"We describe the process and outcome of our efforts to port a legacy Fortran benchmark code to heterogeneous GPU-accelerated computing architectures using OpenMP. The benchmark code is one of the multi-zone NAS Parallel Benchmarks (NPB-MZ) called SP-MZ. This \u201cmini-app\u201d mimics the computation and data movement that is found in popular legacy and modern implicit computational fluid dynamics (CFD) solvers. Our objective was to examine how efficiently legacy Fortran codes can be ported to accelerators by leveraging OpenMP directives. We describe the development and optimization process and demonstrate the performance impact of various code modifications. We show select profiling results from the NVIDIA Visual Profiler (nvpp) to help others diagnose and overcome performance issues in their own applications. We present results for two compute systems endowed with NVIDIA V100 accelerators.","publish_time":1590105600000,"author_summary":" Nompelis, Ioannis; Jost, Gabriele; Koniges,<br>Alice; Daley, Christopher; Eder, David; Stone,<br>Christopher","abstract_summary":" We describe the process and outcome of our<br>efforts to port a legacy Fortran benchmark code to<br>heterogeneous GPU-accelerated computing architectures<br>using OpenMP. The benchmark code is one of the<br>multi-zone NAS Parallel Benchmarks (NPB-MZ) called<br>SP-MZ. This \u201cmini-app\u201d mimics the computation and<br>data movement that is found in popular legacy and<br>modern implicit computational fluid dynamics (CFD)<br>solvers. Our objective was to examine how efficiently<br>legacy Fortran codes can be ported to accelerators by<br>leveraging OpenMP directives. We describe the<br>development and optimization process and demonstrate the<br>performance impact of various code modifications. We show<br>select profiling results from...","title_summary":" Enabling Execution of a Legacy CFD Mini<br>Application on Accelerators Using OpenMP","x":-26.5170097351,"y":40.2819480896,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5170097351,"tsne_y":40.2819480896,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"80n3bg5x","source_x":"PMC","title":"Communication-Aware Hardware-Assisted MPI Overlap Engine","doi":"10.1007\/978-3-030-50743-5_26","abstract":"Overlap of computation and communication is critical for good application-level performance. Modern high-performance networks offer Hardware-assisted tag matching and rendezvous offload to enable communication progress without involving the host CPU. However, hardware based offload cannot be used in many situations due to various hardware limitations and performance issues. Furthermore, hardware-based designs cannot provide good overlap for common communication patterns involving unexpected messages or non-contiguous datatypes. In this paper, we address these limitations by designing a communication-aware overlap engine for MPI that uses novel hardware-assisted and software-based solutions to extract overlap for both expected and unexpected messages. The proposed design adapts to the application\u2019s communication requirements including message size, datatype, and relative timing of processes using heuristics and history-driven predictions. We evaluate the proposed designs against state-of-the-art MPI libraries and show up to 41% and 22% reduction in latency for collective operations and stencil-based application kernels on 1024 and 128 nodes, respectively, as well as 23% improvement in communication performance of the P3DFFT application.","publish_time":1590105600000,"author_summary":" Bayatpour, Mohammadreza; Hashmi Maqbool,<br>Jahanzeb; Chakraborty, Sourav; Kandadi Suresh,<br>Kaushik; Ghazimirsaeed, Seyedeh Mahdieh; Ramesh,<br>Bharath; Subramoni, Hari; Panda, Dhabaleswar K.","abstract_summary":" Overlap of computation and communication is<br>critical for good application-level performance.<br>Modern high-performance networks offer<br>Hardware-assisted tag matching and rendezvous offload to enable<br>communication progress without involving the host CPU.<br>However, hardware based offload cannot be used in many<br>situations due to various hardware limitations and<br>performance issues. Furthermore, hardware-based designs<br>cannot provide good overlap for common communication<br>patterns involving unexpected messages or<br>non-contiguous datatypes. In this paper, we address these<br>limitations by designing a communication-aware overlap<br>engine for MPI that uses novel hardware-assisted and<br>software-based solutions to extract overlap for both expected<br>and unexpected messages. The proposed design<br>adapts...","title_summary":" Communication-Aware Hardware-Assisted MPI<br>Overlap Engine","x":-26.685213089,"y":40.2383613586,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.685213089,"tsne_y":40.2383613586,"subcluster":8,"subcluster_description":"Hardware-Assisted Mpi Overlap Enginesimplifying","shape":"p"},{"cord_uid":"z71qanyv","source_x":"PMC","title":"Using High-Level Synthesis to Implement the Matrix-Vector Multiplication on FPGA","doi":"10.1007\/978-3-030-50743-5_13","abstract":"This work presents how to implement the Matrix-Vector Multiplication (MVM) onto FPGA through the QuickPlay High-Level Synthesis flow. The motivations arise from the Adaptive Optics field, where the MVM is the core of the real-time control algorithm which controls the mirrors of a telescope to compensate for the effects of the atmospheric turbulence. The proposed implementation of the MVM exploits four different levels of parallelism: spatial and pipeline parallelism are used both at the fine (scalar instructions) and at the coarse (vector instructions) levels. To characterize the architecture being developed, a performance model has been developed and validated through the actual results obtained from runs on a prototype board based on the Intel ARRIA10 FPGA. Some details are given to describe how the algorithm has been implemented using the QuickPlay HLS flow. Performance results are presented, in terms of sustained computational speed and resources used in the hardware implementation.","publish_time":1590105600000,"author_summary":" Marongiu, Alessandro; Palazzari, Paolo","abstract_summary":" This work presents how to implement the<br>Matrix-Vector Multiplication (MVM) onto FPGA through the<br>QuickPlay High-Level Synthesis flow. The motivations<br>arise from the Adaptive Optics field, where the MVM is<br>the core of the real-time control algorithm which<br>controls the mirrors of a telescope to compensate for the<br>effects of the atmospheric turbulence. The proposed<br>implementation of the MVM exploits four different levels of<br>parallelism: spatial and pipeline parallelism are used both<br>at the fine (scalar instructions) and at the<br>coarse (vector instructions) levels. To<br>characterize the architecture being developed, a<br>performance model has been developed and validated through<br>the...","title_summary":" Using High-Level Synthesis to Implement the<br>Matrix-Vector Multiplication on FPGA","x":-26.0650196075,"y":40.3985137939,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.0650196075,"tsne_y":40.3985137939,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"823wtl8i","source_x":"PMC","title":"Running a Pre-exascale, Geographically Distributed, Multi-cloud Scientific Simulation","doi":"10.1007\/978-3-030-50743-5_2","abstract":"As we approach the Exascale era, it is important to verify that the existing frameworks and tools will still work at that scale. Moreover, public Cloud computing has been emerging as a viable solution for both prototyping and urgent computing. Using the elasticity of the Cloud, we have thus put in place a pre-exascale HTCondor setup for running a scientific simulation in the Cloud, with the chosen application being IceCube\u2019s photon propagation simulation. I.e. this was not a purely demonstration run, but it was also used to produce valuable and much needed scientific results for the IceCube collaboration. In order to reach the desired scale, we aggregated GPU resources across 8 GPU models from many geographic regions across Amazon Web Services, Microsoft Azure, and the Google Cloud Platform. Using this setup, we reached a peak of over 51k GPUs corresponding to almost 380 PFLOP32s, for a total integrated compute of about 100k GPU hours. In this paper we provide the description of the setup, the problems that were discovered and overcome, as well as a short description of the actual science output of the exercise.","publish_time":1590105600000,"author_summary":" Sfiligoi, Igor; W\u00fcrthwein, Frank; Riedel,<br>Benedikt; Schultz, David","abstract_summary":" As we approach the Exascale era, it is important<br>to verify that the existing frameworks and tools<br>will still work at that scale. Moreover, public<br>Cloud computing has been emerging as a viable<br>solution for both prototyping and urgent computing.<br>Using the elasticity of the Cloud, we have thus put in<br>place a pre-exascale HTCondor setup for running a<br>scientific simulation in the Cloud, with the chosen<br>application being IceCube\u2019s photon propagation<br>simulation. I.e. this was not a purely demonstration run,<br>but it was also used to produce valuable and much<br>needed scientific results for the IceCube<br>collaboration. In order...","title_summary":" Running a Pre-exascale, Geographically<br>Distributed, Multi-cloud Scientific Simulation","x":-26.6203479767,"y":39.9698791504,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6203479767,"tsne_y":39.9698791504,"subcluster":6,"subcluster_description":"Genomics Data Processing","shape":"p"},{"cord_uid":"gkptv4xo","source_x":"PMC","title":"Semi-automatic Assessment of I\/O Behavior by Inspecting the Individual Client-Node Timelines\u2014An Explorative Study on [Formula: see text] Jobs","doi":"10.1007\/978-3-030-50743-5_9","abstract":"HPC applications with suboptimal I\/O behavior interfere with well-behaving applications and lead to increased application runtime. In some cases, this may even lead to unresponsive systems and unfinished jobs. HPC monitoring systems can aid users and support staff to identify problematic behavior and support optimization of problematic applications. The key issue is how to identify relevant applications? A profile of an application doesn\u2019t allow identifying problematic phases during the execution but tracing of each individual I\/O is too invasive. In this work, we split the execution into segments, i.e., windows of fixed size and analyze profiles of them. We develop three I\/O metrics to identify three relevant classes of inefficient I\/O behaviors, and evaluate them on raw data of 1,000,000 jobs on the supercomputer Mistral. The advantages of our method is that temporal information about I\/O activities during job runtime is preserved to some extent and can be used to identify phases of inefficient I\/O. The main contribution of this work is the segmentation of time series and computation of metrics (Job-I\/O-Utilization, Job-I\/O-Problem-Time, and Job-I\/O-Balance) that are effective to identify problematic I\/O phases and jobs.","publish_time":1590105600000,"author_summary":" Betke, Eugen; Kunkel, Julian","abstract_summary":" HPC applications with suboptimal I\/O behavior<br>interfere with well-behaving applications and lead to<br>increased application runtime. In some cases, this may<br>even lead to unresponsive systems and unfinished<br>jobs. HPC monitoring systems can aid users and<br>support staff to identify problematic behavior and<br>support optimization of problematic applications.<br>The key issue is how to identify relevant<br>applications? A profile of an application doesn\u2019t allow<br>identifying problematic phases during the execution but<br>tracing of each individual I\/O is too invasive. In this<br>work, we split the execution into segments, i.e.,<br>windows of fixed size and analyze profiles of them. We<br>develop...","title_summary":" Semi-automatic Assessment of I\/O Behavior by<br>Inspecting the Individual Client-Node Timelines\u2014An<br>Explorative Study on [Formula: see text] Jobs","x":-27.1342773438,"y":40.6589012146,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.1342773438,"tsne_y":40.6589012146,"subcluster":5,"subcluster_description":"Tizen Operating Systemsemi-Automatic Assessment","shape":"p"},{"cord_uid":"sgofnocp","source_x":"PMC","title":"Sparse Linear Algebra on AMD and NVIDIA GPUs \u2013 The Race Is On","doi":"10.1007\/978-3-030-50743-5_16","abstract":"Efficiently processing sparse matrices is a central and performance-critical part of many scientific simulation codes. Recognizing the adoption of manycore accelerators in HPC, we evaluate in this paper the performance of the currently best sparse matrix-vector product (SpMV) implementations on high-end GPUs from AMD and NVIDIA. Specifically, we optimize SpMV kernels for the CSR, COO, ELL, and HYB format taking the hardware characteristics of the latest GPU technologies into account. We compare for 2,800 test matrices the performance of our kernels against AMD\u2019s hipSPARSE library and NVIDIA\u2019s cuSPARSE library, and ultimately assess how the GPU technologies from AMD and NVIDIA compare in terms of SpMV performance.","publish_time":1590105600000,"author_summary":" Tsai, Yuhsiang M.; Cojean, Terry; Anzt,<br>Hartwig","abstract_summary":" Efficiently processing sparse matrices is a<br>central and performance-critical part of many<br>scientific simulation codes. Recognizing the adoption of<br>manycore accelerators in HPC, we evaluate in this paper<br>the performance of the currently best sparse<br>matrix-vector product (SpMV) implementations on high-end<br>GPUs from AMD and NVIDIA. Specifically, we optimize<br>SpMV kernels for the CSR, COO, ELL, and HYB format<br>taking the hardware characteristics of the latest GPU<br>technologies into account. We compare for 2,800 test<br>matrices the performance of our kernels against AMD\u2019s<br>hipSPARSE library and NVIDIA\u2019s cuSPARSE library, and<br>ultimately assess how the GPU technologies from AMD and<br>NVIDIA...","title_summary":" Sparse Linear Algebra on AMD and NVIDIA GPUs \u2013<br>The Race Is On","x":-26.2801876068,"y":40.280166626,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.2801876068,"tsne_y":40.280166626,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"3pe4sj3k","source_x":"PMC","title":"Footprint-Aware Power Capping for Hybrid Memory Based Systems","doi":"10.1007\/978-3-030-50743-5_18","abstract":"High Performance Computing (HPC) systems are facing severe limitations in both power and memory bandwidth\/capacity. By now, these limitations have been addressed individually: to improve performance under a strict power constraint, power capping, which sets power limits to components\/nodes\/jobs, is an indispensable feature; and for memory bandwidth\/capacity increase, the industry has begun to support hybrid main memory designs that comprise multiple different technologies including emerging memories (e.g., 3D stacked DRAM or Non-Volatile RAM) in one compute node. However, few works look at the combination of both trends. This paper explicitly targets power managements on hybrid memory based HPC systems and is based on the following observation: in spite of the system software\u2019s efforts to optimize data allocations on such a system, the effective memory bandwidth can decrease considerably when we scale the problem size of applications. As a result, the performance bottleneck component changes in accordance with the footprint (or data) size, which then also changes the optimal power cap settings in a node. Motivated by this observation, we propose a power management concept called [Image: see text] and a profile-driven software framework to realize it. Our experimental result on a real system using HPC benchmarks shows that our approach is successful in correctly setting power caps depending on the footprint size while keeping around 93\/96% of performance\/power-efficiency compared to the best settings.","publish_time":1590105600000,"author_summary":" Arima, Eishi; Hanawa, Toshihiro; Trinitis,<br>Carsten; Schulz, Martin","abstract_summary":" High Performance Computing (HPC) systems are<br>facing severe limitations in both power and memory<br>bandwidth\/capacity. By now, these limitations have been addressed<br>individually: to improve performance under a strict power<br>constraint, power capping, which sets power limits to<br>components\/nodes\/jobs, is an indispensable feature; and for memory<br>bandwidth\/capacity increase, the industry has begun to support<br>hybrid main memory designs that comprise multiple<br>different technologies including emerging memories<br>(e.g., 3D stacked DRAM or Non-Volatile RAM) in one<br>compute node. However, few works look at the<br>combination of both trends. This paper explicitly targets<br>power managements on hybrid memory based HPC systems<br>and...","title_summary":" Footprint-Aware Power Capping for Hybrid<br>Memory Based Systems","x":-26.7248458862,"y":40.1313972473,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7248458862,"tsne_y":40.1313972473,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"94qph5xa","source_x":"PMC","title":"Simplifying Communication Overlap in OpenSHMEM Through Integrated User-Level Thread Scheduling","doi":"10.1007\/978-3-030-50743-5_25","abstract":"Overlap of communication with computation is a key optimization for high performance computing (HPC) applications. In this paper, we explore the usage of user-level threading to enable productive and efficient communication overlap and pipelining. We extend OpenSHMEM with integrated user-level thread scheduling, enabling applications to leverage fine-grain threading as an alternative to non-blocking communication. Our solution introduces communication-aware thread scheduling that utilizes the communication state of threads to minimize context switching overheads. We identify several patterns common to multi-threaded OpenSHMEM applications, leverage user-level threads to increase overlap of communication and computation, and explore the impact of different thread scheduling policies. Results indicate that user-level threading can enable blocking communication to meet the performance of highly-optimized, non-blocking, single-threaded codes with significantly lower application-level complexity. In one case, we observe a 28.7% performance improvement for the Smith-Waterman DNA sequence alignment benchmark.","publish_time":1590105600000,"author_summary":" Wasi-ur- Rahman, Md.; Ozog, David; Dinan,<br>James","abstract_summary":" Overlap of communication with computation is a<br>key optimization for high performance computing<br>(HPC) applications. In this paper, we explore the<br>usage of user-level threading to enable productive<br>and efficient communication overlap and<br>pipelining. We extend OpenSHMEM with integrated<br>user-level thread scheduling, enabling applications to<br>leverage fine-grain threading as an alternative to<br>non-blocking communication. Our solution introduces<br>communication-aware thread scheduling that utilizes the<br>communication state of threads to minimize context switching<br>overheads. We identify several patterns common to<br>multi-threaded OpenSHMEM applications, leverage user-level<br>threads to increase overlap of communication and<br>computation, and explore the impact of different thread<br>scheduling policies....","title_summary":" Simplifying Communication Overlap in<br>OpenSHMEM Through Integrated User-Level Thread<br>Scheduling","x":-26.6916065216,"y":40.2312393188,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6916065216,"tsne_y":40.2312393188,"subcluster":8,"subcluster_description":"Hardware-Assisted Mpi Overlap Enginesimplifying","shape":"p"},{"cord_uid":"pgkgfrwx","source_x":"PMC","title":"Desynchronization and Wave Pattern Formation in MPI-Parallel and Hybrid Memory-Bound Programs","doi":"10.1007\/978-3-030-50743-5_20","abstract":"Analytic, first-principles performance modeling of distributed-memory parallel codes is notoriously imprecise. Even for applications with extremely regular and homogeneous compute-communicate phases, simply adding communication time to computation time does often not yield a satisfactory prediction of parallel runtime due to deviations from the expected simple lockstep pattern caused by system noise, variations in communication time, and inherent load imbalance. In this paper, we highlight the specific cases of provoked and spontaneous desynchronization of memory-bound, bulk-synchronous pure MPI and hybrid MPI+OpenMP programs. Using simple microbenchmarks we observe that although desynchronization can introduce increased waiting time per process, it does not necessarily cause lower resource utilization but can lead to an increase in available bandwidth per core. In case of significant communication overhead, even natural noise can shove the system into a state of automatic overlap of communication and computation, improving the overall time to solution. The saturation point, i.e., the number of processes per memory domain required to achieve full memory bandwidth, is pivotal in the dynamics of this process and the emerging stable wave pattern. We also demonstrate how hybrid MPI-OpenMP programming can prevent desirable desynchronization by eliminating the bandwidth bottleneck among processes. A Chebyshev filter diagonalization application is used to demonstrate some of the observed effects in a realistic setting.","publish_time":1590105600000,"author_summary":" Afzal, Ayesha; Hager, Georg; Wellein, Gerhard","abstract_summary":" Analytic, first-principles performance<br>modeling of distributed-memory parallel codes is<br>notoriously imprecise. Even for applications with<br>extremely regular and homogeneous compute-communicate<br>phases, simply adding communication time to<br>computation time does often not yield a satisfactory<br>prediction of parallel runtime due to deviations from the<br>expected simple lockstep pattern caused by system<br>noise, variations in communication time, and<br>inherent load imbalance. In this paper, we highlight the<br>specific cases of provoked and spontaneous<br>desynchronization of memory-bound, bulk-synchronous pure MPI<br>and hybrid MPI+OpenMP programs. Using simple<br>microbenchmarks we observe that although desynchronization<br>can introduce increased waiting time per process,<br>it does not necessarily...","title_summary":" Desynchronization and Wave Pattern Formation<br>in MPI-Parallel and Hybrid Memory-Bound<br>Programs","x":-26.5260429382,"y":40.1755599976,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5260429382,"tsne_y":40.1755599976,"subcluster":9,"subcluster_description":"Accelerated Architecturesutilizing Gpu Performance","shape":"p"},{"cord_uid":"e98p99b4","source_x":"PMC","title":"Reinit[Formula: see text]: Evaluating the Performance of Global-Restart Recovery Methods for MPI Fault Tolerance","doi":"10.1007\/978-3-030-50743-5_27","abstract":"Scaling supercomputers comes with an increase in failure rates due to the increasing number of hardware components. In standard practice, applications are made resilient through checkpointing data and restarting execution after a failure occurs to resume from the latest checkpoint. However, re-deploying an application incurs overhead by tearing down and re-instating execution, and possibly limiting checkpointing retrieval from slow permanent storage. In this paper we present Reinit[Formula: see text], a new design and implementation of the Reinit approach for global-restart recovery, which avoids application re-deployment. We extensively evaluate Reinit[Formula: see text] contrasted with the leading MPI fault-tolerance approach of ULFM, implementing global-restart recovery, and the typical practice of restarting an application to derive new insight on performance. Experimentation with three different HPC proxy applications made resilient to withstand process and node failures shows that Reinit[Formula: see text] recovers much faster than restarting, up to 6[Formula: see text], or ULFM, up to 3[Formula: see text], and that it scales excellently as the number of MPI processes grows.","publish_time":1590105600000,"author_summary":" Georgakoudis, Giorgis; Guo, Luanzheng;<br>Laguna, Ignacio","abstract_summary":" Scaling supercomputers comes with an increase<br>in failure rates due to the increasing number of<br>hardware components. In standard practice,<br>applications are made resilient through checkpointing data<br>and restarting execution after a failure occurs to<br>resume from the latest checkpoint. However,<br>re-deploying an application incurs overhead by tearing down<br>and re-instating execution, and possibly<br>limiting checkpointing retrieval from slow permanent<br>storage. In this paper we present Reinit[Formula: see<br>text], a new design and implementation of the Reinit<br>approach for global-restart recovery, which avoids<br>application re-deployment. We extensively evaluate<br>Reinit[Formula: see text] contrasted with the leading MPI<br>fault-tolerance approach of ULFM,...","title_summary":" Reinit[Formula: see text]: Evaluating the<br>Performance of Global-Restart Recovery Methods for MPI<br>Fault Tolerance","x":-27.0442028046,"y":40.664024353,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.0442028046,"tsne_y":40.664024353,"subcluster":5,"subcluster_description":"Tizen Operating Systemsemi-Automatic Assessment","shape":"p"},{"cord_uid":"npj5k4xc","source_x":"PMC","title":"Timemory: Modular Performance Analysis for HPC","doi":"10.1007\/978-3-030-50743-5_22","abstract":"HPC has undergone a significant transition toward heterogeneous architectures. This transition has introduced several issues in code migration to support multiple frameworks for targeting the various architectures. In order to cope with these challenges, projects such as Kokkos and LLVM create abstractions which map a generic front-end API to the backend that supports the targeted architecture. This paper presents a complementary framework for performance measurement and analysis. Several performance measurement and analysis tools in existence provide their capabilities through various methods but the common theme among these tools are prohibitive limitations in terms of user-level extensions. For this reason, software developers commonly have to learn multiple tools and valuable analysis methods, such as the roofline model, are frequently required to be generated manually. The timemory framework provides complete modularity for performance measurement and analysis and eliminates all restrictions on user-level extensions. The timemory framework also provides a highly-efficient and intuitive method for handling multiple tools\/measurements (i.e., \u201ccomponents\u201d) concurrently. The intersection of these characteristics provide ample evidence that timemory can serve as the common interface for existing performance measurement and analysis tools. Timemory components are developed in C++ but includes multi-language support for C, Fortran, and Python codes. Numerous components are provided by the library itself \u2013 including, but not limited to, timers, memory usage, hardware counters, and FLOP and instruction roofline models. Additionally, analysis of the intrinsic overhead demonstrates superior performance in comparison with popular tools.","publish_time":1590105600000,"author_summary":" Madsen, Jonathan R.; Awan, Muaaz G.; Brunie,<br>Hugo; Deslippe, Jack; Gayatri, Rahul; Oliker,<br>Leonid; Wang, Yunsong; Yang, Charlene; Williams,<br>Samuel","abstract_summary":" HPC has undergone a significant transition<br>toward heterogeneous architectures. This<br>transition has introduced several issues in code<br>migration to support multiple frameworks for targeting<br>the various architectures. In order to cope with<br>these challenges, projects such as Kokkos and LLVM<br>create abstractions which map a generic front-end API<br>to the backend that supports the targeted<br>architecture. This paper presents a complementary framework<br>for performance measurement and analysis.<br>Several performance measurement and analysis tools in<br>existence provide their capabilities through various<br>methods but the common theme among these tools are<br>prohibitive limitations in terms of user-level<br>extensions. For this reason, software...","title_summary":" Timemory: Modular Performance Analysis for<br>HPC","x":-26.809009552,"y":40.3847961426,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.809009552,"tsne_y":40.3847961426,"subcluster":7,"subcluster_description":"Ap-Socsaccelerating Real-Time Applications","shape":"p"},{"cord_uid":"42ludmqd","source_x":"PMC","title":"Basic Pattern Graphs for the Efficient Computation of Its Number of Independent Sets","doi":"10.1007\/978-3-030-49076-8_6","abstract":"The problem of counting the number of independent sets of a graph G (denoted as i(G)) is a classic #P-complete problem. We present some patterns on graphs that allows us the polynomial computation of i(G). For example, we show that for a graph G where its set of cycles can be arranged as embedded cycles, i(G) can be computed in polynomial time. Particularly, our proposal counts independent sets on outerplanar graphs.","publish_time":1588118400000,"author_summary":" De Ita, Guillermo; Rodr\u00edguez, Miguel; Bello,<br>Pedro; Contreras, Meliza","abstract_summary":" The problem of counting the number of<br>independent sets of a graph G (denoted as i(G)) is a classic<br>#P-complete problem. We present some patterns on graphs<br>that allows us the polynomial computation of i(G).<br>For example, we show that for a graph G where its set<br>of cycles can be arranged as embedded cycles, i(G)<br>can be computed in polynomial time. Particularly,<br>our proposal counts independent sets on<br>outerplanar graphs.","title_summary":" Basic Pattern Graphs for the Efficient<br>Computation of Its Number of Independent Sets","x":-22.4487457275,"y":44.2600898743,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4487457275,"tsne_y":44.2600898743,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"y058avde","source_x":"PMC","title":"Enabling Hardware Affinity in JVM-Based Applications: A Case Study for Big Data","doi":"10.1007\/978-3-030-50371-0_3","abstract":"Java has been the backbone of Big Data processing for more than a decade due to its interesting features such as object orientation, cross-platform portability and good programming productivity. In fact, most popular Big Data frameworks such as Hadoop and Spark are implemented in Java or using other languages designed to run on the Java Virtual Machine (JVM) such as Scala. However, modern computing hardware is increasingly complex, featuring multiple processing cores aggregated into one or more CPUs that are usually organized as a Non-Uniform Memory Access (NUMA) architecture. The platform-independent features of the JVM come at the cost of hardware abstraction, which makes it more difficult for Big Data developers to take advantage of hardware-aware optimizations based on managing CPU or NUMA affinities. In this paper we introduce jhwloc, a Java library for easily managing such affinities in JVM-based applications and gathering information about the underlying hardware topology. To demonstrate the functionality and benefits of our proposal, we have extended Flame-MR, our Java-based MapReduce framework, to provide support for setting CPU affinities through jhwloc. The experimental evaluation using representative Big Data workloads has shown that performance can be improved by up to 17% when efficiently exploiting the hardware. jhwloc is publicly available to download at https:\/\/github.com\/rreye\/jhwloc.","publish_time":1590451200000,"author_summary":" Exp\u00f3sito, Roberto R.; Veiga, Jorge; Touri\u00f1o,<br>Juan","abstract_summary":" Java has been the backbone of Big Data<br>processing for more than a decade due to its interesting<br>features such as object orientation, cross-platform<br>portability and good programming productivity. In fact,<br>most popular Big Data frameworks such as Hadoop and<br>Spark are implemented in Java or using other<br>languages designed to run on the Java Virtual Machine<br>(JVM) such as Scala. However, modern computing<br>hardware is increasingly complex, featuring multiple<br>processing cores aggregated into one or more CPUs that are<br>usually organized as a Non-Uniform Memory Access<br>(NUMA) architecture. The platform-independent<br>features of the JVM come at the cost of...","title_summary":" Enabling Hardware Affinity in JVM-Based<br>Applications: A Case Study for Big Data","x":-26.8628883362,"y":40.4334907532,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.8628883362,"tsne_y":40.4334907532,"subcluster":7,"subcluster_description":"Ap-Socsaccelerating Real-Time Applications","shape":"p"},{"cord_uid":"7osk5asr","source_x":"PMC","title":"An Optimizing Multi-platform Source-to-source Compiler Framework for the NEURON MODeling Language","doi":"10.1007\/978-3-030-50371-0_4","abstract":"Domain-specific languages (DSLs) play an increasingly important role in the generation of high performing software. They allow the user to exploit domain knowledge for the generation of more efficient code on target architectures. Here, we describe a new code generation framework (NMODL) for an existing DSL in the NEURON framework, a widely used software for massively parallel simulation of biophysically detailed brain tissue models. Existing NMODL DSL transpilers lack either essential features to generate optimized code or capability to parse the diversity of existing models in the user community. Our NMODL framework has been tested against a large number of previously published user models and offers high-level domain-specific optimizations and symbolic algebraic simplifications before target code generation. NMODL implements multiple SIMD and SPMD targets optimized for modern hardware. When comparing NMODL-generated kernels with NEURON we observe a speedup of up to 20[Formula: see text], resulting in overall speedups of two different production simulations by [Formula: see text]. When compared to SIMD optimized kernels that heavily relied on auto-vectorization by the compiler still a speedup of up to [Formula: see text] is observed.","publish_time":1590451200000,"author_summary":" Kumbhar, Pramod; Awile, Omar; Keegan, Liam;<br>Alonso, Jorge Blanco; King, James; Hines, Michael;<br>Sch\u00fcrmann, Felix","abstract_summary":" Domain-specific languages (DSLs) play an<br>increasingly important role in the generation of high<br>performing software. They allow the user to exploit domain<br>knowledge for the generation of more efficient code on<br>target architectures. Here, we describe a new code<br>generation framework (NMODL) for an existing DSL in the<br>NEURON framework, a widely used software for<br>massively parallel simulation of biophysically<br>detailed brain tissue models. Existing NMODL DSL<br>transpilers lack either essential features to generate<br>optimized code or capability to parse the diversity of<br>existing models in the user community. Our NMODL<br>framework has been tested against a large number of...","title_summary":" An Optimizing Multi-platform<br>Source-to-source Compiler Framework for the NEURON MODeling<br>Language","x":-26.5510368347,"y":40.5603599548,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5510368347,"tsne_y":40.5603599548,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"c9xka28x","source_x":"PMC","title":"Enabling EASEY Deployment of Containerized Applications for Future HPC Systems","doi":"10.1007\/978-3-030-50371-0_15","abstract":"The upcoming exascale era will push the changes in computing architecture from classical CPU-based systems towards hybrid GPU-heavy systems with much higher levels of complexity. While such clusters are expected to improve the performance of certain optimized HPC applications, it will also increase the difficulties for those users who have yet to adapt their codes or are starting from scratch with new programming paradigms. Since there are still no comprehensive automatic assistance mechanisms to enhance application performance on such systems, we propose a support framework for future HPC architectures, called EASEY (Enable exASclae for EverYone). Our solution builds on a layered software architecture, which offers different mechanisms on each layer for different tasks of tuning, including a workflow management system. This enables users to adjust the parameters on each of the layers, thereby enhancing specific characteristics of their codes. We introduce the framework with a Charliecloud-based solution, showcasing the LULESH benchmark on the upper layers of our framework. Our approach can automatically deploy optimized container computations with negligible overhead and at the same time reduce the time a scientist needs to spent on manual job submission configurations.","publish_time":1590451200000,"author_summary":" H\u00f6b, Maximilian; Kranzlm\u00fcller, Dieter","abstract_summary":" The upcoming exascale era will push the changes<br>in computing architecture from classical<br>CPU-based systems towards hybrid GPU-heavy systems with<br>much higher levels of complexity. While such<br>clusters are expected to improve the performance of<br>certain optimized HPC applications, it will also<br>increase the difficulties for those users who have yet to<br>adapt their codes or are starting from scratch with<br>new programming paradigms. Since there are still<br>no comprehensive automatic assistance<br>mechanisms to enhance application performance on such<br>systems, we propose a support framework for future HPC<br>architectures, called EASEY (Enable exASclae for EverYone).<br>Our solution builds on a...","title_summary":" Enabling EASEY Deployment of Containerized<br>Applications for Future HPC Systems","x":-26.7815570831,"y":40.0190010071,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7815570831,"tsne_y":40.0190010071,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"3ddzsnei","source_x":"PMC","title":"From Conditional Independence to Parallel Execution in Hierarchical Models","doi":"10.1007\/978-3-030-50371-0_12","abstract":"Hierarchical models describe phenomena by grouping data into multiple levels. Due to the size of these models, parallel execution is required to avoid prohibitively long computing time. While it is occasionally possible to specify some of these models using parallel building blocks, this limits expressivity. Therefore, a more general generative specification is preferred. To leverage parallel computing capacity, these specifications can be annotated, but doing so effectively assumes that the modeler has expertise from computer science. This paper outlines how to identify parallel parts automatically by leveraging the conditional independence property in the graphical model extracted from the dataflow graph of model specifications. Computation related to random variables with the same depth in the graphical model are identified as candidates for parallel execution. Since subsequent proposals in the parameter space exploration of the model are clustered together, the results show that the well known longest processing time scheduling heuristic deals adequately with load imbalance. The proposed parallelization is evaluated on two pharmacometrics models, a domain where hierarchical models with load imbalance are common due to the numeric simulation of pharmacokinetics and pharmacodynamics of human subjects. The varying number of measurements taken per subject further exacerbates load imbalance.","publish_time":1590451200000,"author_summary":" Nemeth, Balazs; Haber, Tom; Liesenborgs,<br>Jori; Lamotte, Wim","abstract_summary":" Hierarchical models describe phenomena by<br>grouping data into multiple levels. Due to the size of<br>these models, parallel execution is required to<br>avoid prohibitively long computing time. While it is<br>occasionally possible to specify some of these models using<br>parallel building blocks, this limits expressivity.<br>Therefore, a more general generative specification is<br>preferred. To leverage parallel computing capacity,<br>these specifications can be annotated, but doing so<br>effectively assumes that the modeler has expertise from<br>computer science. This paper outlines how to identify<br>parallel parts automatically by leveraging the<br>conditional independence property in the graphical model<br>extracted from the dataflow graph...","title_summary":" From Conditional Independence to Parallel<br>Execution in Hierarchical Models","x":-26.7604084015,"y":40.6654701233,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7604084015,"tsne_y":40.6654701233,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"7itfq8ur","source_x":"PMC","title":"An Efficient New Static Scheduling Heuristic for Accelerated Architectures","doi":"10.1007\/978-3-030-50371-0_1","abstract":"Heterogeneous architectures that use Graphics Processing Units (GPUs) for general computations, in addition to multicore CPUs, are increasingly common in high-performance computing. However many of the existing methods for scheduling precedence-constrained tasks on such platforms were intended for more diversely heterogeneous clusters, such as the classic Heterogeneous Earliest Finish Time (HEFT) heuristic. We propose a new static scheduling heuristic called Heterogeneous Optimistic Finish Time (HOFT) which exploits the binary heterogeneity of accelerated platforms. Through extensive experimentation with custom software for simulating task scheduling problems on user-defined CPU-GPU platforms, we show that HOFT can obtain schedules at least [Formula: see text] shorter than HEFT\u2019s for medium-to-large numerical linear algebra application task graphs and around [Formula: see text] shorter on average for a large collection of randomly-generated graphs.","publish_time":1590451200000,"author_summary":" McSweeney, Thomas; Walton, Neil; Zounon,<br>Mawussi","abstract_summary":" Heterogeneous architectures that use<br>Graphics Processing Units (GPUs) for general<br>computations, in addition to multicore CPUs, are<br>increasingly common in high-performance computing.<br>However many of the existing methods for scheduling<br>precedence-constrained tasks on such platforms were intended for more<br>diversely heterogeneous clusters, such as the classic<br>Heterogeneous Earliest Finish Time (HEFT) heuristic. We<br>propose a new static scheduling heuristic called<br>Heterogeneous Optimistic Finish Time (HOFT) which exploits<br>the binary heterogeneity of accelerated<br>platforms. Through extensive experimentation with<br>custom software for simulating task scheduling<br>problems on user-defined CPU-GPU platforms, we show<br>that HOFT can obtain schedules at least [Formula:<br>see text]...","title_summary":" An Efficient New Static Scheduling Heuristic<br>for Accelerated Architectures","x":-26.5396671295,"y":40.1724662781,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5396671295,"tsne_y":40.1724662781,"subcluster":9,"subcluster_description":"Accelerated Architecturesutilizing Gpu Performance","shape":"p"},{"cord_uid":"lwxmjbjm","source_x":"PMC","title":"GPU-Accelerated RDP Algorithm for Data Segmentation","doi":"10.1007\/978-3-030-50371-0_17","abstract":"The Ramer-Douglas-Peucker (RDP) algorithm applies a recursive split-and-merge strategy, which can generate fast, compact and precise data compression for time-critical systems. The use of GPU parallelism accelerates the execution of RDP, but the recursive behavior and the dynamic size of the generated sub-tasks, requires adapting the algorithm to use the GPU resources efficiently. While previous research approaches propose the exploitation of task-based parallelism, our research advocates a general fine-grained solution, which avoids the dynamic and recursive execution of kernels. The segmentation of depth images, a typical application used on autonomous driving, reaches speeds of almost 1000 frames per second for typical workloads using our massively parallel proposal on low-consumption, embedded GPUs. The GPU-accelerated solution is at least an order of magnitude faster than the execution of the same program on multiple CPU cores with similar energy consumption.","publish_time":1590451200000,"author_summary":" Cebrian, Pau; Moure, Juan Carlos","abstract_summary":" The Ramer-Douglas-Peucker (RDP) algorithm<br>applies a recursive split-and-merge strategy, which<br>can generate fast, compact and precise data<br>compression for time-critical systems. The use of GPU<br>parallelism accelerates the execution of RDP, but the<br>recursive behavior and the dynamic size of the generated<br>sub-tasks, requires adapting the algorithm to use the GPU<br>resources efficiently. While previous research<br>approaches propose the exploitation of task-based<br>parallelism, our research advocates a general fine-grained<br>solution, which avoids the dynamic and recursive<br>execution of kernels. The segmentation of depth images, a<br>typical application used on autonomous driving,<br>reaches speeds of almost 1000 frames per second for...","title_summary":" GPU-Accelerated RDP Algorithm for Data<br>Segmentation","x":-26.4050350189,"y":40.0814056396,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.4050350189,"tsne_y":40.0814056396,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"sn7zyd4u","source_x":"PMC","title":"Utilizing GPU Performance Counters to Characterize GPU Kernels via Machine Learning","doi":"10.1007\/978-3-030-50371-0_7","abstract":"GPU computing kernels are relatively simple to write if achieving the best performance is not of the highest priority. However, it can quickly become a much more daunting task when users try to tune and optimize their kernels to obtain the highest performance. This is due to GPUs\u2019 massive degree of parallelism, complex memory hierarchy, fine grain synchronization, and long memory access latency. Hence, users must carry out the complex tasks of profiling, analyzing, and tuning to reduce performance bottlenecks. Today\u2019s GPUs can generate hundreds of performance events that comprehensively quantify the behavior of a kernel. Instead of relying on experts\u2019 manual analysis, this paper targets using machine learning methods to generalize GPU performance counter data to determine the characteristics of a GPU kernel as they will reveal possible reasons for low performance. We choose a set of problem-independent counters as our inputs to design and compare three machine learning methods to automatically classify the execution behavior of a kernel. The experimental results on stencil computing kernels and sparse matrix multiplications show the machine learning models\u2019 good accuracy, and demonstrate a feasible approach that is capable of classifying a kernel\u2019s characterizations and suggesting changes to a skilled user, who can subsequently improve kernel performance with less guessing.","publish_time":1590451200000,"author_summary":" Zigon, Bob; Song, Fengguang","abstract_summary":" GPU computing kernels are relatively simple to<br>write if achieving the best performance is not of the<br>highest priority. However, it can quickly become a much<br>more daunting task when users try to tune and<br>optimize their kernels to obtain the highest<br>performance. This is due to GPUs\u2019 massive degree of<br>parallelism, complex memory hierarchy, fine grain<br>synchronization, and long memory access latency. Hence, users<br>must carry out the complex tasks of profiling,<br>analyzing, and tuning to reduce performance bottlenecks.<br>Today\u2019s GPUs can generate hundreds of performance<br>events that comprehensively quantify the behavior of<br>a kernel. Instead of relying on...","title_summary":" Utilizing GPU Performance Counters to<br>Characterize GPU Kernels via Machine Learning","x":-26.5023841858,"y":40.1726226807,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5023841858,"tsne_y":40.1726226807,"subcluster":9,"subcluster_description":"Accelerated Architecturesutilizing Gpu Performance","shape":"p"},{"cord_uid":"qjkxgeu7","source_x":"PMC","title":"QEScalor: Quantitative Elastic Scaling Framework in Distributed Streaming Processing","doi":"10.1007\/978-3-030-50371-0_11","abstract":"Recently, researchers usually use the elastic scaling techniques as a powerful means of the distributed stream processing systems to deal with the high-speed data stream which arrives continuously and fluctuates constantly. The existing methods allocate the same amount of resources to the instances of the same operator, but they ignore the correlation between the operator performance and resource provision. It may lead to the waste of the resources caused by the over-provision or the huge overhead of the scheduling caused by the under-provision. To solve the above problems, we present a quantitative elastic scaling framework, named QEScalor, to allocate resources for the operator instances quantitatively based on the actual performance requirements. The experimental results show that compared with the existing works, the QEScalor can not only achieve resource-efficient elastic scaling with lower cost, but also it can enhance the total performance of the DSPAs.","publish_time":1590451200000,"author_summary":" Mu, Weimin; Jin, Zongze; Zhu, Weilin; Liu, Fan;<br>Li, Zhenzhen; Zhu, Ziyuan; Wang, Weiping","abstract_summary":" Recently, researchers usually use the elastic<br>scaling techniques as a powerful means of the<br>distributed stream processing systems to deal with the<br>high-speed data stream which arrives continuously and<br>fluctuates constantly. The existing methods allocate the<br>same amount of resources to the instances of the same<br>operator, but they ignore the correlation between the<br>operator performance and resource provision. It may<br>lead to the waste of the resources caused by the<br>over-provision or the huge overhead of the scheduling caused by<br>the under-provision. To solve the above problems,<br>we present a quantitative elastic scaling<br>framework, named QEScalor, to allocate resources...","title_summary":" QEScalor: Quantitative Elastic Scaling<br>Framework in Distributed Streaming Processing","x":-26.6462631226,"y":39.5106735229,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6462631226,"tsne_y":39.5106735229,"subcluster":6,"subcluster_description":"Genomics Data Processing","shape":"p"},{"cord_uid":"25siwrtq","source_x":"PMC","title":"heFFTe: Highly Efficient FFT for Exascale","doi":"10.1007\/978-3-030-50371-0_19","abstract":"Exascale computing aspires to meet the increasing demands from large scientific applications. Software targeting exascale is typically designed for heterogeneous architectures; henceforth, it is not only important to develop well-designed software, but also make it aware of the hardware architecture and efficiently exploit its power. Currently, several and diverse applications, such as those part of the Exascale Computing Project (ECP) in the United States, rely on efficient computation of the Fast Fourier Transform (FFT). In this context, we present the design and implementation of heFFTe (Highly Efficient FFT for Exascale) library, which targets the upcoming exascale supercomputers. We provide highly (linearly) scalable GPU kernels that achieve more than [Formula: see text] speedup with respect to local kernels from CPU state-of-the-art libraries, and over [Formula: see text] speedup for the whole FFT computation. A communication model for parallel FFTs is also provided to analyze the bottleneck for large-scale problems. We show experiments obtained on Summit supercomputer at Oak Ridge National Laboratory, using up to 24,576 IBM Power9 cores and 6,144 NVIDIA V-100 GPUs.","publish_time":1590451200000,"author_summary":" Ayala, Alan; Tomov, Stanimire; Haidar, Azzam;<br>Dongarra, Jack","abstract_summary":" Exascale computing aspires to meet the<br>increasing demands from large scientific applications.<br>Software targeting exascale is typically designed for<br>heterogeneous architectures; henceforth, it is not only<br>important to develop well-designed software, but also<br>make it aware of the hardware architecture and<br>efficiently exploit its power. Currently, several and<br>diverse applications, such as those part of the<br>Exascale Computing Project (ECP) in the United States,<br>rely on efficient computation of the Fast Fourier<br>Transform (FFT). In this context, we present the design<br>and implementation of heFFTe (Highly Efficient<br>FFT for Exascale) library, which targets the<br>upcoming exascale supercomputers. We provide highly...","title_summary":" heFFTe: Highly Efficient FFT for Exascale","x":-26.532087326,"y":40.1759262085,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.532087326,"tsne_y":40.1759262085,"subcluster":9,"subcluster_description":"Accelerated Architecturesutilizing Gpu Performance","shape":"p"},{"cord_uid":"98ds2vw5","source_x":"PMC","title":"Analysis of Checkpoint I\/O Behavior","doi":"10.1007\/978-3-030-50371-0_14","abstract":"Nowadays, checkpoints have gained some relevance, given the increasing complexity of scientific applications for the use of many resources over a long period of time. Thus, in fault tolerance strategies, in addition to taking into account the impact that the application itself has on HPC systems, we must add the impact of the checkpoint. The checkpoint saves information about the application and the system in order to be able to restore the application, if necessary, in stable storage. The checkpoint can be considered as an intensive I\/O application, so its storage need can have a great impact on the application. Therefore, in this paper, the analysis of the checkpoint\u2019s I\/O behavior is presented. The number of checkpoints to be performed in an application is often related to the maximum overhead that you want to introduce in the application. If we know the maximum overload the user wants to pay for and the overhead that a checkpoint introduces, we can calculate the number of checkpoints to be performed. This overhead depends significantly on the I\/O operations. The PIOM-PX tool was used to analyze the spatial and temporal I\/O patterns of the checkpoint. Based on this analysis, a model was designed to predict their behavior. This information is used to calculate the number of checkpoints to be performed in an application given a maximum overhead predefined by the user. This will allow us to understand what happens when a checkpoint is created in an HPC system, in order to make decisions that adapt to the user\u2019s requirements.","publish_time":1590451200000,"author_summary":" Le\u00f3n, Betzabeth; Gomez-Sanchez, Pilar;<br>Franco, Daniel; Rexachs, Dolores; Luque, Emilio","abstract_summary":" Nowadays, checkpoints have gained some<br>relevance, given the increasing complexity of scientific<br>applications for the use of many resources over a long period<br>of time. Thus, in fault tolerance strategies, in<br>addition to taking into account the impact that the<br>application itself has on HPC systems, we must add the impact<br>of the checkpoint. The checkpoint saves<br>information about the application and the system in order to<br>be able to restore the application, if necessary,<br>in stable storage. The checkpoint can be<br>considered as an intensive I\/O application, so its storage<br>need can have a great impact on the application....","title_summary":" Analysis of Checkpoint I\/O Behavior","x":-27.0484161377,"y":40.5334739685,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.0484161377,"tsne_y":40.5334739685,"subcluster":5,"subcluster_description":"Tizen Operating Systemsemi-Automatic Assessment","shape":"p"},{"cord_uid":"2m39440w","source_x":"PMC","title":"Cache-Aware Matrix Polynomials","doi":"10.1007\/978-3-030-50371-0_10","abstract":"Efficient solvers for partial differential equations are among the most important areas of algorithmic research in high-performance computing. In this paper we present a new optimization for solving linear autonomous partial differential equations. Our approach is based on polynomial approximations for exponential time integration, which involves the computation of matrix polynomial terms ([Image: see text]) in every time step. This operation is very memory intensive and requires targeted optimizations. In our approach, we exploit the cache-hierarchy of modern computer architectures using a temporal cache blocking approach over the matrix polynomial terms. We develop two single-core implementations realizing cache blocking over several sparse matrix-vector multiplications of the polynomial approximation and compare it to a reference method that performs the computation in the traditional iterative way. We evaluate our approach on three different hardware platforms and for a wide range of different matrices and demonstrate that our approach achieves time savings of up to 50% for a large number of matrices. This is especially the case on platforms with large caches, significantly increasing the performance to solve linear autonomous differential equations.","publish_time":1590451200000,"author_summary":" Huber, Dominik; Schreiber, Martin; Yang, Dai;<br>Schulz, Martin","abstract_summary":" Efficient solvers for partial differential<br>equations are among the most important areas of<br>algorithmic research in high-performance computing. In<br>this paper we present a new optimization for solving<br>linear autonomous partial differential equations.<br>Our approach is based on polynomial<br>approximations for exponential time integration, which<br>involves the computation of matrix polynomial terms<br>([Image: see text]) in every time step. This operation is<br>very memory intensive and requires targeted<br>optimizations. In our approach, we exploit the<br>cache-hierarchy of modern computer architectures using a<br>temporal cache blocking approach over the matrix<br>polynomial terms. We develop two single-core<br>implementations realizing cache blocking over...","title_summary":" Cache-Aware Matrix Polynomials","x":-25.8395881653,"y":40.5486068726,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.8395881653,"tsne_y":40.5486068726,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"1gteoid5","source_x":"PMC","title":"Generating Random Floating-Point Numbers by Dividing Integers: A Case Study","doi":"10.1007\/978-3-030-50417-5_2","abstract":"A method widely used to obtain IEEE 754 binary floating-point numbers with a standard uniform distribution involves drawing an integer uniformly at random and dividing it by another larger integer. We survey the various instances of the algorithm that are used in actual software and point out their properties and drawbacks, particularly from the standpoint of numerical software testing and data anonymization.","publish_time":1592179200000,"author_summary":" Goualard, Fr\u00e9d\u00e9ric","abstract_summary":" A method widely used to obtain IEEE 754 binary<br>floating-point numbers with a standard uniform distribution<br>involves drawing an integer uniformly at random and<br>dividing it by another larger integer. We survey the<br>various instances of the algorithm that are used in<br>actual software and point out their properties and<br>drawbacks, particularly from the standpoint of numerical<br>software testing and data anonymization.","title_summary":" Generating Random Floating-Point Numbers by<br>Dividing Integers: A Case Study","x":-22.4367523193,"y":46.9840393066,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4367523193,"tsne_y":46.9840393066,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"xeva9ovn","source_x":"PMC","title":"Investigating the Benefit of FP16-Enabled Mixed-Precision Solvers for Symmetric Positive Definite Matrices Using GPUs","doi":"10.1007\/978-3-030-50417-5_18","abstract":"Half-precision computation refers to performing floating-point operations in a 16-bit format. While half-precision has been driven largely by machine learning applications, recent algorithmic advances in numerical linear algebra have discovered beneficial use cases for half precision in accelerating the solution of linear systems of equations at higher precisions. In this paper, we present a high-performance, mixed-precision linear solver ([Formula: see text]) for symmetric positive definite systems in double-precision using graphics processing units (GPUs). The solver is based on a mixed-precision Cholesky factorization that utilizes the high-performance tensor core units in CUDA-enabled GPUs. Since the Cholesky factors are affected by the low precision, an iterative refinement (IR) solver is required to recover the solution back to double-precision accuracy. Two different types of IR solvers are discussed on a wide range of test matrices. A preprocessing step is also developed, which scales and shifts the matrix, if necessary, in order to preserve its positive-definiteness in lower precisions. Our experiments on the V100 GPU show that performance speedups are up to 4.7[Formula: see text] against a direct double-precision solver. However, matrix properties such as the condition number and the eigenvalue distribution can affect the convergence rate, which would consequently affect the overall performance.","publish_time":1592179200000,"author_summary":" Abdelfattah, Ahmad; Tomov, Stan; Dongarra,<br>Jack","abstract_summary":" Half-precision computation refers to<br>performing floating-point operations in a 16-bit format.<br>While half-precision has been driven largely by<br>machine learning applications, recent algorithmic<br>advances in numerical linear algebra have discovered<br>beneficial use cases for half precision in accelerating<br>the solution of linear systems of equations at<br>higher precisions. In this paper, we present a<br>high-performance, mixed-precision linear solver ([Formula: see<br>text]) for symmetric positive definite systems in<br>double-precision using graphics processing units (GPUs). The<br>solver is based on a mixed-precision Cholesky<br>factorization that utilizes the high-performance tensor<br>core units in CUDA-enabled GPUs. Since the Cholesky<br>factors are affected by the...","title_summary":" Investigating the Benefit of FP16-Enabled<br>Mixed-Precision Solvers for Symmetric Positive Definite<br>Matrices Using GPUs","x":-25.7297725677,"y":40.5186882019,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.7297725677,"tsne_y":40.5186882019,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"fc5zdasy","source_x":"PMC","title":"Ant Colony Optimization Implementation for Reversible Synthesis in Walsh-Hadamard Domain","doi":"10.1007\/978-3-030-50426-7_18","abstract":"Reversible circuits are one of the technologies that can provide future low energy circuits. The synthesis of an optimal reversible circuit for a given function is an np-hard problem. The meta-heuristic approaches are one of the most promising methods for these types of optimization problems. In this paper, a new approach for ACO reversible synthesis is presented. Usually, authors build an ACO system with the use of truth table or permutation representation of the reversible function. In this work, a Walsh spectral representation of a Boolean function is used. This allows dividing search spaces into smaller \u201cpromising\u201d areas with well-defined transition operations between them. As a result, we can minimize the enormous search space and generate better solutions than obtained by ACO synthesis with classical reversible function representation. The proposed approach was applied to benchmark reversible functions of 4,5 and 6 variables and compared to other meta-heuristic results and best-known solutions.","publish_time":1590364800000,"author_summary":" Podlaski, Krzysztof","abstract_summary":" Reversible circuits are one of the<br>technologies that can provide future low energy circuits.<br>The synthesis of an optimal reversible circuit for<br>a given function is an np-hard problem. The<br>meta-heuristic approaches are one of the most promising<br>methods for these types of optimization problems. In<br>this paper, a new approach for ACO reversible<br>synthesis is presented. Usually, authors build an ACO<br>system with the use of truth table or permutation<br>representation of the reversible function. In this work, a<br>Walsh spectral representation of a Boolean function<br>is used. This allows dividing search spaces into<br>smaller \u201cpromising\u201d areas with well-defined...","title_summary":" Ant Colony Optimization Implementation for<br>Reversible Synthesis in Walsh-Hadamard Domain","x":-24.0288162231,"y":41.7351989746,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0288162231,"tsne_y":41.7351989746,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"9rfwl9of","source_x":"PMC","title":"A Current Task-Based Programming Paradigms Analysis","doi":"10.1007\/978-3-030-50426-7_16","abstract":"Task-based paradigm models can be an alternative to MPI. The user defines atomic tasks with a defined input and output with the dependencies between them. Then, the runtime can schedule the tasks and data migrations efficiently over all the available cores while reducing the waiting time between tasks. This paper focus on comparing several task-based programming models between themselves using the LU factorization as benchmark. HPX, PaRSEC, Legion and YML+XMP are task-based programming models which schedule data movement and computational tasks on distributed resources allocated to the application. YML+XMP supports parallel and distributed tasks with XscalableMP, a PGAS language. We compared their performances and scalability are compared to ScaLAPACK, an highly optimized library which uses MPI to perform communications between the processes on up to 64 nodes. We performed a block-based LU factorization with the task-based programming model on up to a matrix of size [Formula: see text]. HPX is performing better than PaRSEC, Legion and YML+XMP but not better than ScaLAPACK. YML+XMP has a better scalability than HPX, Legion and PaRSEC. Regent has trouble scaling from 32 nodes to 64 nodes with our algorithm.","publish_time":1590364800000,"author_summary":" Gurhem, J\u00e9r\u00f4me; Petiton, Serge G.","abstract_summary":" Task-based paradigm models can be an<br>alternative to MPI. The user defines atomic tasks with a<br>defined input and output with the dependencies between<br>them. Then, the runtime can schedule the tasks and<br>data migrations efficiently over all the available<br>cores while reducing the waiting time between tasks.<br>This paper focus on comparing several task-based<br>programming models between themselves using the LU<br>factorization as benchmark. HPX, PaRSEC, Legion and YML+XMP<br>are task-based programming models which schedule<br>data movement and computational tasks on<br>distributed resources allocated to the application.<br>YML+XMP supports parallel and distributed tasks with<br>XscalableMP, a PGAS language. We...","title_summary":" A Current Task-Based Programming Paradigms<br>Analysis","x":-26.6659450531,"y":40.2405395508,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6659450531,"tsne_y":40.2405395508,"subcluster":8,"subcluster_description":"Hardware-Assisted Mpi Overlap Enginesimplifying","shape":"p"},{"cord_uid":"gbsoy2o8","source_x":"PMC","title":"Microservice Disaster Crash Recovery: A Weak Global Referential Integrity Management","doi":"10.1007\/978-3-030-50417-5_36","abstract":"Microservices which use polyglot persistence (using multiple data storage techniques) cannot be recovered in a consistent state from backups taken independently. As a consequence, references across microservice boundaries may break after disaster recovery. In this paper, we give a weak global consistency definition for microservice architectures and present a recovery protocol which takes advantage of cached referenced data to reduce the amnesia interval for the recovered microservice, i.e., the time interval after the most recent backup, during which state changes may have been lost.","publish_time":1592179200000,"author_summary":" Manouvrier, Maude; Pautasso, Cesare; Rukoz,<br>Marta","abstract_summary":" Microservices which use polyglot persistence<br>(using multiple data storage techniques) cannot be<br>recovered in a consistent state from backups taken<br>independently. As a consequence, references across<br>microservice boundaries may break after disaster recovery.<br>In this paper, we give a weak global consistency<br>definition for microservice architectures and present a<br>recovery protocol which takes advantage of cached<br>referenced data to reduce the amnesia interval for the<br>recovered microservice, i.e., the time interval after<br>the most recent backup, during which state changes<br>may have been lost.","title_summary":" Microservice Disaster Crash Recovery: A Weak<br>Global Referential Integrity Management","x":-27.6913833618,"y":41.7335929871,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.6913833618,"tsne_y":41.7335929871,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"yqackjjy","source_x":"PMC","title":"Parameterizations and Lagrange Cubics for Fitting Multidimensional Data","doi":"10.1007\/978-3-030-50417-5_10","abstract":"This paper discusses the issue of interpolating data points in arbitrary Euclidean space with the aid of Lagrange cubics [Formula: see text] and exponential parameterization. The latter is commonly used to either fit the so-called reduced data [Formula: see text] for which the associated exact interpolation knots remain unknown or to model the trajectory of the curve [Formula: see text] passing through [Formula: see text]. The exponential parameterization governed by a single parameter [Formula: see text] replaces such discrete set of unavailable knots [Formula: see text] ([Formula: see text] - an internal clock) with some new values [Formula: see text] ([Formula: see text] - an external clock). In order to compare [Formula: see text] with [Formula: see text] the selection of some [Formula: see text] should be predetermined. For some applications and theoretical considerations the function [Formula: see text] needs to form an injective mapping (e.g. in length estimation of [Formula: see text] with any [Formula: see text] fitting [Formula: see text]). We formulate and prove two sufficient conditions yielding [Formula: see text] as injective for given [Formula: see text] and analyze their asymptotic character which forms an important question for [Formula: see text] getting sufficiently dense. The algebraic conditions established herein are also geometrically visualized in 3D plots with the aid of Mathematica. This work is supplemented with illustrative examples including numerical testing of the underpinning convergence rate in length estimation [Formula: see text] by [Formula: see text] (once [Formula: see text]). The reparameterization has potential ramifications in computer graphics and robot navigation for trajectory planning e.g. to construct a new curve [Formula: see text] controlled by the appropriate choice of interpolation knots and of mapping [Formula: see text] (and\/or possibly [Formula: see text]).","publish_time":1592179200000,"author_summary":" Kozera, Ryszard; Noakes, Lyle; Wilko\u0142azka,<br>Magdalena","abstract_summary":" This paper discusses the issue of<br>interpolating data points in arbitrary Euclidean space with<br>the aid of Lagrange cubics [Formula: see text] and<br>exponential parameterization. The latter is commonly used<br>to either fit the so-called reduced data<br>[Formula: see text] for which the associated exact<br>interpolation knots remain unknown or to model the trajectory<br>of the curve [Formula: see text] passing through<br>[Formula: see text]. The exponential parameterization<br>governed by a single parameter [Formula: see text]<br>replaces such discrete set of unavailable knots<br>[Formula: see text] ([Formula: see text] - an internal<br>clock) with some new values [Formula: see text]...","title_summary":" Parameterizations and Lagrange Cubics for<br>Fitting Multidimensional Data","x":-21.9890079498,"y":43.9809646606,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.9890079498,"tsne_y":43.9809646606,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"xfy9hm6q","source_x":"PMC","title":"Addressing the Robustness of Resource Allocation in the Presence of Application and System Irregularities via PEPA Based Modeling","doi":"10.1007\/978-3-030-50417-5_44","abstract":"Applications executing in heterogeneous parallel and\/or distributed computing (PDC) environments are often prone to unpredictable runtime due to variations in problem, algorithm, and system characteristics. This serves as a key motivation towards a study of the robustness of resource allocations required to maintain and guarantee a desired level of performance. Performance modeling and evaluation is often utilized to understand and predict the behavior of the application and the computational system from a performance point of view. In prior work, performance modeling for evaluating response times of static resource allocations in PDC systems was introduced by the authors as a proof of concept for validating the use of the performance evaluation process algebra (PEPA) for analyzing the robustness of static resource allocations. Herein, the authors present numerical modeling of several static resource allocations to evaluate their robustness in the presence of compound perturbations generated as combinations of variations in application workload and machine availability. The novelty of the approach is to introduce the compound effect as the variability of both, application workload and processor\/machine availability, into the performance modeling of the overall computational system. The performance is obtained as a parallel execution time via a numerical analysis of the modeled execution of applications on non-dedicated parallel computational resources. A significant improvement in the robustness value (up to 143%) among the mappings yielding equal parallel execution times has been demonstrated via the analysis of the results. This notable difference in the robustness values strongly indicates the benefit of selecting one mapping versus the other for guaranteeing the best execution performance.","publish_time":1592179200000,"author_summary":" Srivastava, Srishti; Banicescu, Ioana;<br>Sanders, William S.","abstract_summary":" Applications executing in heterogeneous<br>parallel and\/or distributed computing (PDC)<br>environments are often prone to unpredictable runtime due to<br>variations in problem, algorithm, and system<br>characteristics. This serves as a key motivation towards a study<br>of the robustness of resource allocations<br>required to maintain and guarantee a desired level of<br>performance. Performance modeling and evaluation is often<br>utilized to understand and predict the behavior of the<br>application and the computational system from a<br>performance point of view. In prior work, performance<br>modeling for evaluating response times of static<br>resource allocations in PDC systems was introduced by<br>the authors as a proof...","title_summary":" Addressing the Robustness of Resource<br>Allocation in the Presence of Application and System<br>Irregularities via PEPA Based Modeling","x":-26.6535129547,"y":39.6790351868,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6535129547,"tsne_y":39.6790351868,"subcluster":6,"subcluster_description":"Genomics Data Processing","shape":"p"},{"cord_uid":"00tal94i","source_x":"PMC","title":"Grammatical Inference by Answer Set Programming","doi":"10.1007\/978-3-030-50423-6_4","abstract":"In this paper, the identification of context-free grammars based on the presentation of samples is investigated. The main idea of solving this problem proposed in the literature is reformulated in two different ways: in terms of general constrains and as an answer set program. In a series of experiments, we showed that our answer set programming approach is much faster than our alternative method and the original SAT encoding method. Similarly to a pioneer work, some well-known context-free grammars have been induced correctly, and we also followed its test procedure with randomly generated grammars, making it clear that using our answer set programs increases computational efficiency. The research can be regarded as another evidence that solutions based on the stable model (answer set) semantics of logic programming may be a right choice for complex problems.","publish_time":1590192000000,"author_summary":" Wieczorek, Wojciech; Str\u0105k, \u0141ukasz;<br>Nowakowski, Arkadiusz; Unold, Olgierd","abstract_summary":" In this paper, the identification of<br>context-free grammars based on the presentation of samples<br>is investigated. The main idea of solving this<br>problem proposed in the literature is reformulated in<br>two different ways: in terms of general constrains<br>and as an answer set program. In a series of<br>experiments, we showed that our answer set programming<br>approach is much faster than our alternative method and<br>the original SAT encoding method. Similarly to a<br>pioneer work, some well-known context-free grammars<br>have been induced correctly, and we also followed<br>its test procedure with randomly generated<br>grammars, making it clear that using our...","title_summary":" Grammatical Inference by Answer Set<br>Programming","x":-24.6670284271,"y":44.7711257935,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.6670284271,"tsne_y":44.7711257935,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"y13g8cib","source_x":"PMC","title":"Hypergraph Grammar-Based Model of Adaptive Bitmap Compression","doi":"10.1007\/978-3-030-50420-5_9","abstract":"JPEG algorithm defines a sequence of steps (essential and optional) executed in order to compress an image. The first step is an optional conversion of the image color space from RBG (red-blue-green) to YCbCr (luminance and two chroma components). This step allows to discard part of chrominance information, a useful gain due to the fact, that the chrominance resolution of the human eye is much lower than the luminance resolution. In the next step, the image is divided into 8[Formula: see text]8 blocks, called MCUs (Minimum Coded Units). In this paper we present a new adaptive bitmap compression algorithm, and we compare it to the state-of-the-art of JPEG algorithms. Our algorithm utilizes hypergraph grammar model, partitioning the bitmap into a set of adaptively selected rectangles. Each rectangle approximates a bitmap using MCUs with the size selected according to the entire rectangular element. The hypergraph grammar model allows to describe the whole compression algorithm by a set of five productions. They are executed during the compression stage, and they partition the actual rectangles into smaller ones, until the required compression rate is obtained. We show that our method allows to compress bitmaps with large uniform areas in a better way than traditional JPEG algorithms do.","publish_time":1590105600000,"author_summary":" Soli\u0144ski, Grzegorz; Wo\u017aniak, Maciej; Ryzner,<br>Jakub; Mosia\u0142ek, Albert; Paszy\u0144ska, Anna","abstract_summary":" JPEG algorithm defines a sequence of steps<br>(essential and optional) executed in order to compress an<br>image. The first step is an optional conversion of the<br>image color space from RBG (red-blue-green) to YCbCr<br>(luminance and two chroma components). This step allows to<br>discard part of chrominance information, a useful gain<br>due to the fact, that the chrominance resolution of<br>the human eye is much lower than the luminance<br>resolution. In the next step, the image is divided into<br>8[Formula: see text]8 blocks, called MCUs (Minimum Coded<br>Units). In this paper we present a new adaptive bitmap<br>compression algorithm, and...","title_summary":" Hypergraph Grammar-Based Model of Adaptive<br>Bitmap Compression","x":-23.5053329468,"y":41.6219139099,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.5053329468,"tsne_y":41.6219139099,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"4x7qtypf","source_x":"PMC","title":"Multi-agent Reinforcement Learning Using Simulated Quantum Annealing","doi":"10.1007\/978-3-030-50433-5_43","abstract":"With quantum computers still under heavy development, already numerous quantum machine learning algorithms have been proposed for both gate-based quantum computers and quantum annealers. Recently, a quantum annealing version of a reinforcement learning algorithm for grid-traversal using one agent was published. We extend this work based on quantum Boltzmann machines, by allowing for any number of agents. We show that the use of quantum annealing can improve the learning compared to classical methods. We do this both by means of actual quantum hardware and by simulated quantum annealing.","publish_time":1590364800000,"author_summary":" Neumann, Niels M. P.; de Heer, Paolo B. U. L.;<br>Chiscop, Irina; Phillipson, Frank","abstract_summary":" With quantum computers still under heavy<br>development, already numerous quantum machine learning<br>algorithms have been proposed for both gate-based quantum<br>computers and quantum annealers. Recently, a quantum<br>annealing version of a reinforcement learning algorithm<br>for grid-traversal using one agent was published.<br>We extend this work based on quantum Boltzmann<br>machines, by allowing for any number of agents. We show<br>that the use of quantum annealing can improve the<br>learning compared to classical methods. We do this both<br>by means of actual quantum hardware and by<br>simulated quantum annealing.","title_summary":" Multi-agent Reinforcement Learning Using<br>Simulated Quantum Annealing","x":-22.7339344025,"y":41.4668121338,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7339344025,"tsne_y":41.4668121338,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"lbueohsd","source_x":"PMC","title":"Hybrid Quantum Annealing Heuristic Method for Solving Job Shop Scheduling Problem","doi":"10.1007\/978-3-030-50433-5_39","abstract":"Scheduling problems have attracted the attention of researchers and practitioners for several decades. The quality of different methods developed to solve these problems on classical computers have been collected and compared in various benchmark repositories. Recently, quantum annealing has appeared as promising approach to solve some scheduling problems. The goal of this paper is to check experimentally if and how this approach can be applied for solving a well-known benchmark of the classical Job Shop Scheduling Problem. We present the existing capabilities provided by the D-Wave 2000Q quantum annealing system in the light of this benchmark. We have tested the quantum annealing system features experimentally, and proposed a new heuristic method as a proof-of-concept. In our approach we decompose the considered scheduling problem into a set of smaller optimization problems which fit better into a limited quantum hardware capacity. We have tuned experimentally various parameters of limited fully-connected graphs of qubits available in the quantum annealing system for the heuristic. We also indicate how new improvements in the upcoming D-Wave quantum processor might potentially impact the performance of our approach.","publish_time":1590364800000,"author_summary":" Kurowski, Krzysztof; W\u0229glarz, Jan; Subocz,<br>Marek; R\u00f3\u017cycki, Rafa\u0142; Walig\u00f3ra, Grzegorz","abstract_summary":" Scheduling problems have attracted the<br>attention of researchers and practitioners for several<br>decades. The quality of different methods developed to<br>solve these problems on classical computers have<br>been collected and compared in various benchmark<br>repositories. Recently, quantum annealing has appeared as<br>promising approach to solve some scheduling problems.<br>The goal of this paper is to check experimentally if<br>and how this approach can be applied for solving a<br>well-known benchmark of the classical Job Shop Scheduling<br>Problem. We present the existing capabilities provided<br>by the D-Wave 2000Q quantum annealing system in<br>the light of this benchmark. We have tested the...","title_summary":" Hybrid Quantum Annealing Heuristic Method for<br>Solving Job Shop Scheduling Problem","x":-22.8833522797,"y":40.9858398438,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.8833522797,"tsne_y":40.9858398438,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"e0vgjkjh","source_x":"PMC","title":"NUMA-Awareness as a Plug-In for an Eventify-Based Fast Multipole Method","doi":"10.1007\/978-3-030-50436-6_31","abstract":"Following the trend towards Exascale, today\u2019s supercomputers consist of increasingly complex and heterogeneous compute nodes. To exploit the performance of these systems, research software in HPC needs to keep up with the rapid development of hardware architectures. Since manual tuning of software to each and every architecture is neither sustainable nor viable, we aim to tackle this challenge through appropriate software design. In this article, we aim to improve the performance and sustainability of FMSolvr, a parallel Fast Multipole Method for Molecular Dynamics, by adapting it to Non-Uniform Memory Access architectures in a portable and maintainable way. The parallelization of FMSolvr is based on Eventify, an event-based tasking framework we co-developed with FMSolvr. We describe a layered software architecture that enables the separation of the Fast Multipole Method from its parallelization. The focus of this article is on the development and analysis of a reusable NUMA module that improves performance while keeping both layers separated to preserve maintainability and extensibility. By means of the NUMA module we introduce diverse NUMA-aware data distribution, thread pinning and work stealing policies for FMSolvr. During the performance analysis the modular design of the NUMA module was advantageous since it facilitates combination, interchange and redesign of the developed policies. The performance analysis reveals that the runtime of FMSolvr is reduced by [Formula: see text] from 1.48 ms to 1.16 ms through these policies.","publish_time":1590364800000,"author_summary":" Morgenstern, Laura; Haensel, David;<br>Beckmann, Andreas; Kabadshow, Ivo","abstract_summary":" Following the trend towards Exascale, today\u2019s<br>supercomputers consist of increasingly complex and<br>heterogeneous compute nodes. To exploit the performance of<br>these systems, research software in HPC needs to keep<br>up with the rapid development of hardware<br>architectures. Since manual tuning of software to each and<br>every architecture is neither sustainable nor<br>viable, we aim to tackle this challenge through<br>appropriate software design. In this article, we aim to<br>improve the performance and sustainability of<br>FMSolvr, a parallel Fast Multipole Method for Molecular<br>Dynamics, by adapting it to Non-Uniform Memory Access<br>architectures in a portable and maintainable way. The<br>parallelization of...","title_summary":" NUMA-Awareness as a Plug-In for an<br>Eventify-Based Fast Multipole Method","x":-26.6315422058,"y":40.1517486572,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6315422058,"tsne_y":40.1517486572,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"60ys0rwe","source_x":"PMC","title":"Revisiting Old Combinatorial Beasts in the Quantum Age: Quantum Annealing Versus Maximal Matching","doi":"10.1007\/978-3-030-50433-5_37","abstract":"This paper experimentally investigates the behavior of analog quantum computers such as commercialized by D-Wave when confronted to instances of the maximum cardinality matching problem specifically designed to be hard to solve by means of simulated annealing. We benchmark a D-Wave \u201cWashington\u201d (2X) with 1098 operational qubits on various sizes of such instances and observe that for all but the most trivially small of these it fails to obtain an optimal solution. Thus, our results suggest that quantum annealing, at least as implemented in a D-Wave device, falls in the same pitfalls as simulated annealing and therefore provides additional evidences suggesting that there exist polynomial-time problems that such a machine cannot solve efficiently to optimality.","publish_time":1590364800000,"author_summary":" Vert, Daniel; Sirdey, Renaud; Louise,<br>St\u00e9phane","abstract_summary":" This paper experimentally investigates the<br>behavior of analog quantum computers such as<br>commercialized by D-Wave when confronted to instances of the<br>maximum cardinality matching problem specifically<br>designed to be hard to solve by means of simulated<br>annealing. We benchmark a D-Wave \u201cWashington\u201d (2X) with<br>1098 operational qubits on various sizes of such<br>instances and observe that for all but the most trivially<br>small of these it fails to obtain an optimal solution.<br>Thus, our results suggest that quantum annealing, at<br>least as implemented in a D-Wave device, falls in the<br>same pitfalls as simulated annealing and therefore<br>provides additional evidences...","title_summary":" Revisiting Old Combinatorial Beasts in the<br>Quantum Age: Quantum Annealing Versus Maximal<br>Matching","x":-22.9734954834,"y":41.6965560913,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.9734954834,"tsne_y":41.6965560913,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"ugits3n4","source_x":"PMC","title":"Simulations of Quantum Finite Automata","doi":"10.1007\/978-3-030-50433-5_34","abstract":"This paper presents a Python library to simulate different kinds of quantum finite automata on a classical computer. The library also provides tools for language generation and visual representation of simulation results. We have conducted experiments to measure the time complexity of the simulation in a function of the automaton size, alphabet size and word length. Examples of library usage are also provided.","publish_time":1590364800000,"author_summary":" Lippa, Gustaw; Makie\u0142a, Krzysztof; Kuta,<br>Marcin","abstract_summary":" This paper presents a Python library to<br>simulate different kinds of quantum finite automata on a<br>classical computer. The library also provides tools for<br>language generation and visual representation of<br>simulation results. We have conducted experiments to<br>measure the time complexity of the simulation in a<br>function of the automaton size, alphabet size and word<br>length. Examples of library usage are also provided.","title_summary":" Simulations of Quantum Finite Automata","x":-24.1962242126,"y":45.9850311279,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.1962242126,"tsne_y":45.9850311279,"subcluster":17,"subcluster_description":"Quantum Finite Automatainsertion-Deletion Systems","shape":"p"},{"cord_uid":"psnb8ygd","source_x":"PMC","title":"Design of Short Codes for Quantum Channels with Asymmetric Pauli Errors","doi":"10.1007\/978-3-030-50433-5_49","abstract":"One of the main problems in quantum information systems is the presence of errors due to noise. Many quantum error correcting codes have been designed to deal with generic errors. In this paper we construct new stabilizer codes able to correct a given number [Formula: see text] of generic Pauli [Formula: see text] and [Formula: see text] errors, plus a number [Formula: see text] of Pauli errors of a specified type (e.g., [Formula: see text] errors). These codes can be of interest when the quantum channel is asymmetric, i.e., when some types of error occur more frequently than others. For example, we design a [[9, 1]] quantum error correcting code able to correct up to one generic qubit error plus one [Formula: see text] error in arbitrary positions. According to a generalized version of the quantum Hamming bound, it is the shortest code with this error correction capability.","publish_time":1590364800000,"author_summary":" Chiani, Marco; Valentini, Lorenzo","abstract_summary":" One of the main problems in quantum information<br>systems is the presence of errors due to noise. Many<br>quantum error correcting codes have been designed to<br>deal with generic errors. In this paper we construct<br>new stabilizer codes able to correct a given number<br>[Formula: see text] of generic Pauli [Formula: see text]<br>and [Formula: see text] errors, plus a number<br>[Formula: see text] of Pauli errors of a specified type<br>(e.g., [Formula: see text] errors). These codes can be<br>of interest when the quantum channel is<br>asymmetric, i.e., when some types of error occur more<br>frequently than others. For...","title_summary":" Design of Short Codes for Quantum Channels with<br>Asymmetric Pauli Errors","x":-23.0003185272,"y":42.5845031738,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.0003185272,"tsne_y":42.5845031738,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"pi977nax","source_x":"PMC","title":"Foundations for Workflow Application Scheduling on D-Wave System","doi":"10.1007\/978-3-030-50433-5_40","abstract":"Many scientific processes and applications can be represented in the standardized form of workflows. One of the key challenges related to managing and executing workflows is scheduling. As an NP-hard problem with exponential complexity it imposes limitations on the size of practically solvable problems. In this paper, we present a solution to the challenge of scheduling workflow applications with the help of the D-Wave quantum annealer. To the best of our knowledge, there is no other work directly addressing workflow scheduling using quantum computing. Our solution includes transformation into a Quadratic Unconstrained Binary Optimization (QUBO) problem and discussion of experimental results, as well as possible applications of the solution. For our experiments we choose four problem instances small enough to fit into the annealer\u2019s architecture. For two of our instances the quantum annealer finds the global optimum for scheduling. We thus show that it is possible to solve such problems with the help of the D-Wave machine and discuss the limitations of this approach.","publish_time":1590364800000,"author_summary":" Tomasiewicz, Dawid; Pawlik, Maciej;<br>Malawski, Maciej; Rycerz, Katarzyna","abstract_summary":" Many scientific processes and applications<br>can be represented in the standardized form of<br>workflows. One of the key challenges related to managing<br>and executing workflows is scheduling. As an<br>NP-hard problem with exponential complexity it<br>imposes limitations on the size of practically<br>solvable problems. In this paper, we present a solution<br>to the challenge of scheduling workflow<br>applications with the help of the D-Wave quantum annealer. To<br>the best of our knowledge, there is no other work<br>directly addressing workflow scheduling using quantum<br>computing. Our solution includes transformation into a<br>Quadratic Unconstrained Binary Optimization (QUBO)<br>problem and discussion of experimental...","title_summary":" Foundations for Workflow Application<br>Scheduling on D-Wave System","x":-25.5442886353,"y":40.009601593,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.5442886353,"tsne_y":40.009601593,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"6o2tshf0","source_x":"PMC","title":"Lessons Learned in a Decade of Research Software Engineering GPU Applications","doi":"10.1007\/978-3-030-50436-6_29","abstract":"After years of using Graphics Processing Units (GPUs) to accelerate scientific applications in fields as varied as tomography, computer vision, climate modeling, digital forensics, geospatial databases, particle physics, radio astronomy, and localization microscopy, we noticed a number of technical, socio-technical, and non-technical challenges that Research Software Engineers (RSEs) may run into. While some of these challenges, such as managing different programming languages within a project, or having to deal with different memory spaces, are common to all software projects involving GPUs, others are more typical of scientific software projects. Among these challenges we include changing resolutions or scales, maintaining an application over time and making it sustainable, and evaluating both the obtained results and the achieved performance.","publish_time":1590364800000,"author_summary":" van Werkhoven, Ben; Palenstijn, Willem Jan;<br>Sclocco, Alessio","abstract_summary":" After years of using Graphics Processing Units<br>(GPUs) to accelerate scientific applications in<br>fields as varied as tomography, computer vision,<br>climate modeling, digital forensics, geospatial<br>databases, particle physics, radio astronomy, and<br>localization microscopy, we noticed a number of technical,<br>socio-technical, and non-technical challenges that Research<br>Software Engineers (RSEs) may run into. While some of<br>these challenges, such as managing different<br>programming languages within a project, or having to deal<br>with different memory spaces, are common to all<br>software projects involving GPUs, others are more<br>typical of scientific software projects. Among these<br>challenges we include changing resolutions or scales,<br>maintaining an...","title_summary":" Lessons Learned in a Decade of Research<br>Software Engineering GPU Applications","x":-26.4122047424,"y":40.1756782532,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.4122047424,"tsne_y":40.1756782532,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"vipysuku","source_x":"PMC","title":"Quantum Hopfield Neural Networks: A New Approach and Its Storage Capacity","doi":"10.1007\/978-3-030-50433-5_44","abstract":"At the interface between quantum computing and machine learning, the field of quantum machine learning aims to improve classical machine learning algorithms with the help of quantum computers. Examples are Hopfield neural networks, which can store patterns and thereby are used as associative memory. However, the storage capacity of such classical networks is limited. In this work, we present a new approach to quantum Hopfield neural networks with classical inputs and outputs. The approach is easily extendable to quantum inputs or outputs. Performance is evaluated by three measures of error rates, introduced in this paper. We simulate our approach and find increased storage capacity compared to classical networks for small systems. We furthermore present classical results that indicate an increased storage capacity for quantum Hopfield neural networks in large systems as well.","publish_time":1590364800000,"author_summary":" Meinhardt, Nicholas; Neumann, Niels M. P.;<br>Phillipson, Frank","abstract_summary":" At the interface between quantum computing and<br>machine learning, the field of quantum machine<br>learning aims to improve classical machine learning<br>algorithms with the help of quantum computers. Examples<br>are Hopfield neural networks, which can store<br>patterns and thereby are used as associative memory.<br>However, the storage capacity of such classical<br>networks is limited. In this work, we present a new<br>approach to quantum Hopfield neural networks with<br>classical inputs and outputs. The approach is easily<br>extendable to quantum inputs or outputs. Performance is<br>evaluated by three measures of error rates, introduced in<br>this paper. We simulate our approach and...","title_summary":" Quantum Hopfield Neural Networks: A New<br>Approach and Its Storage Capacity","x":-22.6904354095,"y":41.5792999268,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.6904354095,"tsne_y":41.5792999268,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"3jo6qnvs","source_x":"PMC","title":"Imperfect Distributed Quantum Phase Estimation","doi":"10.1007\/978-3-030-50433-5_46","abstract":"In the near-term, the number of qubits in quantum computers will be limited to a few hundreds. Therefore, problems are often too large and complex to be run on quantum devices. By distributing quantum algorithms over different devices, larger problem instances can be run. This distributing however, often requires operations between two qubits of different devices. Using shared entangled states and classical communication, these operations between different devices can still be performed. In the ideal case of perfect fidelity, distributed quantum computing is a solution to achieving scalable quantum computers with a larger number of qubits. In this work we consider the effects on the output fidelity of a quantum algorithm when using noisy shared entangled states. We consider the quantum phase estimation algorithm and present two distribution schemes for the algorithm. We give the resource requirements for both and show that using less noisy shared entangled states results in a higher overall fidelity.","publish_time":1590364800000,"author_summary":" Neumann, Niels M. P.; van Houte, Roy; Attema,<br>Thomas","abstract_summary":" In the near-term, the number of qubits in<br>quantum computers will be limited to a few hundreds.<br>Therefore, problems are often too large and complex to be<br>run on quantum devices. By distributing quantum<br>algorithms over different devices, larger problem<br>instances can be run. This distributing however, often<br>requires operations between two qubits of different<br>devices. Using shared entangled states and classical<br>communication, these operations between different devices<br>can still be performed. In the ideal case of perfect<br>fidelity, distributed quantum computing is a solution to<br>achieving scalable quantum computers with a larger<br>number of qubits. In this work we...","title_summary":" Imperfect Distributed Quantum Phase<br>Estimation","x":-22.8178710938,"y":41.6756286621,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.8178710938,"tsne_y":41.6756286621,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"0evmsixa","source_x":"PMC","title":"Modeling and Automatic Code Generation Tool for Teaching Concurrent and Parallel Programming by Finite State Processes","doi":"10.1007\/978-3-030-50436-6_44","abstract":"Understanding concurrent and parallel programming can be a very hard task on first contact by students. This paper describes the development and experimental results of the FSP2JAVA tool. The proposed method starts from concurrent systems modeling through Finite State Processes (FSP). After that, the method includes an automatic code generation from the model. This goal is achieved by a domain-specific language compiler which translates from the FSP model to Java code. The FSP2JAVA tool is available for free download in the github site. We argue that this tool helps in teaching concurrent systems, since it abstracts all complex languages concern and encourages the student to be focused at the fundamental concepts of modeling and analysis.","publish_time":1590364800000,"author_summary":" Monteiro, Edwin; Pereira, Kelvinn; Barreto,<br>Raimundo","abstract_summary":" Understanding concurrent and parallel<br>programming can be a very hard task on first contact by<br>students. This paper describes the development and<br>experimental results of the FSP2JAVA tool. The proposed<br>method starts from concurrent systems modeling<br>through Finite State Processes (FSP). After that, the<br>method includes an automatic code generation from the<br>model. This goal is achieved by a domain-specific<br>language compiler which translates from the FSP model to<br>Java code. The FSP2JAVA tool is available for free<br>download in the github site. We argue that this tool helps<br>in teaching concurrent systems, since it<br>abstracts all complex languages concern...","title_summary":" Modeling and Automatic Code Generation Tool<br>for Teaching Concurrent and Parallel Programming<br>by Finite State Processes","x":-27.0127353668,"y":43.303401947,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.0127353668,"tsne_y":43.303401947,"subcluster":23,"subcluster_description":"Finite State Processesa Fast","shape":"p"},{"cord_uid":"wryjlh99","source_x":"PMC","title":"Towards Accurate Simulation of Global Challenges on Data Centers Infrastructures via Coupling of Models and Data Sources","doi":"10.1007\/978-3-030-50433-5_32","abstract":"Accurate digital twinning of the global challenges (GC) leads to computationally expensive coupled simulations. These simulations bring together not only different models, but also various sources of massive static and streaming data sets. In this paper, we explore ways to bridge the gap between traditional high performance computing (HPC) and data-centric computation in order to provide efficient technological solutions for accurate policy-making in the domain of GC. GC simulations in HPC environments give rise to a number of technical challenges related to coupling. Being intended to reflect current and upcoming situation for policy-making, GC simulations extensively use recent streaming data coming from external data sources, which requires changing traditional HPC systems operation. Another common challenge stems from the necessity to couple simulations and exchange data across data centers in GC scenarios. By introducing a generalized GC simulation workflow, this paper shows commonality of the technical challenges for various GC and reflects on the approaches to tackle these technical challenges in the HiDALGO project.","publish_time":1590364800000,"author_summary":" Gogolenko, Sergiy; Groen, Derek;<br>Suleimenova, Diana; Mahmood, Imran; Lawenda, Marcin; Nieto<br>de Santos, F. Javier; Hanley, John; Vu\u010dkovi\u0107,<br>Milana; Kr\u00f6ll, Mark; Geiger, Bernhard; Els\u00e4sser,<br>Robert; Hoppe, Dennis","abstract_summary":" Accurate digital twinning of the global<br>challenges (GC) leads to computationally expensive<br>coupled simulations. These simulations bring<br>together not only different models, but also various<br>sources of massive static and streaming data sets. In<br>this paper, we explore ways to bridge the gap between<br>traditional high performance computing (HPC) and<br>data-centric computation in order to provide efficient<br>technological solutions for accurate policy-making in the<br>domain of GC. GC simulations in HPC environments give<br>rise to a number of technical challenges related to<br>coupling. Being intended to reflect current and upcoming<br>situation for policy-making, GC simulations<br>extensively use recent streaming data...","title_summary":" Towards Accurate Simulation of Global<br>Challenges on Data Centers Infrastructures via Coupling<br>of Models and Data Sources","x":-26.7582168579,"y":39.6931037903,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7582168579,"tsne_y":39.6931037903,"subcluster":6,"subcluster_description":"Genomics Data Processing","shape":"p"},{"cord_uid":"79hfr31b","source_x":"PMC","title":"A Variational Algorithm for Quantum Neural Networks","doi":"10.1007\/978-3-030-50433-5_45","abstract":"Quantum Computing leverages the laws of quantum mechanics to build computers endowed with tremendous computing power. The field is attracting ever-increasing attention from both academic and private sectors, as testified by the recent demonstration of quantum supremacy in practice. However, the intrinsic restriction to linear operations significantly limits the range of relevant use cases for the application of Quantum Computing. In this work, we introduce a novel variational algorithm for quantum Single Layer Perceptron. Thanks to the universal approximation theorem, and given that the number of hidden neurons scales exponentially with the number of qubits, our framework opens to the possibility of approximating any function on quantum computers. Thus, the proposed approach produces a model with substantial descriptive power, and widens the horizon of potential applications already in the NISQ era, especially the ones related to Quantum Artificial Intelligence. In particular, we design a quantum circuit to perform linear combinations in superposition and discuss adaptations to classification and regression tasks. After this theoretical investigation, we also provide practical implementations using various simulation environments. Finally, we test the proposed algorithm on synthetic data exploiting both simulators and real quantum devices.","publish_time":1590364800000,"author_summary":" Macaluso, Antonio; Clissa, Luca; Lodi,<br>Stefano; Sartori, Claudio","abstract_summary":" Quantum Computing leverages the laws of<br>quantum mechanics to build computers endowed with<br>tremendous computing power. The field is attracting<br>ever-increasing attention from both academic and private<br>sectors, as testified by the recent demonstration of<br>quantum supremacy in practice. However, the intrinsic<br>restriction to linear operations significantly limits the<br>range of relevant use cases for the application of<br>Quantum Computing. In this work, we introduce a novel<br>variational algorithm for quantum Single Layer<br>Perceptron. Thanks to the universal approximation<br>theorem, and given that the number of hidden neurons<br>scales exponentially with the number of qubits, our<br>framework opens to the...","title_summary":" A Variational Algorithm for Quantum Neural<br>Networks","x":-22.7504501343,"y":41.6234436035,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7504501343,"tsne_y":41.6234436035,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"14w3edty","source_x":"PMC","title":"[Image: see text]: A Cross-Platform Programming Framework for Quantum-Accelerated Scientific Computing","doi":"10.1007\/978-3-030-50433-5_35","abstract":"This paper introduces a new cross-platform programming framework for developing quantum-accelerated scientific computing applications and executing them on most of today\u2019s cloud-based quantum computers and simulators. It makes use of C++ template meta-programming techniques to implement quantum algorithms as generic, platform-independent expressions, which get automatically synthesized into device-specific compute kernels upon execution. Our software framework supports concurrent and asynchronous execution of multiple quantum kernels via a CUDA-inspired stream concept.","publish_time":1590364800000,"author_summary":" M\u00f6ller, Matthias; Schalkers, Merel","abstract_summary":" This paper introduces a new cross-platform<br>programming framework for developing<br>quantum-accelerated scientific computing applications and<br>executing them on most of today\u2019s cloud-based quantum<br>computers and simulators. It makes use of C++ template<br>meta-programming techniques to implement quantum algorithms as<br>generic, platform-independent expressions, which get<br>automatically synthesized into device-specific compute<br>kernels upon execution. Our software framework<br>supports concurrent and asynchronous execution of<br>multiple quantum kernels via a CUDA-inspired stream<br>concept.","title_summary":" [Image: see text]: A Cross-Platform<br>Programming Framework for Quantum-Accelerated<br>Scientific Computing","x":-26.1787395477,"y":40.6703948975,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.1787395477,"tsne_y":40.6703948975,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"ztx9fsbg","source_x":"PMC","title":"Data Mining for Big Dataset-Related Thermal Analysis of High Performance Computing (HPC) Data Center","doi":"10.1007\/978-3-030-50436-6_27","abstract":"Greening of Data Centers could be achieved through energy savings in two significant areas, namely: compute systems and cooling systems. A reliable cooling system is necessary to produce a persistent flow of cold air to cool the servers due to increasing computational load demand. Servers\u2019 dissipated heat effects a strain on the cooling systems. Consequently, it is necessary to identify hotspots that frequently occur in the server zones. This is facilitated through the application of data mining techniques to an available big dataset for thermal characteristics of High-Performance Computing ENEA Data Center, namely Cresco 6. This work presents an algorithm that clusters hotspots with the goal of reducing a data centre\u2019s large thermal-gradient due to uneven distribution of server dissipated waste heat followed by increasing cooling effectiveness.","publish_time":1590364800000,"author_summary":" De Chiara, Davide; Chinnici, Marta; Kor,<br>Ah-Lian","abstract_summary":" Greening of Data Centers could be achieved<br>through energy savings in two significant areas,<br>namely: compute systems and cooling systems. A<br>reliable cooling system is necessary to produce a<br>persistent flow of cold air to cool the servers due to<br>increasing computational load demand. Servers\u2019<br>dissipated heat effects a strain on the cooling systems.<br>Consequently, it is necessary to identify hotspots that<br>frequently occur in the server zones. This is facilitated<br>through the application of data mining techniques to an<br>available big dataset for thermal characteristics of<br>High-Performance Computing ENEA Data Center, namely Cresco 6.<br>This work presents an algorithm...","title_summary":" Data Mining for Big Dataset-Related Thermal<br>Analysis of High Performance Computing (HPC) Data<br>Center","x":-26.801618576,"y":39.255355835,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.801618576,"tsne_y":39.255355835,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"m4maejgo","source_x":"PMC","title":"A Quantum Annealing Algorithm for Finding Pure Nash Equilibria in Graphical Games","doi":"10.1007\/978-3-030-50433-5_38","abstract":"We introduce Q-Nash, a quantum annealing algorithm for the NP-complete problem of finding pure Nash equilibria in graphical games. The algorithm consists of two phases. The first phase determines all combinations of best response strategies for each player using classical computation. The second phase finds pure Nash equilibria using a quantum annealing device by mapping the computed combinations to a quadratic unconstrained binary optimization formulation based on the Set Cover problem. We empirically evaluate Q-Nash on D-Wave\u2019s Quantum Annealer 2000Q using different graphical game topologies. The results with respect to solution quality and computing time are compared to a Brute Force algorithm and the Iterated Best Response heuristic.","publish_time":1590364800000,"author_summary":" Roch, Christoph; Phan, Thomy; Feld,<br>Sebastian; M\u00fcller, Robert; Gabor, Thomas; Hahn, Carsten;<br>Linnhoff-Popien, Claudia","abstract_summary":" We introduce Q-Nash, a quantum annealing<br>algorithm for the NP-complete problem of finding pure<br>Nash equilibria in graphical games. The algorithm<br>consists of two phases. The first phase determines all<br>combinations of best response strategies for each player<br>using classical computation. The second phase finds<br>pure Nash equilibria using a quantum annealing<br>device by mapping the computed combinations to a<br>quadratic unconstrained binary optimization<br>formulation based on the Set Cover problem. We empirically<br>evaluate Q-Nash on D-Wave\u2019s Quantum Annealer 2000Q<br>using different graphical game topologies. The<br>results with respect to solution quality and computing<br>time are compared to a Brute...","title_summary":" A Quantum Annealing Algorithm for Finding Pure<br>Nash Equilibria in Graphical Games","x":-22.6891727448,"y":41.4331436157,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.6891727448,"tsne_y":41.4331436157,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"xdiytfye","source_x":"PMC","title":"Generalized Quantum Deutsch-Jozsa Algorithm","doi":"10.1007\/978-3-030-50433-5_36","abstract":"Quantum computing aims to provide algorithms and hardware that allows for solving computational problems asymptotically faster than on classical computers. Yet, design of new, fast quantum algorithms is not straightforward, and the field faces high barriers of entry for traditional computer scientists. One of the main didactic examples used to introduce speedup resulting from quantum computing is the Deutsch-Jozsa algorithm for discriminating between constant and balanced functions. Here, we show a generalization of the Deutsch-Jozsa algorithm beyond balanced functions that can be used to further illustrate the design choices underpinning quantum algorithms.","publish_time":1590364800000,"author_summary":" Arodz, Tomasz","abstract_summary":" Quantum computing aims to provide algorithms<br>and hardware that allows for solving<br>computational problems asymptotically faster than on<br>classical computers. Yet, design of new, fast quantum<br>algorithms is not straightforward, and the field faces<br>high barriers of entry for traditional computer<br>scientists. One of the main didactic examples used to<br>introduce speedup resulting from quantum computing is<br>the Deutsch-Jozsa algorithm for discriminating<br>between constant and balanced functions. Here, we show<br>a generalization of the Deutsch-Jozsa<br>algorithm beyond balanced functions that can be used to<br>further illustrate the design choices underpinning<br>quantum algorithms.","title_summary":" Generalized Quantum Deutsch-Jozsa Algorithm","x":-22.9866447449,"y":41.7198867798,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.9866447449,"tsne_y":41.7198867798,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"6wanod41","source_x":"PMC","title":"Degrees of Non-computability of Homeomorphism Types of Polish Spaces","doi":"10.1007\/978-3-030-51466-2_16","abstract":"There are continuum many homeomorphism types of Polish spaces. In particular, there is a Polish space which is not homeomorphic to any computably presented Polish space. We examine the details of degrees of non-computability of presenting homeomorphic copies of Polish spaces.","publish_time":1592956800000,"author_summary":" Hoyrup, Mathieu; Kihara, Takayuki;<br>Selivanov, Victor","abstract_summary":" There are continuum many homeomorphism types<br>of Polish spaces. In particular, there is a Polish<br>space which is not homeomorphic to any computably<br>presented Polish space. We examine the details of degrees<br>of non-computability of presenting<br>homeomorphic copies of Polish spaces.","title_summary":" Degrees of Non-computability of<br>Homeomorphism Types of Polish Spaces","x":-21.8444595337,"y":46.5387191772,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.8444595337,"tsne_y":46.5387191772,"subcluster":31,"subcluster_description":"Algebraic Surfacesa Convex Programming","shape":"p"},{"cord_uid":"a0xr7e5e","source_x":"PMC","title":"Computable Analysis and Classification Problems","doi":"10.1007\/978-3-030-51466-2_9","abstract":"Suppose we are given a collection of mathematical objects such as the class of connected compact Polish groups or the set of all real numbers which are normal to some base.","publish_time":1592956800000,"author_summary":" Downey, Rodney G.; Melnikov, Alexander G.","abstract_summary":" Suppose we are given a collection of<br>mathematical objects such as the class of connected compact<br>Polish groups or the set of all real numbers which are<br>normal to some base.","title_summary":" Computable Analysis and Classification<br>Problems","x":-22.0761890411,"y":46.6610069275,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.0761890411,"tsne_y":46.6610069275,"subcluster":31,"subcluster_description":"Algebraic Surfacesa Convex Programming","shape":"p"},{"cord_uid":"is6a5f7y","source_x":"PMC","title":"Theoretical and Implementational Aspects of the Formal Language Server (LaSer)","doi":"10.1007\/978-3-030-51466-2_25","abstract":"LaSer, the formal language server, allows a user to enter a question about an independent language and provides an answer either in real time or by generating a program that can be executed at the user\u2019s site. Typical examples of independent languages are codes in the classic sense, such as prefix codes and error-detecting languages, or DNA-computing related codes. Typical questions about independent languages are the satisfaction, maximality and construction questions. We present some theoretical and implementational aspects of LaSer, as well as some ongoing progress and research plans.","publish_time":1592956800000,"author_summary":" Konstantinidis, Stavros","abstract_summary":" LaSer, the formal language server, allows a<br>user to enter a question about an independent<br>language and provides an answer either in real time or by<br>generating a program that can be executed at the user\u2019s<br>site. Typical examples of independent languages are<br>codes in the classic sense, such as prefix codes and<br>error-detecting languages, or DNA-computing related codes.<br>Typical questions about independent languages are the<br>satisfaction, maximality and construction questions. We<br>present some theoretical and implementational<br>aspects of LaSer, as well as some ongoing progress and<br>research plans.","title_summary":" Theoretical and Implementational Aspects of<br>the Formal Language Server (LaSer)","x":-26.3909282684,"y":43.8010253906,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.3909282684,"tsne_y":43.8010253906,"subcluster":22,"subcluster_description":"Metric Temporal Graph Logic","shape":"p"},{"cord_uid":"qcpy9ycw","source_x":"PMC","title":"Time-Aware Uniformization of Winning Strategies","doi":"10.1007\/978-3-030-51466-2_17","abstract":"Two-player win\/lose games of infinite duration are involved in several disciplines including computer science and logic. If such a game has deterministic winning strategies, one may ask how simple such strategies can get. The answer may help with actual implementation, or to win despite imperfect information, or to conceal sensitive information especially if the game is repeated. Given a concurrent two-player win\/lose game of infinite duration, this article considers equivalence relations over histories of played actions. A classical restriction used here is that equivalent histories have equal length, hence time awareness. A sufficient condition is given such that if a player has winning strategies, she has one that prescribes the same action at equivalent histories, hence uniformization. The proof is fairly constructive and preserves finiteness of strategy memory, and counterexamples show relative tightness of the result. Several corollaries follow for games with states and colors.","publish_time":1592956800000,"author_summary":" Le Roux, St\u00e9phane","abstract_summary":" Two-player win\/lose games of infinite<br>duration are involved in several disciplines including<br>computer science and logic. If such a game has<br>deterministic winning strategies, one may ask how simple such<br>strategies can get. The answer may help with actual<br>implementation, or to win despite imperfect information, or to<br>conceal sensitive information especially if the game<br>is repeated. Given a concurrent two-player<br>win\/lose game of infinite duration, this article<br>considers equivalence relations over histories of<br>played actions. A classical restriction used here is<br>that equivalent histories have equal length, hence<br>time awareness. A sufficient condition is given<br>such that if a...","title_summary":" Time-Aware Uniformization of Winning<br>Strategies","x":-24.3077392578,"y":42.7024116516,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.3077392578,"tsne_y":42.7024116516,"subcluster":10,"subcluster_description":"Winning Strategieson-The-Fly","shape":"p"},{"cord_uid":"1wfg6vsa","source_x":"PMC","title":"Parallelizations in Weihrauch Reducibility and Constructive Reverse Mathematics","doi":"10.1007\/978-3-030-51466-2_4","abstract":"In the framework of finite-type arithmetic, we characterize the notion that an existence statement is primitive recursive Weihrauch reducible to the parallelization of another existence statement by a standard derivability notion in constructive reverse mathematics.","publish_time":1592956800000,"author_summary":" Fujiwara, Makoto","abstract_summary":" In the framework of finite-type arithmetic, we<br>characterize the notion that an existence statement is<br>primitive recursive Weihrauch reducible to the<br>parallelization of another existence statement by a standard<br>derivability notion in constructive reverse mathematics.","title_summary":" Parallelizations in Weihrauch Reducibility<br>and Constructive Reverse Mathematics","x":-23.1640033722,"y":46.276512146,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.1640033722,"tsne_y":46.276512146,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"gotvzg2u","source_x":"PMC","title":"Quantitative Coding and Complexity Theory of Compact Metric Spaces","doi":"10.1007\/978-3-030-51466-2_18","abstract":"Specifying a computational problem requires fixing encodings for input and output: encoding graphs as adjacency matrices, characters as integers, integers as bit strings, and vice versa. For such discrete data, the actual encoding is usually straightforward and\/or complexity-theoretically inessential (up to polynomial time, say); but concerning continuous data, already real numbers naturally suggest various encodings with very different computational properties. With respect to qualitative computability, Kreitz and Weihrauch (1985) had identified admissibility as crucial property for \u201creasonable\u201d encodings over the Cantor space of infinite binary sequences, so-called representations. For (precisely) these does the Kreitz-Weihrauch representation (aka Main) Theorem apply, characterizing continuity of functions in terms of continuous realizers. We similarly identify refined criteria for representations suitable for quantitative complexity investigations. Higher type complexity is captured by replacing Cantor\u2019s as ground space with more general compact metric spaces, similar to equilogical spaces in computability.","publish_time":1592956800000,"author_summary":" Lim, Donghyun; Ziegler, Martin","abstract_summary":" Specifying a computational problem requires<br>fixing encodings for input and output: encoding<br>graphs as adjacency matrices, characters as<br>integers, integers as bit strings, and vice versa. For<br>such discrete data, the actual encoding is usually<br>straightforward and\/or complexity-theoretically<br>inessential (up to polynomial time, say); but concerning<br>continuous data, already real numbers naturally suggest<br>various encodings with very different computational<br>properties. With respect to qualitative computability,<br>Kreitz and Weihrauch (1985) had identified<br>admissibility as crucial property for \u201creasonable\u201d<br>encodings over the Cantor space of infinite binary<br>sequences, so-called representations. For (precisely)<br>these does the Kreitz-Weihrauch representation<br>(aka Main) Theorem apply, characterizing...","title_summary":" Quantitative Coding and Complexity Theory of<br>Compact Metric Spaces","x":-23.1136646271,"y":43.6454391479,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.1136646271,"tsne_y":43.6454391479,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"3nsg9m2d","source_x":"PMC","title":"Clockability for Ordinal Turing Machines","doi":"10.1007\/978-3-030-51466-2_2","abstract":"We study clockability for Ordinal Turing Machines (OTMs). In particular, we show that, in contrast to the situation for ITTMs, admissible ordinals can be OTM-clockable, that [Formula: see text]-admissible ordinals are never OTM-clockable and that gaps in the OTM-clockable ordinals are always started by admissible limits of admissible ordinals. This partially answers two questions in [3].","publish_time":1592956800000,"author_summary":" Carl, Merlin","abstract_summary":" We study clockability for Ordinal Turing<br>Machines (OTMs). In particular, we show that, in<br>contrast to the situation for ITTMs, admissible<br>ordinals can be OTM-clockable, that [Formula: see<br>text]-admissible ordinals are never OTM-clockable and that gaps<br>in the OTM-clockable ordinals are always started<br>by admissible limits of admissible ordinals.<br>This partially answers two questions in [3].","title_summary":" Clockability for Ordinal Turing Machines","x":-24.5605106354,"y":45.3851509094,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.5605106354,"tsne_y":45.3851509094,"subcluster":14,"subcluster_description":"Orienting Combinator Equationsshort Q-Resolution","shape":"p"},{"cord_uid":"k0ee2l2i","source_x":"PMC","title":"Liouville Numbers and the Computational Complexity of Changing Bases","doi":"10.1007\/978-3-030-51466-2_5","abstract":"We study the computational complexity of uniformly converting the base-a expansion of an irrational numbers to the base-b expansion. In particular, we are interested in subsets of the irrationals where such conversion can be performed with little overhead. We show that such conversion is possible, essentially with polynomial overhead, for the set of irrationals that are not Liouville numbers. Furthermore, it is known that there are irrational numbers x such that the expansion of x in one integer base is efficiently computable, but the expansion of x in certain other integer bases is not. We prove that any such number must be a Liouville number.","publish_time":1592956800000,"author_summary":" Jakobsen, Sune Kristian; Simonsen, Jakob Grue","abstract_summary":" We study the computational complexity of<br>uniformly converting the base-a expansion of an<br>irrational numbers to the base-b expansion. In<br>particular, we are interested in subsets of the irrationals<br>where such conversion can be performed with little<br>overhead. We show that such conversion is possible,<br>essentially with polynomial overhead, for the set of<br>irrationals that are not Liouville numbers. Furthermore,<br>it is known that there are irrational numbers x<br>such that the expansion of x in one integer base is<br>efficiently computable, but the expansion of x in certain<br>other integer bases is not. We prove that any such<br>number...","title_summary":" Liouville Numbers and the Computational<br>Complexity of Changing Bases","x":-22.6431732178,"y":45.478302002,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.6431732178,"tsne_y":45.478302002,"subcluster":20,"subcluster_description":"Classic Real Number Representations","shape":"p"},{"cord_uid":"bzr7wl6w","source_x":"PMC","title":"Combinatorial Properties of Degree Sequences of 3-Uniform Hypergraphs Arising from Saind Arrays","doi":"10.1007\/978-3-030-51466-2_20","abstract":"The characterization of k-uniform hypergraphs by their degree sequences, say k-sequences, has been a longstanding open problem for [Formula: see text]. Very recently its decision version was proved to be NP-complete in [3]. In this paper, we consider Saind arrays [Formula: see text] of length [Formula: see text], i.e. arrays [Formula: see text], and we compute the related 3-uniform hypergraphs incidence matrices [Formula: see text] as in [3], where, for any [Formula: see text], the array of column sums, [Formula: see text] turns out to be the degree sequence of the corresponding 3-uniform hypergraph. We show that, for a generic [Formula: see text], [Formula: see text] and [Formula: see text] share the same entries starting from an index on. Furthermore, increasing n, these common entries give rise to the integer sequence A002620 in [15]. We prove this statement introducing the notion of queue-triad of size n and pointer k. Sequence A002620 is known to enumerate several combinatorial structures, including symmetric Dyck paths with three peaks, some families of integers partitions in two parts, bracelets with beads in three colours satisfying certain constraints, and special kind of genotype frequency vectors. We define bijections between queue triads and the above mentioned combinatorial families, thus showing an innovative approach to the study of 3-hypergraphic sequences which should provide subclasses of 3-uniform hypergraphs polynomially reconstructable from their degree sequences.","publish_time":1592956800000,"author_summary":" Frosini, A.; Palma, G.; Rinaldi, S.","abstract_summary":" The characterization of k-uniform<br>hypergraphs by their degree sequences, say k-sequences,<br>has been a longstanding open problem for [Formula:<br>see text]. Very recently its decision version was<br>proved to be NP-complete in [3]. In this paper, we<br>consider Saind arrays [Formula: see text] of length<br>[Formula: see text], i.e. arrays [Formula: see text], and<br>we compute the related 3-uniform hypergraphs<br>incidence matrices [Formula: see text] as in [3], where,<br>for any [Formula: see text], the array of column<br>sums, [Formula: see text] turns out to be the degree<br>sequence of the corresponding 3-uniform hypergraph. We<br>show that, for a generic...","title_summary":" Combinatorial Properties of Degree Sequences<br>of 3-Uniform Hypergraphs Arising from Saind<br>Arrays","x":-22.666765213,"y":43.9190826416,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.666765213,"tsne_y":43.9190826416,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"tx5z2nep","source_x":"PMC","title":"Insertion-Deletion Systems with Substitutions I","doi":"10.1007\/978-3-030-51466-2_33","abstract":"With good biological motivation, we add substitutions as a further type of operations to (in particular, context-free) insertion-deletion systems. This way, we obtain new characterizations of and normal forms for context-sensitive and recursively enumerable languages.","publish_time":1592956800000,"author_summary":" Vu, Martin; Fernau, Henning","abstract_summary":" With good biological motivation, we add<br>substitutions as a further type of operations to (in<br>particular, context-free) insertion-deletion systems.<br>This way, we obtain new characterizations of and<br>normal forms for context-sensitive and recursively<br>enumerable languages.","title_summary":" Insertion-Deletion Systems with<br>Substitutions I","x":-24.1743774414,"y":46.1569519043,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.1743774414,"tsne_y":46.1569519043,"subcluster":17,"subcluster_description":"Quantum Finite Automatainsertion-Deletion Systems","shape":"p"},{"cord_uid":"g88etd34","source_x":"PMC","title":"On Interpretability Between Some Weak Essentially Undecidable Theories","doi":"10.1007\/978-3-030-51466-2_6","abstract":"We introduce two essentially undecidable first-order theories [Formula: see text] and [Formula: see text]. The intended model for the theories is a term model. We prove that [Formula: see text] is mutually interpretable with Robinson\u2019s [Formula: see text]. Moreover, we prove that Robinson\u2019s [Formula: see text] is interpretable in [Formula: see text].","publish_time":1592956800000,"author_summary":" Kristiansen, Lars; Murwanashyaka, Juvenal","abstract_summary":" We introduce two essentially undecidable<br>first-order theories [Formula: see text] and [Formula: see<br>text]. The intended model for the theories is a term<br>model. We prove that [Formula: see text] is mutually<br>interpretable with Robinson\u2019s [Formula: see text].<br>Moreover, we prove that Robinson\u2019s [Formula: see text] is<br>interpretable in [Formula: see text].","title_summary":" On Interpretability Between Some Weak<br>Essentially Undecidable Theories","x":-24.3197174072,"y":45.335144043,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.3197174072,"tsne_y":45.335144043,"subcluster":14,"subcluster_description":"Orienting Combinator Equationsshort Q-Resolution","shape":"p"},{"cord_uid":"dujfi7wv","source_x":"PMC","title":"Some Notes on Spaces of Ideals and Computable Topology","doi":"10.1007\/978-3-030-51466-2_3","abstract":"It was shown in [4] that the quasi-Polish spaces introduced in [2] can be equivalently characterized as spaces of ideals in the following sense.","publish_time":1592956800000,"author_summary":" de Brecht, Matthew","abstract_summary":" It was shown in [4] that the quasi-Polish spaces<br>introduced in [2] can be equivalently characterized as<br>spaces of ideals in the following sense.","title_summary":" Some Notes on Spaces of Ideals and Computable<br>Topology","x":-22.010093689,"y":46.5358314514,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.010093689,"tsne_y":46.5358314514,"subcluster":31,"subcluster_description":"Algebraic Surfacesa Convex Programming","shape":"p"},{"cord_uid":"wybbc832","source_x":"PMC","title":"Number of Prefixes in Trace Monoids: Clique Polynomials and Dependency Graphs","doi":"10.1007\/978-3-030-51466-2_22","abstract":"We present some asymptotic properties on the average number of prefixes in trace languages. Such languages are characterized by an alphabet and a set of commutation rules, also called concurrent alphabet, which can be encoded by an independency graph or by its complement, called dependency graph. One key technical result, which has its own interest, concerns general properties of graphs and states that \u201cif an undirected graph admits a transitive orientation, then the multiplicity of the root of minimum modulus of its clique polynomial is smaller or equal to the number of connected components of its complement graph\u201d. As a consequence, under the same hypothesis of transitive orientation of the independency graph, one obtains the relation [Formula: see text], where the random variables [Formula: see text] and [Formula: see text] represent the number of prefixes in traces of length n under two different fundamental probabilistic models: the uniform distribution among traces of length n (for [Formula: see text]), the uniform distribution among words of length n (for [Formula: see text]). These two quantities are related to the time complexity of algorithms for solving classical membership problems on trace languages.","publish_time":1592956800000,"author_summary":" Banderier, Cyril; Goldwurm, Massimiliano","abstract_summary":" We present some asymptotic properties on the<br>average number of prefixes in trace languages. Such<br>languages are characterized by an alphabet and a set of<br>commutation rules, also called concurrent alphabet, which<br>can be encoded by an independency graph or by its<br>complement, called dependency graph. One key technical<br>result, which has its own interest, concerns general<br>properties of graphs and states that \u201cif an undirected<br>graph admits a transitive orientation, then the<br>multiplicity of the root of minimum modulus of its clique<br>polynomial is smaller or equal to the number of connected<br>components of its complement graph\u201d. As a...","title_summary":" Number of Prefixes in Trace Monoids: Clique<br>Polynomials and Dependency Graphs","x":-23.181142807,"y":43.8795127869,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.181142807,"tsne_y":43.8795127869,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"55fpwfkx","source_x":"PMC","title":"Repetitions in Toeplitz Words and the Thue Threshold","doi":"10.1007\/978-3-030-51466-2_23","abstract":"A (finite or infinite) word is said to be k-th power-free if it does not contain k consecutive equal blocks. A colouring of the integer lattice points in the n-dimensional Euclidean space is power-free if there exists a positive integer k such that the sequence of colours of consecutive points on any straight line is a k-th power-free word. The Thue threshold of [Formula: see text] is the least number of colours t(n) allowing a power-free colouring of the integer lattice points in the n-dimensional Euclidean space. Answering a question of Grytczuk (2008), we prove that [Formula: see text]. Moreover, we show the existence of a 2-colouring of the integer lattice points in the Euclidean plane such that the sequence of colours of consecutive points on any straight line does not contain squares of length larger than 26. In order to obtain these results, we study repetitions in Toeplitz words. We show that the Toeplitz word generated by any sequence of primitive partial words of maximal length k is k-th power-free. Moreover, adding a suitable hypothesis on the positions of the holes in the generating sequence, we obtain that also the subwords occurring in the considered Toeplitz word according to an arithmetic progression of suitable difference, are k-th power-free words.","publish_time":1592956800000,"author_summary":" Boccuto, Antonio; Carpi, Arturo","abstract_summary":" A (finite or infinite) word is said to be k-th<br>power-free if it does not contain k consecutive equal<br>blocks. A colouring of the integer lattice points in the<br>n-dimensional Euclidean space is power-free if there exists a<br>positive integer k such that the sequence of colours of<br>consecutive points on any straight line is a k-th power-free<br>word. The Thue threshold of [Formula: see text] is the<br>least number of colours t(n) allowing a power-free<br>colouring of the integer lattice points in the<br>n-dimensional Euclidean space. Answering a question of<br>Grytczuk (2008), we prove that [Formula: see text].<br>Moreover,...","title_summary":" Repetitions in Toeplitz Words and the Thue<br>Threshold","x":-22.7073345184,"y":44.2986221313,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7073345184,"tsne_y":44.2986221313,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"szzmz6y6","source_x":"PMC","title":"Balancing Straight-Line Programs for Strings and Trees","doi":"10.1007\/978-3-030-51466-2_26","abstract":"The talk will explain a recent balancing result according to which a context-free grammar in Chomsky normal form of size m that produces a single string w of length n (such a grammar is also called a straight-line program) can be transformed in linear time into a context-free grammar in Chomsky normal form for w of size [Formula: see text], whose unique derivation tree has depth [Formula: see text]. This solves an open problem in the area of grammar-based compression, improves many results in this area and greatly simplifies many existing constructions. Similar balancing results can be formulated for various grammar-based tree compression formalism like top DAGs and forest straight-line programs. The talk is based on joint work with Moses Ganardi and Artur Je\u017c. An extended abstract appeared in [11]; a long version of the paper can be found in [12].","publish_time":1592956800000,"author_summary":" Lohrey, Markus","abstract_summary":" The talk will explain a recent balancing result<br>according to which a context-free grammar in Chomsky<br>normal form of size m that produces a single string w of<br>length n (such a grammar is also called a straight-line<br>program) can be transformed in linear time into a<br>context-free grammar in Chomsky normal form for w of size<br>[Formula: see text], whose unique derivation tree has<br>depth [Formula: see text]. This solves an open<br>problem in the area of grammar-based compression,<br>improves many results in this area and greatly<br>simplifies many existing constructions. Similar<br>balancing results can be formulated for various...","title_summary":" Balancing Straight-Line Programs for Strings<br>and Trees","x":-23.7816333771,"y":44.118183136,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.7816333771,"tsne_y":44.118183136,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"yfmgrvyy","source_x":"PMC","title":"#P-completeness of Counting Update Digraphs, Cacti, and Series-Parallel Decomposition Method","doi":"10.1007\/978-3-030-51466-2_30","abstract":"Automata networks are a very general model of interacting entities, with applications to biological phenomena such as gene regulation. In many contexts, the order in which entities update their state is unknown, and the dynamics may be very sensitive to changes in this schedule of updates. Since the works of Aracena et al., it is known that update digraphs are pertinent objects to study non-equivalent block-sequential update schedules. We prove that counting the number of equivalence classes, that is a tight upper bound on the synchronism sensitivity of a given network, is [Formula: see text]-complete. The problem is nevertheless computable in quasi-quadratic time for oriented cacti, and for oriented series-parallel graphs thanks to a decomposition method.","publish_time":1592956800000,"author_summary":" No\u00fbs, Camille; Perrot, K\u00e9vin; Sen\u00e9, Sylvain;<br>Venturini, Lucas","abstract_summary":" Automata networks are a very general model of<br>interacting entities, with applications to biological<br>phenomena such as gene regulation. In many contexts, the<br>order in which entities update their state is<br>unknown, and the dynamics may be very sensitive to<br>changes in this schedule of updates. Since the works of<br>Aracena et al., it is known that update digraphs are<br>pertinent objects to study non-equivalent<br>block-sequential update schedules. We prove that counting the<br>number of equivalence classes, that is a tight upper<br>bound on the synchronism sensitivity of a given<br>network, is [Formula: see text]-complete. The problem<br>is nevertheless computable...","title_summary":" #P-completeness of Counting Update Digraphs,<br>Cacti, and Series-Parallel Decomposition Method","x":-24.1811218262,"y":43.9850845337,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.1811218262,"tsne_y":43.9850845337,"subcluster":28,"subcluster_description":"Automata Networksmonadic Decomposition","shape":"p"},{"cord_uid":"7umxx0tz","source_x":"PMC","title":"On the Complexity of Conversion Between Classic Real Number Representations","doi":"10.1007\/978-3-030-51466-2_7","abstract":"It is known that while it is possible to convert between many different representations of irrational numbers (e.g., between Dedekind cuts and Cauchy sequences), it is in general not possible to do so subrecursively: conversions in general need to perform unbounded search. This raises the question of categorizing the pairs of representations between which either subrecursive conversion is possible, or is not possible. The purpose of this paper is to prove the following positive result: for a number of well-known representations (Beatty sequences, Dedekind cuts, General base expansions, Hurwitz characteristics, and Locators) conversion between the representations can be performed effectively and with good subrecursive bounds.","publish_time":1592956800000,"author_summary":" Kristiansen, Lars; Simonsen, Jakob Grue","abstract_summary":" It is known that while it is possible to convert<br>between many different representations of irrational<br>numbers (e.g., between Dedekind cuts and Cauchy<br>sequences), it is in general not possible to do so<br>subrecursively: conversions in general need to perform<br>unbounded search. This raises the question of<br>categorizing the pairs of representations between which<br>either subrecursive conversion is possible, or is not<br>possible. The purpose of this paper is to prove the<br>following positive result: for a number of well-known<br>representations (Beatty sequences, Dedekind cuts, General<br>base expansions, Hurwitz characteristics, and<br>Locators) conversion between the representations can be<br>performed effectively...","title_summary":" On the Complexity of Conversion Between<br>Classic Real Number Representations","x":-22.7106590271,"y":45.4593009949,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7106590271,"tsne_y":45.4593009949,"subcluster":20,"subcluster_description":"Classic Real Number Representations","shape":"p"},{"cord_uid":"q0876x4u","source_x":"PMC","title":"Recent Advances in Text-to-Pattern Distance Algorithms","doi":"10.1007\/978-3-030-51466-2_32","abstract":"Computing text-to-pattern distances is a fundamental problem in pattern matching. Given a text of length n and a pattern of length m, we are asked to output the distance between the pattern and every n-substring of the text. A basic variant of this problem is computation of Hamming distances, that is counting the number of mismatches (different characters aligned), for each alignment. Other popular variants include [Formula: see text] distance (Manhattan distance), [Formula: see text] distance (Euclidean distance) and general [Formula: see text] distance. While each of those problems trivially generalizes classical pattern-matching, the efficient algorithms for them require a broader set of tools, usually involving both algebraic and combinatorial insights. We briefly survey the history of the problems, and then focus on the progress made in the past few years in many specific settings: fine-grained complexity and lower-bounds, [Formula: see text] multiplicative approximations, k-bounded relaxations, streaming algorithms, purely combinatorial algorithms, and other recently proposed variants.","publish_time":1592956800000,"author_summary":" Uzna\u0144ski, Przemys\u0142aw","abstract_summary":" Computing text-to-pattern distances is a<br>fundamental problem in pattern matching. Given a text of<br>length n and a pattern of length m, we are asked to output<br>the distance between the pattern and every<br>n-substring of the text. A basic variant of this problem is<br>computation of Hamming distances, that is counting the<br>number of mismatches (different characters<br>aligned), for each alignment. Other popular variants<br>include [Formula: see text] distance (Manhattan<br>distance), [Formula: see text] distance (Euclidean<br>distance) and general [Formula: see text] distance.<br>While each of those problems trivially generalizes<br>classical pattern-matching, the efficient algorithms<br>for them require a...","title_summary":" Recent Advances in Text-to-Pattern Distance<br>Algorithms","x":-22.9435405731,"y":43.811088562,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.9435405731,"tsne_y":43.811088562,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"z3r757u0","source_x":"PMC","title":"Non-coding Enumeration Operators","doi":"10.1007\/978-3-030-51466-2_10","abstract":"An enumeration operator maps each set A of natural numbers to a set [Formula: see text], in such a way that E(A) can be enumerated uniformly from every enumeration of A. The maximum possible Turing degree of E(A) is therefore the degree of the jump [Formula: see text]. It is impossible to have [Formula: see text] for all A, but possible to achieve this for all A outside a meager set of Lebesgue measure 0. We consider the properties of two specific enumeration operators: the HTP operator, mapping a set W of prime numbers to the set of polynomials realizing Hilbert\u2019s Tenth Problem in the ring [Formula: see text]; and the root operator, mapping the atomic diagram of an algebraic field F of characteristic 0 to the set of polynomials in [Formula: see text] with roots in F. These lead to new open questions about enumeration operators in general.","publish_time":1592956800000,"author_summary":" Miller, Russell","abstract_summary":" An enumeration operator maps each set A of<br>natural numbers to a set [Formula: see text], in such a<br>way that E(A) can be enumerated uniformly from<br>every enumeration of A. The maximum possible Turing<br>degree of E(A) is therefore the degree of the jump<br>[Formula: see text]. It is impossible to have [Formula:<br>see text] for all A, but possible to achieve this for<br>all A outside a meager set of Lebesgue measure 0. We<br>consider the properties of two specific enumeration<br>operators: the HTP operator, mapping a set W of prime<br>numbers to the set of polynomials realizing...","title_summary":" Non-coding Enumeration Operators","x":-23.0287227631,"y":44.3632850647,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.0287227631,"tsne_y":44.3632850647,"subcluster":29,"subcluster_description":"Inverse Lyndon Words","shape":"p"},{"cord_uid":"o8kivylv","source_x":"PMC","title":"Functions of Baire Class One over a Bishop Topology","doi":"10.1007\/978-3-030-51466-2_19","abstract":"If [Formula: see text] is a topology of open sets on a set X, a real-valued function on X is of Baire class one over [Formula: see text], if it is the pointwise limit of a sequence of functions in the corresponding ring of continuous functions C(X). If F is a Bishop topology of functions on X, a constructive and function-theoretic alternative to [Formula: see text] introduced by Bishop, we define a real-valued function on X to be of Baire class one over F, if it is the pointwise limit of a sequence of functions in F. We show that the set [Formula: see text] of functions of Baire class one over a given Bishop topology F on a set X is a Bishop topology on X. Consequently, notions and results from the general theory of Bishop spaces are naturally translated to the study of Baire class one-functions. We work within Bishop\u2019s informal system of constructive mathematics [Formula: see text], that is [Formula: see text] extended with inductive definitions with rules of countably many premises.","publish_time":1592956800000,"author_summary":" Petrakis, Iosif","abstract_summary":" If [Formula: see text] is a topology of open sets<br>on a set X, a real-valued function on X is of Baire<br>class one over [Formula: see text], if it is the<br>pointwise limit of a sequence of functions in the<br>corresponding ring of continuous functions C(X). If F is a<br>Bishop topology of functions on X, a constructive and<br>function-theoretic alternative to [Formula: see text] introduced<br>by Bishop, we define a real-valued function on X to<br>be of Baire class one over F, if it is the pointwise<br>limit of a sequence of functions in F. We show that...","title_summary":" Functions of Baire Class One over a Bishop<br>Topology","x":-22.2786045074,"y":44.7836265564,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.2786045074,"tsne_y":44.7836265564,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"38i5x9ye","source_x":"PMC","title":"A Note on Computable Embeddings for Ordinals and Their Reverses","doi":"10.1007\/978-3-030-51466-2_1","abstract":"We continue the study of computable embeddings for pairs of structures, i.e. for classes containing precisely two non-isomorphic structures. Surprisingly, even for some pairs of simple linear orders, computable embeddings induce a non-trivial degree structure. Our main result shows that although [Formula: see text] is computably embeddable in [Formula: see text], the class [Formula: see text] is not computably embeddable in [Formula: see text] for any natural number [Formula: see text].","publish_time":1592956800000,"author_summary":" Bazhenov, Nikolay; Vatev, Stefan","abstract_summary":" We continue the study of computable embeddings<br>for pairs of structures, i.e. for classes<br>containing precisely two non-isomorphic structures.<br>Surprisingly, even for some pairs of simple linear orders,<br>computable embeddings induce a non-trivial degree<br>structure. Our main result shows that although [Formula:<br>see text] is computably embeddable in [Formula:<br>see text], the class [Formula: see text] is not<br>computably embeddable in [Formula: see text] for any<br>natural number [Formula: see text].","title_summary":" A Note on Computable Embeddings for Ordinals<br>and Their Reverses","x":-22.7857971191,"y":44.9718971252,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7857971191,"tsne_y":44.9718971252,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"52blv0lv","source_x":"PMC","title":"The Computational Significance of Hausdorff\u2019s Maximal Chain Principle","doi":"10.1007\/978-3-030-51466-2_21","abstract":"As a fairly frequent form of the Axiom of Choice about relatively simple structures (posets), Hausdorff\u2019s Maximal Chain Principle appears to be little amenable to computational interpretation. This received view, however, requires revision. When attempting to convert Hausdorff\u2019s principle into a conservation theorem, we have indeed found out that maximal chains are more reminiscent of maximal ideals than it might seem at first glance. The latter live in richer algebraic structures (rings), and thus are readier to be put under computational scrutiny. Exploiting the newly discovered analogy between maximal chains and ideals, we can carry over the concept of Jacobson radical from a ring to an arbitrary set with an irreflexive symmetric relation. This achievement enables us to present a generalisation of Hausdorff\u2019s principle first as a semantic and then as a syntactical conservation theorem. We obtain the latter, which is nothing but the desired computational core of Hausdorff\u2019s principle, by passing from maximal chains to paths of finite binary trees of an adequate inductively generated class. In addition to Hausdorff\u2019s principle, applications include the Maximal Clique Principle for undirected graphs. Throughout the paper we work within constructive set theory.","publish_time":1592956800000,"author_summary":" Schuster, Peter; Wessel, Daniel","abstract_summary":" As a fairly frequent form of the Axiom of Choice<br>about relatively simple structures (posets),<br>Hausdorff\u2019s Maximal Chain Principle appears to be little<br>amenable to computational interpretation. This<br>received view, however, requires revision. When<br>attempting to convert Hausdorff\u2019s principle into a<br>conservation theorem, we have indeed found out that maximal<br>chains are more reminiscent of maximal ideals than it<br>might seem at first glance. The latter live in richer<br>algebraic structures (rings), and thus are readier to be<br>put under computational scrutiny. Exploiting the<br>newly discovered analogy between maximal chains and<br>ideals, we can carry over the concept of Jacobson...","title_summary":" The Computational Significance of<br>Hausdorff\u2019s Maximal Chain Principle","x":-23.1298274994,"y":45.0740737915,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.1298274994,"tsne_y":45.0740737915,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"kz1kvw3p","source_x":"PMC","title":"Ackermannian Goodstein Sequences of Intermediate Growth","doi":"10.1007\/978-3-030-51466-2_14","abstract":"The original Goodstein process proceeds by writing natural numbers in nested exponential k-normal form, then successively raising the base to [Formula: see text] and subtracting one from the end result. Such sequences always reach zero, but this fact is unprovable in Peano arithmetic. In this paper we instead consider notations for natural numbers based on the Ackermann function. We define two new Goodstein processes, obtaining new independence results for [Formula: see text] and [Formula: see text], theories of second order arithmetic related to the existence of Turing jumps.","publish_time":1592956800000,"author_summary":" Fern\u00e1ndez-Duque, David; Weiermann, Andreas","abstract_summary":" The original Goodstein process proceeds by<br>writing natural numbers in nested exponential<br>k-normal form, then successively raising the base to<br>[Formula: see text] and subtracting one from the end<br>result. Such sequences always reach zero, but this fact<br>is unprovable in Peano arithmetic. In this paper<br>we instead consider notations for natural<br>numbers based on the Ackermann function. We define two<br>new Goodstein processes, obtaining new<br>independence results for [Formula: see text] and [Formula:<br>see text], theories of second order arithmetic<br>related to the existence of Turing jumps.","title_summary":" Ackermannian Goodstein Sequences of<br>Intermediate Growth","x":-23.560136795,"y":45.344669342,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.560136795,"tsne_y":45.344669342,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"qu9rb7q9","source_x":"PMC","title":"ASNP: A Tame Fragment of Existential Second-Order Logic","doi":"10.1007\/978-3-030-51466-2_13","abstract":"Amalgamation SNP (ASNP) is a fragment of existential second-order logic that strictly contains binary connected MMSNP of Feder and Vardi and binary connected guarded monotone SNP of Bienvenu, ten Cate, Lutz, and Wolter; it is a promising candidate for an expressive subclass of NP that exhibits a complexity dichotomy. We show that ASNP has a complexity dichotomy if and only if the infinite-domain dichotomy conjecture holds for constraint satisfaction problems for first-order reducts of binary finitely bounded homogeneous structures. For such CSPs, powerful universal-algebraic hardness conditions are known that are conjectured to describe the border between NP-hard and polynomial-time tractable CSPs. The connection to CSPs also implies that every ASNP sentence can be evaluated in polynomial time on classes of finite structures of bounded treewidth. We show that the syntax of ASNP is decidable. The proof relies on the fact that for classes of finite binary structures given by finitely many forbidden substructures, the amalgamation property is decidable.","publish_time":1592956800000,"author_summary":" Bodirsky, Manuel; Kn\u00e4uer, Simon; Starke,<br>Florian","abstract_summary":" Amalgamation SNP (ASNP) is a fragment of<br>existential second-order logic that strictly contains<br>binary connected MMSNP of Feder and Vardi and binary<br>connected guarded monotone SNP of Bienvenu, ten Cate,<br>Lutz, and Wolter; it is a promising candidate for an<br>expressive subclass of NP that exhibits a complexity<br>dichotomy. We show that ASNP has a complexity dichotomy if<br>and only if the infinite-domain dichotomy<br>conjecture holds for constraint satisfaction problems<br>for first-order reducts of binary finitely<br>bounded homogeneous structures. For such CSPs,<br>powerful universal-algebraic hardness conditions are<br>known that are conjectured to describe the border<br>between NP-hard and polynomial-time tractable...","title_summary":" ASNP: A Tame Fragment of Existential<br>Second-Order Logic","x":-24.7648506165,"y":44.1533546448,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.7648506165,"tsne_y":44.1533546448,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"7c0ltv2c","source_x":"PMC","title":"On Simulation in Automata Networks","doi":"10.1007\/978-3-030-51466-2_24","abstract":"An automata network is a finite graph where each node holds a state from some finite alphabet and is equipped with an update function that changes its state according to the configuration of neighboring states. More concisely, it is given by a finite map [Formula: see text]. In this paper we study how some (sets of) automata networks can be simulated by some other (set of) automata networks with prescribed update mode or interaction graph. Our contributions are the following. For non-Boolean alphabets and for any network size, there are intrinsically non-sequential transformations (i.e. that can not be obtained as composition of sequential updates of some network). Moreover there is no universal automaton network that can produce all non-bijective functions via compositions of asynchronous updates. On the other hand, we show that there are universal automata networks for sequential updates if one is allowed to use a larger alphabet and then use either projection onto or restriction to the original alphabet. We also characterize the set of functions that are generated by non-bijective sequential updates. Following Tchuente, we characterize the interaction graphs D whose semigroup of transformations is the full semigroup of transformations on [Formula: see text], and we show that they are the same if we force either sequential updates only, or all asynchronous updates.","publish_time":1592956800000,"author_summary":" Bridoux, Florian; Gadouleau, Maximilien;<br>Theyssier, Guillaume","abstract_summary":" An automata network is a finite graph where each<br>node holds a state from some finite alphabet and is<br>equipped with an update function that changes its state<br>according to the configuration of neighboring states.<br>More concisely, it is given by a finite map [Formula:<br>see text]. In this paper we study how some (sets of)<br>automata networks can be simulated by some other (set of)<br>automata networks with prescribed update mode or<br>interaction graph. Our contributions are the following.<br>For non-Boolean alphabets and for any network<br>size, there are intrinsically non-sequential<br>transformations (i.e. that can not be obtained as...","title_summary":" On Simulation in Automata Networks","x":-24.0020561218,"y":43.8584747314,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0020561218,"tsne_y":43.8584747314,"subcluster":28,"subcluster_description":"Automata Networksmonadic Decomposition","shape":"p"},{"cord_uid":"405fsqvw","source_x":"PMC","title":"On the Complexity of Validity Degrees in \u0141ukasiewicz Logic","doi":"10.1007\/978-3-030-51466-2_15","abstract":"\u0141ukasiewicz logic is an established formal system of many-valued logic. Decision problems in both propositional and first-order case have been classified as to their computational complexity or degrees of undecidability; for the propositional fragment, theoremhood and provability from finite theories are [Formula: see text] complete. This paper extends the range of results by looking at validity degree in propositional \u0141ukasiewicz logic, a natural optimization problem to find the minimal value of a term under a finite theory in a fixed complete semantics interpreting the logic. A classification for this problem is provided using the oracle class [Formula: see text], where it is shown complete under metric reductions.","publish_time":1592956800000,"author_summary":" Hanikov\u00e1, Zuzana","abstract_summary":" \u0141ukasiewicz logic is an established formal<br>system of many-valued logic. Decision problems in<br>both propositional and first-order case have been<br>classified as to their computational complexity or<br>degrees of undecidability; for the propositional<br>fragment, theoremhood and provability from finite<br>theories are [Formula: see text] complete. This paper<br>extends the range of results by looking at validity<br>degree in propositional \u0141ukasiewicz logic, a natural<br>optimization problem to find the minimal value of a term under<br>a finite theory in a fixed complete semantics<br>interpreting the logic. A classification for this problem is<br>provided using the oracle class [Formula: see text],<br>where...","title_summary":" On the Complexity of Validity Degrees in<br>\u0141ukasiewicz Logic","x":-24.8422317505,"y":44.8107910156,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.8422317505,"tsne_y":44.8107910156,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"sexwh6d8","source_x":"PMC","title":"On the Interplay Between Inductive Inference of Recursive Functions, Complexity Theory and Recursive Numberings","doi":"10.1007\/978-3-030-51466-2_11","abstract":"The present paper surveys some results from the inductive inference of recursive functions, which are related to the characterization of inferrible function classes in terms of complexity theory, and in terms of recursive numberings. Some new results and open problems are also included.","publish_time":1592956800000,"author_summary":" Zeugmann, Thomas","abstract_summary":" The present paper surveys some results from the<br>inductive inference of recursive functions, which are<br>related to the characterization of inferrible<br>function classes in terms of complexity theory, and in<br>terms of recursive numberings. Some new results and<br>open problems are also included.","title_summary":" On the Interplay Between Inductive Inference<br>of Recursive Functions, Complexity Theory and<br>Recursive Numberings","x":-23.9372215271,"y":46.1560707092,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.9372215271,"tsne_y":46.1560707092,"subcluster":17,"subcluster_description":"Quantum Finite Automatainsertion-Deletion Systems","shape":"p"},{"cord_uid":"twv8q4dq","source_x":"PMC","title":"Deterministic and Nondeterministic Iterated Uniform Finite-State Transducers: Computational and Descriptional Power","doi":"10.1007\/978-3-030-51466-2_8","abstract":"An iterated uniform finite-state transducer ([Formula: see text]) operates the same length-preserving transduction, starting with a sweep on the input string and then iteratively sweeping on the output of the previous sweep. The [Formula: see text] accepts or rejects the input string by halting in an accepting or rejecting state along its sweeps. We consider both the deterministic ([Formula: see text]) and nondeterministic ([Formula: see text]) version of this device. We show that constant sweep bounded [Formula: see text]s and [Formula: see text]s accept all and only regular languages. We study the size cost of removing nondeterminism as well as sweeps on constant sweep bounded [Formula: see text]s, and the descriptional power of constant sweep bounded [Formula: see text]s and [Formula: see text]s with respect to classical models of finite-state automata. Finally, we focus on non-constant sweep bounded devices, proving the existence of a proper infinite nonregular language hierarchy depending on the sweep complexity both in the deterministic and nondeterministic case. Also, we show that the nondeterministic devices are always more powerful than their deterministic variant if at least a logarithmic number of sweeps is given.","publish_time":1592956800000,"author_summary":" Kutrib, Martin; Malcher, Andreas;<br>Mereghetti, Carlo; Palano, Beatrice","abstract_summary":" An iterated uniform finite-state transducer<br>([Formula: see text]) operates the same<br>length-preserving transduction, starting with a sweep on the<br>input string and then iteratively sweeping on the<br>output of the previous sweep. The [Formula: see text]<br>accepts or rejects the input string by halting in an<br>accepting or rejecting state along its sweeps. We<br>consider both the deterministic ([Formula: see text])<br>and nondeterministic ([Formula: see text])<br>version of this device. We show that constant sweep<br>bounded [Formula: see text]s and [Formula: see text]s<br>accept all and only regular languages. We study the<br>size cost of removing nondeterminism as well as...","title_summary":" Deterministic and Nondeterministic Iterated<br>Uniform Finite-State Transducers: Computational and<br>Descriptional Power","x":-23.6316432953,"y":44.2909851074,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.6316432953,"tsne_y":44.2909851074,"subcluster":35,"subcluster_description":"Semi-Simple Splicing Systemsthe State","shape":"p"},{"cord_uid":"t5duxtjv","source_x":"PMC","title":"Prawf: An Interactive Proof System for Program Extraction","doi":"10.1007\/978-3-030-51466-2_12","abstract":"We present an interactive proof system dedicated to program extraction from proofs. In a previous paper [5] the underlying theory IFP (Intuitionistic Fixed Point Logic) was presented and its soundness proven. The present contribution describes a prototype implementation and explains its use through several case studies. The system benefits from an improvement of the theory which makes it possible to extract programs from proofs using unrestricted strictly positive inductive and coinductive definitions, thus removing the previous admissibility restrictions.","publish_time":1592956800000,"author_summary":" Berger, Ulrich; Petrovska, Olga; Tsuiki,<br>Hideki","abstract_summary":" We present an interactive proof system<br>dedicated to program extraction from proofs. In a<br>previous paper [5] the underlying theory IFP<br>(Intuitionistic Fixed Point Logic) was presented and its<br>soundness proven. The present contribution describes a<br>prototype implementation and explains its use through<br>several case studies. The system benefits from an<br>improvement of the theory which makes it possible to extract<br>programs from proofs using unrestricted strictly<br>positive inductive and coinductive definitions, thus<br>removing the previous admissibility restrictions.","title_summary":" Prawf: An Interactive Proof System for Program<br>Extraction","x":-25.761713028,"y":44.5505371094,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.761713028,"tsne_y":44.5505371094,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"8bqb0804","source_x":"PMC","title":"The Glasgow Subgraph Solver: Using Constraint Programming to Tackle Hard Subgraph Isomorphism Problem Variants","doi":"10.1007\/978-3-030-51372-6_19","abstract":"The Glasgow Subgraph Solver provides an implementation of state of the art algorithms for subgraph isomorphism problems. It combines constraint programming concepts with a variety of strong but fast domain-specific search and inference techniques, and is suitable for use on a wide range of graphs, including many that are found to be computationally hard by other solvers. It can also be equipped with side constraints, and can easily be adapted to solve other subgraph matching problem variants. We outline its key features from the view of both users and algorithm developers, and discuss future directions.","publish_time":1590883200000,"author_summary":" McCreesh, Ciaran; Prosser, Patrick; Trimble,<br>James","abstract_summary":" The Glasgow Subgraph Solver provides an<br>implementation of state of the art algorithms for subgraph<br>isomorphism problems. It combines constraint programming<br>concepts with a variety of strong but fast<br>domain-specific search and inference techniques, and is<br>suitable for use on a wide range of graphs, including many<br>that are found to be computationally hard by other<br>solvers. It can also be equipped with side constraints,<br>and can easily be adapted to solve other subgraph<br>matching problem variants. We outline its key features<br>from the view of both users and algorithm<br>developers, and discuss future directions.","title_summary":" The Glasgow Subgraph Solver: Using Constraint<br>Programming to Tackle Hard Subgraph Isomorphism Problem<br>Variants","x":-24.5983257294,"y":43.1539268494,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.5983257294,"tsne_y":43.1539268494,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"avm9psep","source_x":"PMC","title":"A Flexible and Easy-to-Use Library for the Rapid Development of Graph Tools in Java","doi":"10.1007\/978-3-030-51372-6_17","abstract":"We present a programming library for the rapid development of graph tools, with applications in graph transformation and related fields. Features include working with graphs, graph morphisms, basic categorical constructions such as computing pushouts and pushout complements or enumerating all morphisms with certain properties, but also applications such as executing graph transformation steps. Additionally, we offer graphical user interface widgets for visualization and manipulation of graphs, morphisms and categorical diagrams. Our objective is to allow users to quickly develop graph tools for both simple and complex problems, to allow easy embedding into existing software, and to have comprehensible code especially for the main algorithms. Existing tools that demonstrate the versatility and ease of use of the library include: DPOdactic (a didactic tool for teaching double-pushout graph transformation), DrAGoM (a tool to handle multiply annotated type graphs for abstract graph rewriting), and Grez (termination analysis of graph transformation systems).","publish_time":1590883200000,"author_summary":" Bruggink, H. J. Sander; K\u00f6nig, Barbara;<br>Matjeka, Marleen; Nolte, Dennis; Stoltenow, Lars","abstract_summary":" We present a programming library for the rapid<br>development of graph tools, with applications in graph<br>transformation and related fields. Features include working<br>with graphs, graph morphisms, basic categorical<br>constructions such as computing pushouts and pushout<br>complements or enumerating all morphisms with certain<br>properties, but also applications such as executing graph<br>transformation steps. Additionally, we offer graphical user<br>interface widgets for visualization and manipulation of<br>graphs, morphisms and categorical diagrams. Our<br>objective is to allow users to quickly develop graph tools<br>for both simple and complex problems, to allow easy<br>embedding into existing software, and to have<br>comprehensible code especially...","title_summary":" A Flexible and Easy-to-Use Library for the<br>Rapid Development of Graph Tools in Java","x":-26.4501457214,"y":43.4558410645,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.4501457214,"tsne_y":43.4558410645,"subcluster":22,"subcluster_description":"Metric Temporal Graph Logic","shape":"p"},{"cord_uid":"rhgv0eom","source_x":"PMC","title":"Computing Embeddings of Directed Bigraphs","doi":"10.1007\/978-3-030-51372-6_3","abstract":"Directed bigraphs are a meta-model which generalises Milner\u2019s bigraphs by taking into account the request flow between controls and names. A key problem about these bigraphs is that of bigraph embedding, i.e., finding the embeddings of a bigraph inside a larger one. We present an algorithm for computing embeddings of directed bigraphs, via a reduction to a constraint satisfaction problem. We prove soundness and completeness of this algorithm, and provide an implementation in jLibBig, a general Java library for manipulating bigraphical reactive systems, together with some experimental results.","publish_time":1590883200000,"author_summary":" Chiapperini, Alessio; Miculan, Marino;<br>Peressotti, Marco","abstract_summary":" Directed bigraphs are a meta-model which<br>generalises Milner\u2019s bigraphs by taking into account the<br>request flow between controls and names. A key problem<br>about these bigraphs is that of bigraph embedding,<br>i.e., finding the embeddings of a bigraph inside a<br>larger one. We present an algorithm for computing<br>embeddings of directed bigraphs, via a reduction to a<br>constraint satisfaction problem. We prove soundness and<br>completeness of this algorithm, and provide an<br>implementation in jLibBig, a general Java library for<br>manipulating bigraphical reactive systems, together with<br>some experimental results.","title_summary":" Computing Embeddings of Directed Bigraphs","x":-25.5179138184,"y":44.6977424622,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.5179138184,"tsne_y":44.6977424622,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"khnjkv1s","source_x":"PMC","title":"A Simulator for Probabilistic Timed Graph Transformation Systems with Complex Large-Scale Topologies","doi":"10.1007\/978-3-030-51372-6_20","abstract":"Future cyber-physical systems, like networks of autonomous vehicles, will result in a huge number of collaborating systems acting together on large-scale topologies. Modeling them requires capturing timed and probabilistic behavior as well as structure dynamics. In [9], we introduced Probabilistic Timed Graph Transformation Systems (PTGTSs) as a means of modeling a high-level view of these systems of systems and provided model checking support. However, given the scale of emerging systems of systems and their often complex topologies, analyzing only small or medium size models using model checking is insufficient. To close this gap, we developed a simulator for PTGTSs that can import real-world topologies, automatically detect violations of state properties, and handle the graph pattern matching as well as time and probabilities efficiently so that complex large-scale topologies can be considered.","publish_time":1590883200000,"author_summary":" Z\u00f6llner, Christian; Barkowsky, Matthias;<br>Maximova, Maria; Schneider, Melanie; Giese, Holger","abstract_summary":" Future cyber-physical systems, like networks<br>of autonomous vehicles, will result in a huge<br>number of collaborating systems acting together on<br>large-scale topologies. Modeling them requires capturing<br>timed and probabilistic behavior as well as<br>structure dynamics. In [9], we introduced Probabilistic<br>Timed Graph Transformation Systems (PTGTSs) as a<br>means of modeling a high-level view of these systems<br>of systems and provided model checking support.<br>However, given the scale of emerging systems of systems<br>and their often complex topologies, analyzing<br>only small or medium size models using model<br>checking is insufficient. To close this gap, we<br>developed a simulator for PTGTSs that...","title_summary":" A Simulator for Probabilistic Timed Graph<br>Transformation Systems with Complex Large-Scale Topologies","x":-27.6857738495,"y":43.9923286438,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.6857738495,"tsne_y":43.9923286438,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"s9w0dm8l","source_x":"PMC","title":"Conditional Bigraphs","doi":"10.1007\/978-3-030-51372-6_1","abstract":"Bigraphs are a universal graph based model, designed for analysing reactive systems that include spatial and non-spatial (e.g. communication) relationships. Bigraphs evolve over time using a rewriting framework that finds instances of a (sub)-bigraph, and substitutes a new bigraph. In standard bigraphs, the applicability of a rewrite rule is determined completely by a local match and does not allow any non-local reasoning, i.e. contextual conditions. We introduce conditional bigraphs that add conditions to rules and show how these fit into the matching framework for standard bigraphs. An implementation is provided, along with a set of examples. Finally, we discuss the limits of application conditions within the existing matching framework and present ways to extend the range of conditions that may be expressed.","publish_time":1590883200000,"author_summary":" Archibald, Blair; Calder, Muffy; Sevegnani,<br>Michele","abstract_summary":" Bigraphs are a universal graph based model,<br>designed for analysing reactive systems that include<br>spatial and non-spatial (e.g. communication)<br>relationships. Bigraphs evolve over time using a rewriting<br>framework that finds instances of a (sub)-bigraph, and<br>substitutes a new bigraph. In standard bigraphs, the<br>applicability of a rewrite rule is determined completely by a<br>local match and does not allow any non-local<br>reasoning, i.e. contextual conditions. We introduce<br>conditional bigraphs that add conditions to rules and show<br>how these fit into the matching framework for<br>standard bigraphs. An implementation is provided,<br>along with a set of examples. Finally, we discuss the...","title_summary":" Conditional Bigraphs","x":-25.8945770264,"y":44.3885231018,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.8945770264,"tsne_y":44.3885231018,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"eenftvew","source_x":"PMC","title":"Initial Conflicts for Transformation Rules with Nested Application Conditions","doi":"10.1007\/978-3-030-51372-6_7","abstract":"We extend the theory of initial conflicts in the framework of [Formula: see text]-adhesive categories to transformation rules with ACs. We first show that for rules with ACs, conflicts are in general neither inherited from a bigger context any more, nor is it possible to find a finite and complete subset of finite conflicts as illustrated for the category of graphs. We define initial conflicts to be special so-called symbolic transformation pairs, and show that they are minimally complete (and in the case of graphs also finite) in this symbolic way. We show that initial conflicts represent a proper subset of critical pairs again. We moreover demonstrate that (analogous to the case of rules without ACs) for each conflict a unique initial conflict exists representing it. We conclude with presenting a sufficient condition illustrating important special cases for rules with ACs, where we do not only have initial conflicts being complete in a symbolic way, but also find complete (and in the case of graphs also finite) subsets of conflicts in the classical sense.","publish_time":1590883200000,"author_summary":" Lambers, Leen; Orejas, Fernando","abstract_summary":" We extend the theory of initial conflicts in the<br>framework of [Formula: see text]-adhesive categories to<br>transformation rules with ACs. We first show that for rules with<br>ACs, conflicts are in general neither inherited<br>from a bigger context any more, nor is it possible to<br>find a finite and complete subset of finite<br>conflicts as illustrated for the category of graphs. We<br>define initial conflicts to be special so-called<br>symbolic transformation pairs, and show that they are<br>minimally complete (and in the case of graphs also finite)<br>in this symbolic way. We show that initial<br>conflicts represent a proper subset...","title_summary":" Initial Conflicts for Transformation Rules<br>with Nested Application Conditions","x":-25.7668762207,"y":44.1716308594,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.7668762207,"tsne_y":44.1716308594,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"u9lh101s","source_x":"PMC","title":"Multiscale Graph Grammars Can Generate Cayley Graphs of Groups and Monoids","doi":"10.1007\/978-3-030-51372-6_18","abstract":"A graph grammar with parallel replacement of subgraphs, based on the single-pushout approach in graph rewriting, was designed which constructs Cayley graphs of monoids of transformations of a finite set, with permutation groups as a special case. As input, graph-based representations of a finite number of generating transformations have to be specified; they will then correspond to the edge types of the Cayley graph which is the final result of the rewriting process. The grammar has [Formula: see text] rules, where d is the number of generators, and operates at two scale levels. The fine-scale level is the level of elements on which the transformations act and where their composition is calculated by parallel subgraph replacement. The coarse-scale level corresponds to the transformations themselves which are organized in the Cayley graph in a sequential rule application process. Both scale levels are represented in a single graph. The graph grammar was implemented in the programming language XL on the software platform GroIMP, a graph rewriting tool which was originally designed for simulating the growth of plants.","publish_time":1590883200000,"author_summary":" Kurth, Winfried","abstract_summary":" A graph grammar with parallel replacement of<br>subgraphs, based on the single-pushout approach in graph<br>rewriting, was designed which constructs Cayley graphs of<br>monoids of transformations of a finite set, with<br>permutation groups as a special case. As input, graph-based<br>representations of a finite number of generating<br>transformations have to be specified; they will then correspond<br>to the edge types of the Cayley graph which is the<br>final result of the rewriting process. The grammar<br>has [Formula: see text] rules, where d is the number<br>of generators, and operates at two scale levels.<br>The fine-scale level is the level of...","title_summary":" Multiscale Graph Grammars Can Generate Cayley<br>Graphs of Groups and Monoids","x":-23.9032592773,"y":43.7784538269,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.9032592773,"tsne_y":43.7784538269,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"1yn80025","source_x":"PMC","title":"Unfolding Symbolic Attributed Graph Grammars","doi":"10.1007\/978-3-030-51372-6_5","abstract":"Attributed graph grammars can specify the transformation of complex data and object structures within a natural rule-based model of concurrency. This is crucial to their use in modelling interfaces of services and components as well as the evolution of complex systems and networks. However, the established concurrent semantics of graph grammars by unfolding does not cover attributed grammars. We develop a theory of unfolding for attributed graph grammars where attribution is represented symbolically, via logical constraints. We establish a functorial representation (a coreflection) of unfolding which guarantees it to be correct, complete and fully abstract. As a case study and running example we demonstrate the use of visual contracts to specify an escrow smart contract.","publish_time":1590883200000,"author_summary":" Ghaffari Saadat, Maryam; Heckel, Reiko;<br>Orejas, Fernando","abstract_summary":" Attributed graph grammars can specify the<br>transformation of complex data and object structures within a<br>natural rule-based model of concurrency. This is<br>crucial to their use in modelling interfaces of<br>services and components as well as the evolution of<br>complex systems and networks. However, the<br>established concurrent semantics of graph grammars by<br>unfolding does not cover attributed grammars. We develop<br>a theory of unfolding for attributed graph<br>grammars where attribution is represented<br>symbolically, via logical constraints. We establish a<br>functorial representation (a coreflection) of unfolding<br>which guarantees it to be correct, complete and fully<br>abstract. As a case study and...","title_summary":" Unfolding Symbolic Attributed Graph Grammars","x":-25.912361145,"y":44.4474182129,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.912361145,"tsne_y":44.4474182129,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"80r41ejh","source_x":"PMC","title":"Confluence up to Garbage","doi":"10.1007\/978-3-030-51372-6_2","abstract":"The transformation of graphs and graph-like structures is ubiquitous in computer science. When a system is described by graph-transformation rules, it is often desirable that the rules are both terminating and confluent so that rule applications in an arbitrary order produce unique resulting graphs. However, there are application scenarios where the rules are not globally confluent but confluent on a subclass of graphs that are of interest. In other words, non-resolvable conflicts can only occur on graphs that are considered as \u201cgarbage\u201d. In this paper, we introduce the notion of confluence up to garbage and generalise Plump\u2019s critical pair lemma for double-pushout graph transformation, providing a sufficient condition for confluence up to garbage by non-garbage critical pair analysis. We apply our results to language recognition by backtracking-free graph reduction, showing how to establish that a graph language can be decided by a system which is confluent up to garbage. We present two case studies with backtracking-free graph reduction systems which recognise a class of flow diagrams and a class of labelled series-parallel graphs, respectively. Both systems are non-confluent but confluent up to garbage.","publish_time":1590883200000,"author_summary":" Campbell, Graham; Plump, Detlef","abstract_summary":" The transformation of graphs and graph-like<br>structures is ubiquitous in computer science. When a<br>system is described by graph-transformation rules,<br>it is often desirable that the rules are both<br>terminating and confluent so that rule applications in an<br>arbitrary order produce unique resulting graphs.<br>However, there are application scenarios where the<br>rules are not globally confluent but confluent on a<br>subclass of graphs that are of interest. In other words,<br>non-resolvable conflicts can only occur on graphs that are<br>considered as \u201cgarbage\u201d. In this paper, we introduce the<br>notion of confluence up to garbage and generalise<br>Plump\u2019s critical pair lemma...","title_summary":" Confluence up to Garbage","x":-25.3092002869,"y":44.1276855469,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3092002869,"tsne_y":44.1276855469,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"mjj0e5fd","source_x":"PMC","title":"Hypergraph Basic Categorial Grammars","doi":"10.1007\/978-3-030-51372-6_9","abstract":"This work is an attempt to generalize categorial grammars, which deal with string languages, to hypergraphs. We consider a particular approach called basic categorial grammar (BCG) and introduce its natural extension to hypergraphs \u2014 hypergraph basic categorial grammar (HBCG). We show that BCGs can be naturally embedded in HBCGs. It turns out that, as BCGs are equivalent to context-free grammars, HBCGs are equivalent to hyperedge replacement grammars in generalized Greibach normal form. We also present several structural properties of HBCGs. From practical point of view, we show that HBCGs can be used to describe semantics of sentences of natural languages. We incorporate the lambda semantics into the new mechanism in the same way as it is done for BCGs and show that such an embedding allows one to describe semantics of sentences with cross-serial dependencies.","publish_time":1590883200000,"author_summary":" Pshenitsyn, Tikhon","abstract_summary":" This work is an attempt to generalize<br>categorial grammars, which deal with string languages, to<br>hypergraphs. We consider a particular approach called basic<br>categorial grammar (BCG) and introduce its natural<br>extension to hypergraphs \u2014 hypergraph basic categorial<br>grammar (HBCG). We show that BCGs can be naturally<br>embedded in HBCGs. It turns out that, as BCGs are<br>equivalent to context-free grammars, HBCGs are<br>equivalent to hyperedge replacement grammars in<br>generalized Greibach normal form. We also present several<br>structural properties of HBCGs. From practical point of<br>view, we show that HBCGs can be used to describe<br>semantics of sentences of natural languages....","title_summary":" Hypergraph Basic Categorial Grammars","x":-24.2408847809,"y":44.8797645569,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.2408847809,"tsne_y":44.8797645569,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"hooj4epe","source_x":"PMC","title":"Graph Consistency as a Graduated Property: Consistency-Sustaining and -Improving Graph Transformations","doi":"10.1007\/978-3-030-51372-6_14","abstract":"Where graphs are used for modelling and specifying systems, consistency is an important concern. To be a valid model of a system, the graph structure must satisfy a number of constraints. To date, consistency has primarily been viewed as a binary property: a graph either is or is not consistent with respect to a set of graph constraints. This has enabled the definition of notions such as constraint-preserving and constraint-guaranteeing graph transformations. Many practical applications\u2014for example model repair or evolutionary search\u2014implicitly assume a more graduated notion of consistency, but without an explicit formalisation only limited analysis of these applications is possible. In this paper, we introduce an explicit notion of consistency as a graduated property, depending on the number of constraint violations in a graph. We present two new characterisations of transformations (and transformation rules) enabling reasoning about the gradual introduction of consistency: while consistency-sustaining transformations do not decrease the consistency level, consistency-improving transformations strictly reduce the number of constraint violations. We show how these new definitions refine the existing concepts of constraint-preserving and constraint-guaranteeing transformations. To support a static analysis based on our characterisations, we present criteria for deciding which form of consistency ensuring transformations is induced by the application of a transformation rule. We illustrate our contributions in the context of an example from search-based model engineering.","publish_time":1590883200000,"author_summary":" Kosiol, Jens; Str\u00fcber, Daniel; Taentzer,<br>Gabriele; Zschaler, Steffen","abstract_summary":" Where graphs are used for modelling and<br>specifying systems, consistency is an important concern.<br>To be a valid model of a system, the graph structure<br>must satisfy a number of constraints. To date,<br>consistency has primarily been viewed as a binary property:<br>a graph either is or is not consistent with<br>respect to a set of graph constraints. This has enabled<br>the definition of notions such as<br>constraint-preserving and constraint-guaranteeing graph<br>transformations. Many practical applications\u2014for example<br>model repair or evolutionary search\u2014implicitly<br>assume a more graduated notion of consistency, but<br>without an explicit formalisation only limited<br>analysis of these applications is...","title_summary":" Graph Consistency as a Graduated Property:<br>Consistency-Sustaining and -Improving Graph Transformations","x":-25.4475650787,"y":43.8503875732,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.4475650787,"tsne_y":43.8503875732,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"c99z3ob0","source_x":"PMC","title":"Single Pushout Rewriting in Comprehensive Systems","doi":"10.1007\/978-3-030-51372-6_6","abstract":"The elegance of the single-pushout (SPO) approach to graph transformations arises from substituting total morphisms by partial ones in the underlying category. Thus, SPO\u2019s applicability depends on the durability of pushouts after this transition. There is a wide range of work on the question when pushouts exist in categories with partial morphisms starting with the pioneering work of L\u00f6we and Kennaway and ending with an essential characterisation in terms of an exactness property (for the interplay between pullbacks and pushouts) and an adjointness condition (w.r.t. inverse image functions) by Hayman and Heindel. Triple graphs and graph diagrams are frameworks to synchronize two or more updatable data sources by means of internal mappings, which identify common sub-structures. Comprehensive systems generalise these frameworks, treating the network of data sources and their structural inter-relations as a homogeneous comprehensive artifact, in which partial maps identify commonalities. Although this inherent partiality produces amplified complexity, Heindel\u2019s characterisation still yields cocompleteness of the category of comprehensive systems equipped with closed partial morphisms and thus enables computing by SPO graph transformation.","publish_time":1590883200000,"author_summary":" K\u00f6nig, Harald; St\u00fcnkel, Patrick","abstract_summary":" The elegance of the single-pushout (SPO)<br>approach to graph transformations arises from<br>substituting total morphisms by partial ones in the<br>underlying category. Thus, SPO\u2019s applicability depends<br>on the durability of pushouts after this<br>transition. There is a wide range of work on the question when<br>pushouts exist in categories with partial morphisms<br>starting with the pioneering work of L\u00f6we and Kennaway<br>and ending with an essential characterisation in<br>terms of an exactness property (for the interplay<br>between pullbacks and pushouts) and an adjointness<br>condition (w.r.t. inverse image functions) by Hayman and<br>Heindel. Triple graphs and graph diagrams are<br>frameworks to...","title_summary":" Single Pushout Rewriting in Comprehensive<br>Systems","x":-25.1254787445,"y":44.0590362549,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.1254787445,"tsne_y":44.0590362549,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"05s2usjk","source_x":"PMC","title":"A Categorical Semantics for Guarded Petri Nets","doi":"10.1007\/978-3-030-51372-6_4","abstract":"We build on the correspondence between Petri nets and free symmetric strict monoidal categories already investigated in the literature, and present a categorical semantics for Petri nets with guards. This comes in two flavors: Deterministic and with side-effects. Using the Grothendieck construction, we show how the guard semantics can be internalized in the net itself.","publish_time":1590883200000,"author_summary":" Genovese, Fabrizio; Spivak, David I.","abstract_summary":" We build on the correspondence between Petri<br>nets and free symmetric strict monoidal categories<br>already investigated in the literature, and present a<br>categorical semantics for Petri nets with guards. This<br>comes in two flavors: Deterministic and with<br>side-effects. Using the Grothendieck construction, we show<br>how the guard semantics can be internalized in the<br>net itself.","title_summary":" A Categorical Semantics for Guarded Petri Nets","x":-25.3832111359,"y":45.4410095215,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3832111359,"tsne_y":45.4410095215,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"33olgre3","source_x":"PMC","title":"Patch Graph Rewriting","doi":"10.1007\/978-3-030-51372-6_8","abstract":"The basic principle of graph rewriting is the stepwise replacement of subgraphs inside a host graph. A challenge in such replacement steps is the treatment of the patch graph, consisting of those edges of the host graph that touch the subgraph, but are not part of it. We introduce patch graph rewriting, a visual graph rewriting language with precise formal semantics. The language has rich expressive power in two ways. First, rewrite rules can flexibly constrain the permitted shapes of patches touching matching subgraphs. Second, rules can freely transform patches. We highlight the framework\u2019s distinguishing features by comparing it against existing approaches.","publish_time":1590883200000,"author_summary":" Overbeek, Roy; Endrullis, J\u00f6rg","abstract_summary":" The basic principle of graph rewriting is the<br>stepwise replacement of subgraphs inside a host graph. A<br>challenge in such replacement steps is the treatment of<br>the patch graph, consisting of those edges of the<br>host graph that touch the subgraph, but are not part<br>of it. We introduce patch graph rewriting, a<br>visual graph rewriting language with precise formal<br>semantics. The language has rich expressive power in two<br>ways. First, rewrite rules can flexibly constrain<br>the permitted shapes of patches touching matching<br>subgraphs. Second, rules can freely transform patches. We<br>highlight the framework\u2019s distinguishing features by<br>comparing it against...","title_summary":" Patch Graph Rewriting","x":-24.522354126,"y":43.5727462769,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.522354126,"tsne_y":43.5727462769,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"q88ayiks","source_x":"PMC","title":"Algebras for Tree Decomposable Graphs","doi":"10.1007\/978-3-030-51372-6_12","abstract":"Complex problems can be sometimes solved efficiently via recursive decomposition strategies. In this line, the tree decomposition approach equips problems modelled as graphs with tree-like parsing structures. Following Milner\u2019s flowgraph algebra, in a previous paper two of the authors introduced a strong network algebra to represent open graphs (up to isomorphism), so that homomorphic properties of open graphs can be computed via structural recursion. This paper extends this graphical-algebraic foundation to tree decomposable graphs. The correspondence is shown: (i) on the algebraic side by a loose network algebra, which relaxes the restriction reordering and scope extension axioms of the strong one; and (ii) on the graphical side by Milner\u2019s binding bigraphs, and elementary tree decompositions. Conveniently, an interpreted loose algebra gives the evaluation complexity of each graph decomposition. As a key contribution, we apply our results to dynamic programming (DP). The initial statement of the problem is transformed into a term (this is the secondary optimisation problem of DP). Noting that when the scope extension axiom is applied to reduce the scope of the restriction, then also the complexity is reduced (or not changed), only so-called canonical terms (in the loose algebra) are considered. Then, the canonical term is evaluated obtaining a solution which is locally optimal for complexity. Finding a global optimum remains an NP-hard problem.","publish_time":1590883200000,"author_summary":" Bruni, Roberto; Montanari, Ugo; Sammartino,<br>Matteo","abstract_summary":" Complex problems can be sometimes solved<br>efficiently via recursive decomposition strategies. In<br>this line, the tree decomposition approach equips<br>problems modelled as graphs with tree-like parsing<br>structures. Following Milner\u2019s flowgraph algebra, in a<br>previous paper two of the authors introduced a strong<br>network algebra to represent open graphs (up to<br>isomorphism), so that homomorphic properties of open graphs<br>can be computed via structural recursion. This<br>paper extends this graphical-algebraic foundation<br>to tree decomposable graphs. The correspondence<br>is shown: (i) on the algebraic side by a loose<br>network algebra, which relaxes the restriction<br>reordering and scope extension axioms of the strong...","title_summary":" Algebras for Tree Decomposable Graphs","x":-24.1942691803,"y":43.749130249,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.1942691803,"tsne_y":43.749130249,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"645p39ds","source_x":"PMC","title":"Optimistic and Pessimistic On-the-fly Analysis for Metric Temporal Graph Logic","doi":"10.1007\/978-3-030-51372-6_16","abstract":"The nonpropositional Metric Temporal Graph Logic (MTGL) specifies the behavior of timed dynamic systems given by timed graph sequences (TGSs), which contain typed attributed graphs representing system states and the elapsed time between states. MTGL satisfaction can be analyzed for finite TGSs by translating its satisfaction problem to the satisfaction problem of nested graph conditions using a folding operation (aggregating a TGS into a graph with history) and a reduction operation (translating an MTGL condition into a nested graph condition). In this paper, we introduce an analysis procedure for MTGL to allow for an on-the-fly analysis of finite\/infinite TGSs. To this end, we introduce a further (optimistic) reduction of MTGL conditions, which leads to violations during the on-the-fly analysis only when non-satisfaction is guaranteed in the future whereas the former (pessimistic) reduction leads to violations when satisfaction is not guaranteed in the future. We motivate the relevance of our analysis procedure, which uses both reduction operations, by means of a running example. Finally, we discuss prototypical support in the tool AutoGraph.","publish_time":1590883200000,"author_summary":" Schneider, Sven; Sakizloglou, Lucas;<br>Maximova, Maria; Giese, Holger","abstract_summary":" The nonpropositional Metric Temporal Graph<br>Logic (MTGL) specifies the behavior of timed dynamic<br>systems given by timed graph sequences (TGSs), which<br>contain typed attributed graphs representing system<br>states and the elapsed time between states. MTGL<br>satisfaction can be analyzed for finite TGSs by translating<br>its satisfaction problem to the satisfaction<br>problem of nested graph conditions using a folding<br>operation (aggregating a TGS into a graph with history)<br>and a reduction operation (translating an MTGL<br>condition into a nested graph condition). In this paper,<br>we introduce an analysis procedure for MTGL to<br>allow for an on-the-fly analysis of finite\/infinite<br>TGSs. To...","title_summary":" Optimistic and Pessimistic On-the-fly<br>Analysis for Metric Temporal Graph Logic","x":-26.2503356934,"y":43.7891654968,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.2503356934,"tsne_y":43.7891654968,"subcluster":22,"subcluster_description":"Metric Temporal Graph Logic","shape":"p"},{"cord_uid":"nwmkdsy7","source_x":"PMC","title":"Multilevel Typed Graph Transformations","doi":"10.1007\/978-3-030-51372-6_10","abstract":"Multilevel modeling extends traditional modeling techniques with a potentially unlimited number of abstraction levels. Multilevel models can be formally represented by multilevel typed graphs whose manipulation and transformation are carried out by multilevel typed graph transformation rules. These rules are cospans of three graphs and two inclusion graph homomorphisms where the three graphs are multilevel typed over a common typing chain. In this paper, we show that typed graph transformations can be appropriately generalized to multilevel typed graph transformations improving preciseness, flexibility and reusability of transformation rules. We identify type compatibility conditions, for rules and their matches, formulated as equations and inequations, respectively, between composed partial typing morphisms. These conditions are crucial presuppositions for the application of a rule for a match\u2014based on a pushout and a final pullback complement construction for the underlying graphs in the category [Image: see text] \u2014to always provide a well-defined canonical result in the multilevel typed setting. Moreover, to formalize and analyze multilevel typing as well as to prove the necessary results, in a systematic way, we introduce the category [Image: see text] of typing chains and typing chain morphisms.","publish_time":1590883200000,"author_summary":" Wolter, Uwe; Mac\u00edas, Fernando; Rutle, Adrian","abstract_summary":" Multilevel modeling extends traditional<br>modeling techniques with a potentially unlimited<br>number of abstraction levels. Multilevel models can<br>be formally represented by multilevel typed<br>graphs whose manipulation and transformation are<br>carried out by multilevel typed graph transformation<br>rules. These rules are cospans of three graphs and two<br>inclusion graph homomorphisms where the three graphs are<br>multilevel typed over a common typing chain. In this paper,<br>we show that typed graph transformations can be<br>appropriately generalized to multilevel typed graph<br>transformations improving preciseness, flexibility and<br>reusability of transformation rules. We identify type<br>compatibility conditions, for rules and their matches,<br>formulated as equations...","title_summary":" Multilevel Typed Graph Transformations","x":-25.3444671631,"y":43.9760475159,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3444671631,"tsne_y":43.9760475159,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"fr6i993w","source_x":"PMC","title":"Rewriting Theory for the Life Sciences: A Unifying Theory of CTMC Semantics","doi":"10.1007\/978-3-030-51372-6_11","abstract":"The Kappa biochemistry and the M\u00d8D organo-chemistry frameworks are amongst the most intensely developed applications of rewriting theoretical methods in the life sciences to date. A typical feature of these types of rewriting theories is the necessity to implement certain structural constraints on the objects to be rewritten (a protein is empirically found to have a certain signature of sites, a carbon atom can form at most four bonds, ...). In this paper, we contribute to the theoretical foundations of these types of rewriting theory a number of conceptual and technical developments that permit to implement a universal theory of continuous-time Markov chains (CTMCs) for stochastic rewriting systems. Our core mathematical concepts are a novel rule algebra construction for the relevant setting of rewriting rules with conditions, both in Double- and in Sesqui-Pushout semantics, augmented by a suitable stochastic mechanics formalism extension that permits to derive dynamical evolution equations for pattern-counting statistics.","publish_time":1590883200000,"author_summary":" Behr, Nicolas; Krivine, Jean","abstract_summary":" The Kappa biochemistry and the M\u00d8D<br>organo-chemistry frameworks are amongst the most intensely<br>developed applications of rewriting theoretical<br>methods in the life sciences to date. A typical feature<br>of these types of rewriting theories is the<br>necessity to implement certain structural constraints<br>on the objects to be rewritten (a protein is<br>empirically found to have a certain signature of sites, a<br>carbon atom can form at most four bonds, ...). In this<br>paper, we contribute to the theoretical foundations<br>of these types of rewriting theory a number of<br>conceptual and technical developments that permit to<br>implement a universal theory of...","title_summary":" Rewriting Theory for the Life Sciences: A<br>Unifying Theory of CTMC Semantics","x":-24.6888275146,"y":44.574256897,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.6888275146,"tsne_y":44.574256897,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"s8xxdw9h","source_x":"PMC","title":"Graph Parsing as Graph Transformation: Correctness of Predictive Top-Down Parsers","doi":"10.1007\/978-3-030-51372-6_13","abstract":"Hyperedge replacement (HR) allows to define context-free graph languages, but parsing is NP-hard in the general case. Predictive top-down (PTD) is an efficient, backtrack-free parsing algorithm for subclasses of HR and contextual HR grammars, which has been described and implemented in earlier work, based on a representation of graphs and grammar productions as strings. In this paper, we define PTD parsers for HR grammars by graph transformation rules and prove that they are correct.","publish_time":1590883200000,"author_summary":" Drewes, Frank; Hoffmann, Berthold; Minas,<br>Mark","abstract_summary":" Hyperedge replacement (HR) allows to define<br>context-free graph languages, but parsing is NP-hard in the<br>general case. Predictive top-down (PTD) is an<br>efficient, backtrack-free parsing algorithm for<br>subclasses of HR and contextual HR grammars, which has been<br>described and implemented in earlier work, based on a<br>representation of graphs and grammar productions as strings.<br>In this paper, we define PTD parsers for HR<br>grammars by graph transformation rules and prove that<br>they are correct.","title_summary":" Graph Parsing as Graph Transformation:<br>Correctness of Predictive Top-Down Parsers","x":-25.4047222137,"y":45.2457733154,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.4047222137,"tsne_y":45.2457733154,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"ssdj96t3","source_x":"PMC","title":"Formal Verification of Invariants for Attributed Graph Transformation Systems Based on Nested Attributed Graph Conditions","doi":"10.1007\/978-3-030-51372-6_15","abstract":"The behavior of various kinds of dynamic systems can be formalized using typed attributed graph transformation systems (GTSs). The states of these systems are then modelled using graphs and the evolution of the system from one state to another is described by a finite set of graph transformation rules. GTSs with small finite state spaces can be analyzed with ease but analysis is intractable\/undecidable for GTSs inducing large\/infinite state spaces due to the inherent expressiveness of GTSs. Hence, automatic analysis procedures do not terminate or return indefinite or incorrect results. We propose an analysis procedure for establishing state-invariants for GTSs that are given by nested graph conditions (GCs). To this end, we formalize a symbolic analysis algorithm based on k-induction using Isabelle, apply it to GTSs and GCs over typed attributed graphs, develop support to single out some spurious counterexamples, and demonstrate the feasibility of the approach using our prototypical implementation.","publish_time":1590883200000,"author_summary":" Schneider, Sven; Dyck, Johannes; Giese,<br>Holger","abstract_summary":" The behavior of various kinds of dynamic<br>systems can be formalized using typed attributed graph<br>transformation systems (GTSs). The states of these systems are<br>then modelled using graphs and the evolution of the<br>system from one state to another is described by a<br>finite set of graph transformation rules. GTSs with<br>small finite state spaces can be analyzed with ease<br>but analysis is intractable\/undecidable for GTSs<br>inducing large\/infinite state spaces due to the<br>inherent expressiveness of GTSs. Hence, automatic<br>analysis procedures do not terminate or return<br>indefinite or incorrect results. We propose an analysis<br>procedure for establishing state-invariants for GTSs...","title_summary":" Formal Verification of Invariants for<br>Attributed Graph Transformation Systems Based on Nested<br>Attributed Graph Conditions","x":-26.0097579956,"y":44.0978355408,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.0097579956,"tsne_y":44.0978355408,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"ttuoax9s","source_x":"PMC","title":"Make E Smart Again (Short Paper)","doi":"10.1007\/978-3-030-51054-1_26","abstract":"In this work in progress, we demonstrate a new use-case for the ENIGMA system. The ENIGMA system using the XGBoost implementation of gradient boosted decision trees has demonstrated high capability to learn to guide the E theorem prover\u2019s inferences in real-time. Here, we strip E to the bare bones: we replace the KBO term ordering with an identity relation as the minimal possible ordering, disable literal selection, and replace evolved strategies with a simple combination of the clause weight and FIFO (first in first out) clause evaluation functions. We experimentally demonstrate that ENIGMA can learn to guide E as well as the smart, evolved strategies even without these standard automated theorem prover functionalities. To this end, we experiment with XGBoost\u2019s meta-parameters over a dozen loops.","publish_time":1591401600000,"author_summary":" Goertzel, Zarathustra Amadeus","abstract_summary":" In this work in progress, we demonstrate a new<br>use-case for the ENIGMA system. The ENIGMA system using<br>the XGBoost implementation of gradient boosted<br>decision trees has demonstrated high capability to<br>learn to guide the E theorem prover\u2019s inferences in<br>real-time. Here, we strip E to the bare bones: we replace the<br>KBO term ordering with an identity relation as the<br>minimal possible ordering, disable literal<br>selection, and replace evolved strategies with a simple<br>combination of the clause weight and FIFO (first in first<br>out) clause evaluation functions. We<br>experimentally demonstrate that ENIGMA can learn to guide E as<br>well...","title_summary":" Make E Smart Again (Short Paper)","x":-25.9649009705,"y":43.6126747131,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.9649009705,"tsne_y":43.6126747131,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"f732f2kr","source_x":"PMC","title":"Teaching Automated Theorem Proving by Example: PyRes 1.2: (System Description)","doi":"10.1007\/978-3-030-51054-1_9","abstract":"PyRes is a complete theorem prover for classical first-order logic. It is not designed for high performance, but to clearly demonstrate the core concepts of a saturating theorem prover. The system is written in extensively commented Python, explaining data structures, algorithms, and many of the underlying theoretical concepts. The prover implements binary resolution with factoring and optional negative literal selection. Equality is handled by adding the basic axioms of equality. PyRes uses the given-clause algorithm, optionally controlled by weight- and age evaluations for clause selection. The prover can read TPTP CNF\/FOF input files and produces TPTP\/TSTP proof objects. Evaluation shows, as expected, mediocre performance compared to modern high-performance systems, with relatively better performance for problems without equality. However, the implementation seems to be sound and complete.","publish_time":1591401600000,"author_summary":" Schulz, Stephan; Pease, Adam","abstract_summary":" PyRes is a complete theorem prover for<br>classical first-order logic. It is not designed for high<br>performance, but to clearly demonstrate the core concepts of<br>a saturating theorem prover. The system is<br>written in extensively commented Python, explaining<br>data structures, algorithms, and many of the<br>underlying theoretical concepts. The prover implements<br>binary resolution with factoring and optional<br>negative literal selection. Equality is handled by<br>adding the basic axioms of equality. PyRes uses the<br>given-clause algorithm, optionally controlled by weight-<br>and age evaluations for clause selection. The<br>prover can read TPTP CNF\/FOF input files and produces<br>TPTP\/TSTP proof objects. Evaluation shows,...","title_summary":" Teaching Automated Theorem Proving by<br>Example: PyRes 1.2: (System Description)","x":-25.8237113953,"y":44.0822105408,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.8237113953,"tsne_y":44.0822105408,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"7x3rqrsv","source_x":"PMC","title":"A Programmer\u2019s Text Editor for a Logical Theory: The SUMOjEdit Editor (System Description)","doi":"10.1007\/978-3-030-51054-1_31","abstract":"SUMOjEdit is a programmer\u2019s text editor for the SUO-KIF language and SUMO http:\/\/www.ontologyportal.org theory. Modern procedural programming is done in a text editor with tool support. Development of ontologies and taxonomies has often been done in graphical editors, leading many developers to employ only logics of very limited expressiveness that can be manipulated visually. Developers in the theorem proving community typically work in text editors but often without the same degree of tool support that most programmers rely on. Beginners working with SUMO make some very predictable errors in syntax, logical formulation, and use of the library of theories. Many of these errors can be flagged during editing, resulting in reduced time to become a productive developer. An editor designed for working with SUMO has the potential to aid beginners and experienced SUMO developers.","publish_time":1591401600000,"author_summary":" Pease, Adam","abstract_summary":" SUMOjEdit is a programmer\u2019s text editor for the<br>SUO-KIF language and SUMO<br>http:\/\/www.ontologyportal.org theory. Modern procedural programming is done<br>in a text editor with tool support. Development of<br>ontologies and taxonomies has often been done in graphical<br>editors, leading many developers to employ only logics<br>of very limited expressiveness that can be<br>manipulated visually. Developers in the theorem proving<br>community typically work in text editors but often<br>without the same degree of tool support that most<br>programmers rely on. Beginners working with SUMO make some<br>very predictable errors in syntax, logical<br>formulation, and use of the library of theories. Many...","title_summary":" A Programmer\u2019s Text Editor for a Logical<br>Theory: The SUMOjEdit Editor (System Description)","x":-26.318561554,"y":44.0652923584,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.318561554,"tsne_y":44.0652923584,"subcluster":33,"subcluster_description":"Netsstructural Reductions Revisiteda Study","shape":"p"},{"cord_uid":"j9uc22uv","source_x":"PMC","title":"Prolog Technology Reinforcement Learning Prover: (System Description)","doi":"10.1007\/978-3-030-51054-1_33","abstract":"We present a reinforcement learning toolkit for experiments with guiding automated theorem proving in the connection calculus. The core of the toolkit is a compact and easy to extend Prolog-based automated theorem prover called plCoP. plCoP builds on the leanCoP Prolog implementation and adds learning-guided Monte-Carlo Tree Search as done in the rlCoP system. Other components include a Python interface to plCoP and machine learners, and an external proof checker that verifies the validity of plCoP proofs. The toolkit is evaluated on two benchmarks and we demonstrate its extendability by two additions: (1) guidance is extended to reduction steps and (2) the standard leanCoP calculus is extended with rewrite steps and their learned guidance. We argue that the Prolog setting is suitable for combining statistical and symbolic learning methods. The complete toolkit is publicly released.","publish_time":1591401600000,"author_summary":" Zombori, Zsolt; Urban, Josef; Brown, Chad E.","abstract_summary":" We present a reinforcement learning toolkit<br>for experiments with guiding automated theorem<br>proving in the connection calculus. The core of the<br>toolkit is a compact and easy to extend Prolog-based<br>automated theorem prover called plCoP. plCoP builds on<br>the leanCoP Prolog implementation and adds<br>learning-guided Monte-Carlo Tree Search as done in the rlCoP<br>system. Other components include a Python interface to<br>plCoP and machine learners, and an external proof<br>checker that verifies the validity of plCoP proofs. The<br>toolkit is evaluated on two benchmarks and we<br>demonstrate its extendability by two additions: (1)<br>guidance is extended to reduction steps and...","title_summary":" Prolog Technology Reinforcement Learning<br>Prover: (System Description)","x":-26.0099754333,"y":43.4689483643,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.0099754333,"tsne_y":43.4689483643,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"t8wjfo7o","source_x":"PMC","title":"A Polymorphic Vampire: (Short Paper)","doi":"10.1007\/978-3-030-51054-1_21","abstract":"We have modified the Vampire theorem prover to support rank-1 polymorphism. In this paper we discuss the changes required to enable this and compare the performance of polymorphic Vampire against other polymorphic provers. We also compare its performance on monomorphic problems against standard Vampire. Finally, we discuss how polymorphism can be used to support theory reasoning and present results related to this.","publish_time":1591401600000,"author_summary":" Bhayat, Ahmed; Reger, Giles","abstract_summary":" We have modified the Vampire theorem prover to<br>support rank-1 polymorphism. In this paper we discuss<br>the changes required to enable this and compare the<br>performance of polymorphic Vampire against other<br>polymorphic provers. We also compare its performance on<br>monomorphic problems against standard Vampire. Finally,<br>we discuss how polymorphism can be used to support<br>theory reasoning and present results related to this.","title_summary":" A Polymorphic Vampire: (Short Paper)","x":-25.3133678436,"y":45.5395774841,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3133678436,"tsne_y":45.5395774841,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"68b3pdht","source_x":"PMC","title":"Practical Proof Search for Coq by Type Inhabitation","doi":"10.1007\/978-3-030-51054-1_3","abstract":"We present a practical proof search procedure for Coq based on a direct search for type inhabitants in an appropriate normal form. The procedure is more general than any of the automation tactics natively available in Coq. It aims to handle as large a part of the Calculus of Inductive Constructions as practically feasible. For efficiency, our procedure is not complete for the entire Calculus of Inductive Constructions, but we prove completeness for a first-order fragment. Even in pure intuitionistic first-order logic, our procedure performs competitively. We implemented the procedure in a Coq plugin and evaluated it on a collection of Coq libraries, on CompCert, and on the ILTP library of first-order intuitionistic problems. The results are promising and indicate the viablility of our approach to general automated proof search for the Calculus of Inductive Constructions.","publish_time":1591401600000,"author_summary":" Czajka, \u0141ukasz","abstract_summary":" We present a practical proof search procedure<br>for Coq based on a direct search for type<br>inhabitants in an appropriate normal form. The procedure is<br>more general than any of the automation tactics<br>natively available in Coq. It aims to handle as large a<br>part of the Calculus of Inductive Constructions as<br>practically feasible. For efficiency, our procedure is not<br>complete for the entire Calculus of Inductive<br>Constructions, but we prove completeness for a first-order<br>fragment. Even in pure intuitionistic first-order<br>logic, our procedure performs competitively. We<br>implemented the procedure in a Coq plugin and evaluated it on<br>a collection...","title_summary":" Practical Proof Search for Coq by Type<br>Inhabitation","x":-25.4422397614,"y":44.4153862,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.4422397614,"tsne_y":44.4153862,"subcluster":39,"subcluster_description":"Feasibility Conditionslogic-Independent Proof Search","shape":"p"},{"cord_uid":"34fjvjkb","source_x":"PMC","title":"mu-term: Verify Termination Properties Automatically (System Description)","doi":"10.1007\/978-3-030-51054-1_28","abstract":"We report on the new version of mu-term, a tool for proving termination properties of variants of rewrite systems, including conditional, context-sensitive, equational, and order-sorted rewrite systems. We follow a unified, logic-based approach to describe rewriting computations. The automatic generation of logical models for suitable first-order theories and formulas provides a common basis to implement the proofs.","publish_time":1591401600000,"author_summary":" Guti\u00e9rrez, Ra\u00fal; Lucas, Salvador","abstract_summary":" We report on the new version of mu-term, a tool<br>for proving termination properties of variants of<br>rewrite systems, including conditional,<br>context-sensitive, equational, and order-sorted rewrite<br>systems. We follow a unified, logic-based approach to<br>describe rewriting computations. The automatic<br>generation of logical models for suitable first-order<br>theories and formulas provides a common basis to<br>implement the proofs.","title_summary":" mu-term: Verify Termination Properties<br>Automatically (System Description)","x":-26.1910438538,"y":44.2695426941,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.1910438538,"tsne_y":44.2695426941,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"9zdow49o","source_x":"PMC","title":"The Imandra Automated Reasoning System (System Description)","doi":"10.1007\/978-3-030-51054-1_30","abstract":"We describe Imandra, a modern computational logic theorem prover designed to bridge the gap between decision procedures such as SMT, semi-automatic inductive provers of the Boyer-Moore family like ACL2, and interactive proof assistants for typed higher-order logics. Imandra\u2019s logic is computational, based on a pure subset of OCaml in which all functions are terminating, with restrictions on types and higher-order functions that allow conjectures to be translated into multi-sorted first-order logic with theories, including arithmetic and datatypes. Imandra has novel features supporting large-scale industrial applications, including a seamless integration of bounded and unbounded verification, first-class computable counterexamples, efficiently executable models and a cloud-native architecture supporting live multiuser collaboration. The core reasoning mechanisms of Imandra are (i) a semi-complete procedure for finding models of formulas in the logic mentioned above, centered around the lazy expansion of recursive functions, (ii) an inductive waterfall and simplifier which \u201clifts\u201d many Boyer-Moore ideas to our typed higher-order setting. These mechanisms are tightly integrated and subject to many forms of user control.","publish_time":1591401600000,"author_summary":" Passmore, Grant; Cruanes, Simon; Ignatovich,<br>Denis; Aitken, Dave; Bray, Matt; Kagan, Elijah;<br>Kanishev, Kostya; Maclean, Ewen; Mometto, Nicola","abstract_summary":" We describe Imandra, a modern computational<br>logic theorem prover designed to bridge the gap<br>between decision procedures such as SMT,<br>semi-automatic inductive provers of the Boyer-Moore family<br>like ACL2, and interactive proof assistants for<br>typed higher-order logics. Imandra\u2019s logic is<br>computational, based on a pure subset of OCaml in which all<br>functions are terminating, with restrictions on types<br>and higher-order functions that allow<br>conjectures to be translated into multi-sorted<br>first-order logic with theories, including arithmetic and<br>datatypes. Imandra has novel features supporting<br>large-scale industrial applications, including a<br>seamless integration of bounded and unbounded<br>verification, first-class computable counterexamples,<br>efficiently executable models...","title_summary":" The Imandra Automated Reasoning System<br>(System Description)","x":-25.8691825867,"y":43.9128723145,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.8691825867,"tsne_y":43.9128723145,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"ioci6ekn","source_x":"PMC","title":"Algebraically Closed Fields in Isabelle\/HOL","doi":"10.1007\/978-3-030-51054-1_12","abstract":"A fundamental theorem states that every field admits an algebraically closed extension. Despite its central importance, this theorem has never before been formalised in a proof assistant. We fill this gap by documenting its formalisation in Isabelle\/HOL, describing the difficulties that impeded this development and their solutions.","publish_time":1591401600000,"author_summary":" de Vilhena, Paulo Em\u00edlio; Paulson, Lawrence C.","abstract_summary":" A fundamental theorem states that every field<br>admits an algebraically closed extension. Despite<br>its central importance, this theorem has never<br>before been formalised in a proof assistant. We fill<br>this gap by documenting its formalisation in<br>Isabelle\/HOL, describing the difficulties that impeded this<br>development and their solutions.","title_summary":" Algebraically Closed Fields in Isabelle\/HOL","x":-23.1099777222,"y":46.1914901733,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.1099777222,"tsne_y":46.1914901733,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"77nyal4w","source_x":"PMC","title":"Verifying Farad\u017eev-Read Type Isomorph-Free Exhaustive Generation","doi":"10.1007\/978-3-030-51054-1_16","abstract":"Many applications require generating catalogues of combinatorial objects, that do not contain isomorphs. Several efficient abstract schemes for this problem exist. One is described independently by I. A. Farad\u017eev and R. C. Read and has since been applied to catalogue many different combinatorial structures. We present an Isabelle\/HOL verification of this abstract scheme. To show its practicality, we instantiate it on two concrete problems: enumerating digraphs and enumerating union-closed families of sets. In the second example abstract algorithm specification is refined to an implementation that can quite efficiently enumerate all canonical union-closed families over a six element universe (there is more than 100 million such families).","publish_time":1591401600000,"author_summary":" Mari\u0107, Filip","abstract_summary":" Many applications require generating<br>catalogues of combinatorial objects, that do not contain<br>isomorphs. Several efficient abstract schemes for this<br>problem exist. One is described independently by I. A.<br>Farad\u017eev and R. C. Read and has since been applied to<br>catalogue many different combinatorial structures. We<br>present an Isabelle\/HOL verification of this abstract<br>scheme. To show its practicality, we instantiate it on<br>two concrete problems: enumerating digraphs and<br>enumerating union-closed families of sets. In the second<br>example abstract algorithm specification is refined<br>to an implementation that can quite efficiently<br>enumerate all canonical union-closed families over a six<br>element universe (there is...","title_summary":" Verifying Farad\u017eev-Read Type Isomorph-Free<br>Exhaustive Generation","x":-24.9595336914,"y":44.1082458496,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.9595336914,"tsne_y":44.1082458496,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"orql5n44","source_x":"PMC","title":"Implementing Superposition in iProver (System Description)","doi":"10.1007\/978-3-030-51054-1_24","abstract":"iProver is a saturation theorem prover for first-order logic with equality, which is originally based on an instantiation calculus Inst-Gen. In this paper we describe an extension of iProver with the superposition calculus. We have developed a flexible simplification setup that subsumes and generalises common architectures such as DISCOUNT or Otter. This also includes the concept of \u201cimmediate simplification\u201d, wherein newly derived clauses are more aggressively simplified among themselves, and the concept of \u201clight normalisation\u201d, wherein ground unit equations are stored in an interreduced TRS which is then used to simplify new clauses. We have also added support for associative-commutative theories (AC), namely by deletion of AC-joinable clauses, semantic detection of AC axioms, and preprocessing normalisation.","publish_time":1591401600000,"author_summary":" Duarte, Andr\u00e9; Korovin, Konstantin","abstract_summary":" iProver is a saturation theorem prover for<br>first-order logic with equality, which is originally based<br>on an instantiation calculus Inst-Gen. In this<br>paper we describe an extension of iProver with the<br>superposition calculus. We have developed a flexible<br>simplification setup that subsumes and generalises common<br>architectures such as DISCOUNT or Otter. This also includes<br>the concept of \u201cimmediate simplification\u201d,<br>wherein newly derived clauses are more aggressively<br>simplified among themselves, and the concept of \u201clight<br>normalisation\u201d, wherein ground unit equations are stored in an<br>interreduced TRS which is then used to simplify new clauses.<br>We have also added support for<br>associative-commutative...","title_summary":" Implementing Superposition in iProver<br>(System Description)","x":-25.7763633728,"y":44.268447876,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.7763633728,"tsne_y":44.268447876,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"0z3b087r","source_x":"PMC","title":"N-PAT: A Nested Model-Checker: (System Description)","doi":"10.1007\/978-3-030-51054-1_22","abstract":"N-PAT is a new model-checking tool that supports the verification of nested-models, i.e. models whose behaviour depends on the results of verification tasks. In this paper, we describe its operation and discuss mechanisms that are tailored to the efficient verification of nested-models. Further, we motivate the advantages of N-PAT over traditional model-checking tools through a network security case study.","publish_time":1591401600000,"author_summary":" Bride, Hadrien; Cai, Cheng-Hao; Dong, Jin<br>Song; Gore, Rajeev; H\u00f3u, Zh\u00e9; Mahony, Brendan;<br>McCarthy, Jim","abstract_summary":" N-PAT is a new model-checking tool that<br>supports the verification of nested-models, i.e.<br>models whose behaviour depends on the results of<br>verification tasks. In this paper, we describe its operation<br>and discuss mechanisms that are tailored to the<br>efficient verification of nested-models. Further, we<br>motivate the advantages of N-PAT over traditional<br>model-checking tools through a network security case study.","title_summary":" N-PAT: A Nested Model-Checker: (System<br>Description)","x":-26.9534797668,"y":43.7322235107,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.9534797668,"tsne_y":43.7322235107,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"4ipgdypq","source_x":"PMC","title":"Quotients of Bounded Natural Functors","doi":"10.1007\/978-3-030-51054-1_4","abstract":"The functorial structure of type constructors is the foundation for many definition and proof principles in higher-order logic (HOL). For example, inductive and coinductive datatypes can be built modularly from bounded natural functors (BNFs), a class of well-behaved type constructors. Composition, fixpoints, and\u2014under certain conditions\u2014subtypes are known to preserve the BNF structure. In this paper, we tackle the preservation question for quotients, the last important principle for introducing new types in HOL. We identify sufficient conditions under which a quotient inherits the BNF structure from its underlying type. We extend the Isabelle proof assistant with a command that automates the registration of a quotient type as a BNF by lifting the underlying type\u2019s BNF structure. We demonstrate the command\u2019s usefulness through several case studies.","publish_time":1591401600000,"author_summary":" F\u00fcrer, Basil; Lochbihler, Andreas;<br>Schneider, Joshua; Traytel, Dmitriy","abstract_summary":" The functorial structure of type constructors<br>is the foundation for many definition and proof<br>principles in higher-order logic (HOL). For example,<br>inductive and coinductive datatypes can be built<br>modularly from bounded natural functors (BNFs), a class<br>of well-behaved type constructors.<br>Composition, fixpoints, and\u2014under certain<br>conditions\u2014subtypes are known to preserve the BNF structure. In this<br>paper, we tackle the preservation question for<br>quotients, the last important principle for introducing<br>new types in HOL. We identify sufficient<br>conditions under which a quotient inherits the BNF<br>structure from its underlying type. We extend the<br>Isabelle proof assistant with a command that automates<br>the...","title_summary":" Quotients of Bounded Natural Functors","x":-24.2423648834,"y":45.2105751038,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.2423648834,"tsne_y":45.2105751038,"subcluster":14,"subcluster_description":"Orienting Combinator Equationsshort Q-Resolution","shape":"p"},{"cord_uid":"6cvi7f56","source_x":"PMC","title":"Reasoning About Algebraic Structures with Implicit Carriers in Isabelle\/HOL","doi":"10.1007\/978-3-030-51054-1_14","abstract":"We prove Chen and Gr\u00e4tzer\u2019s construction theorem for Stone algebras in Isabelle\/HOL. The development requires extensive reasoning about algebraic structures in addition to reasoning in algebraic structures. We present an approach for this using classes and locales with implicit carriers. This involves using function liftings to implement some aspects of dependent types and using embeddings of algebras to inherit theorems. We also formalise a theory of filters based on partial orders.","publish_time":1591401600000,"author_summary":" Guttmann, Walter","abstract_summary":" We prove Chen and Gr\u00e4tzer\u2019s construction<br>theorem for Stone algebras in Isabelle\/HOL. The<br>development requires extensive reasoning about algebraic<br>structures in addition to reasoning in algebraic<br>structures. We present an approach for this using classes<br>and locales with implicit carriers. This involves<br>using function liftings to implement some aspects of<br>dependent types and using embeddings of algebras to<br>inherit theorems. We also formalise a theory of filters<br>based on partial orders.","title_summary":" Reasoning About Algebraic Structures with<br>Implicit Carriers in Isabelle\/HOL","x":-23.8517818451,"y":45.826675415,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.8517818451,"tsne_y":45.826675415,"subcluster":16,"subcluster_description":"Strictly Local Tree Transducersequivalence","shape":"p"},{"cord_uid":"apshv9tr","source_x":"PMC","title":"HYPNO: Theorem Proving with Hypersequent Calculi for Non-normal Modal Logics (System Description)","doi":"10.1007\/978-3-030-51054-1_23","abstract":"We present HYPNO (HYpersequent Prover for NOn-normal modal logics), a Prolog-based theorem prover and countermodel generator for non-normal modal logics. HYPNO implements some hypersequent calculi recently introduced for the basic system [Formula: see text] and its extensions with axioms M, N, and C. It is inspired by the methodology of [Image: see text], so that it does not make use of any ad-hoc control mechanism. Given a formula, HYPNO provides either a proof in the calculus or a countermodel, directly built from an open saturated hypersequent. Preliminary experimental results show that the performances of HYPNO are very promising with respect to other theorem provers for the same class of logics.","publish_time":1591401600000,"author_summary":" Dalmonte, Tiziano; Olivetti, Nicola;<br>Pozzato, Gian Luca","abstract_summary":" We present HYPNO (HYpersequent Prover for<br>NOn-normal modal logics), a Prolog-based theorem prover<br>and countermodel generator for non-normal modal<br>logics. HYPNO implements some hypersequent calculi<br>recently introduced for the basic system [Formula: see<br>text] and its extensions with axioms M, N, and C. It is<br>inspired by the methodology of [Image: see text], so that<br>it does not make use of any ad-hoc control<br>mechanism. Given a formula, HYPNO provides either a proof<br>in the calculus or a countermodel, directly built<br>from an open saturated hypersequent. Preliminary<br>experimental results show that the performances of HYPNO are<br>very promising with respect...","title_summary":" HYPNO: Theorem Proving with Hypersequent<br>Calculi for Non-normal Modal Logics (System<br>Description)","x":-25.3404865265,"y":44.699382782,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3404865265,"tsne_y":44.699382782,"subcluster":38,"subcluster_description":"Proof Cyclesmechanised Modal Model","shape":"p"},{"cord_uid":"wtvlzctr","source_x":"PMC","title":"A Lean Tactic for Normalising Ring Expressions with Exponents (Short Paper)","doi":"10.1007\/978-3-030-51054-1_2","abstract":"This paper describes the design of the normalising tactic ring_exp for the Lean prover. This tactic improves on existing tactics by extending commutative rings with a binary exponent operator. An inductive family of types represents the normal form, enforcing various invariants. The design can also be extended with more operators.","publish_time":1591401600000,"author_summary":" Baanen, Anne","abstract_summary":" This paper describes the design of the<br>normalising tactic ring_exp for the Lean prover. This<br>tactic improves on existing tactics by extending<br>commutative rings with a binary exponent operator. An<br>inductive family of types represents the normal form,<br>enforcing various invariants. The design can also be<br>extended with more operators.","title_summary":" A Lean Tactic for Normalising Ring Expressions<br>with Exponents (Short Paper)","x":-24.6192150116,"y":46.0685310364,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.6192150116,"tsne_y":46.0685310364,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"p9wjfqkl","source_x":"PMC","title":"Automatically Proving and Disproving Feasibility Conditions","doi":"10.1007\/978-3-030-51054-1_27","abstract":"In the realm of term rewriting, given terms s and t, a reachability condition [Formula: see text] is called feasible if there is a substitution [Formula: see text] such that [Formula: see text] rewrites into [Formula: see text] in zero or more steps; otherwise, it is called infeasible. Checking infeasibility of (sequences of) reachability conditions is important in the analysis of computational properties of rewrite systems like confluence or (operational) termination. In this paper, we generalize this notion of feasibility to arbitrary n-ary relations on terms defined by first-order theories. In this way, properties of computational systems whose operational semantics can be given as a first-order theory can be investigated. We introduce a framework for proving feasibility\/infeasibility, and a new tool, infChecker, which implements it.","publish_time":1591401600000,"author_summary":" Guti\u00e9rrez, Ra\u00fal; Lucas, Salvador","abstract_summary":" In the realm of term rewriting, given terms s and<br>t, a reachability condition [Formula: see text]<br>is called feasible if there is a substitution<br>[Formula: see text] such that [Formula: see text]<br>rewrites into [Formula: see text] in zero or more steps;<br>otherwise, it is called infeasible. Checking<br>infeasibility of (sequences of) reachability conditions is<br>important in the analysis of computational properties of<br>rewrite systems like confluence or (operational)<br>termination. In this paper, we generalize this notion of<br>feasibility to arbitrary n-ary relations on terms defined<br>by first-order theories. In this way, properties<br>of computational systems whose operational<br>semantics...","title_summary":" Automatically Proving and Disproving<br>Feasibility Conditions","x":-25.6256465912,"y":44.3801956177,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.6256465912,"tsne_y":44.3801956177,"subcluster":39,"subcluster_description":"Feasibility Conditionslogic-Independent Proof Search","shape":"p"},{"cord_uid":"mv07zyan","source_x":"PMC","title":"Sequoia: A Playground for Logicians: (System Description)","doi":"10.1007\/978-3-030-51054-1_32","abstract":"Sequent calculus is a pervasive technique for studying logics and their properties due to the regularity of rules, proofs, and meta-property proofs across logics. However, even simple proofs can be large, and writing them by hand is often messy. Moreover, the combinatorial nature of the calculus makes it easy for humans to make mistakes or miss cases. Sequoia aims to alleviate these problems. Sequoia is a web-based application for specifying sequent calculi and performing basic reasoning about them. The goal is to be a user-friendly program, where logicians can specify and \u201cplay\u201d with their calculi. For that purpose, we provide an intuitive interface where inference rules can be input in [Image: see text] and are immediately rendered with the corresponding symbols. Users can then build proof trees in a streamlined and minimal-effort way, in whichever calculus they defined. In addition to that, we provide checks for some of the most important meta-theoretical properties, such as weakening admissibility and identity expansion, given that they proceed by the usual structural induction. In this sense, the logician is only left with the tricky and most interesting cases of each analysis.","publish_time":1591401600000,"author_summary":" Reis, Giselle; Naeem, Zan; Hashim, Mohammed","abstract_summary":" Sequent calculus is a pervasive technique for<br>studying logics and their properties due to the<br>regularity of rules, proofs, and meta-property proofs<br>across logics. However, even simple proofs can be<br>large, and writing them by hand is often messy.<br>Moreover, the combinatorial nature of the calculus makes<br>it easy for humans to make mistakes or miss cases.<br>Sequoia aims to alleviate these problems. Sequoia is a<br>web-based application for specifying sequent calculi<br>and performing basic reasoning about them. The<br>goal is to be a user-friendly program, where<br>logicians can specify and \u201cplay\u201d with their calculi. For<br>that purpose, we provide...","title_summary":" Sequoia: A Playground for Logicians: (System<br>Description)","x":-25.7037715912,"y":44.1756858826,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.7037715912,"tsne_y":44.1756858826,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"xt9wtqm6","source_x":"PMC","title":"Trakhtenbrot\u2019s Theorem in Coq: A Constructive Approach to Finite Model Theory","doi":"10.1007\/978-3-030-51054-1_5","abstract":"We study finite first-order satisfiability (FSAT) in the constructive setting of dependent type theory. Employing synthetic accounts of enumerability and decidability, we give a full classification of FSAT depending on the first-order signature of non-logical symbols. On the one hand, our development focuses on Trakhtenbrot\u2019s theorem, stating that FSAT is undecidable as soon as the signature contains an at least binary relation symbol. Our proof proceeds by a many-one reduction chain starting from the Post correspondence problem. On the other hand, we establish the decidability of FSAT for monadic first-order logic, i.e. where the signature only contains at most unary function and relation symbols, as well as the enumerability of FSAT for arbitrary enumerable signatures. All our results are mechanised in the framework of a growing Coq library of synthetic undecidability proofs.","publish_time":1591401600000,"author_summary":" Kirst, Dominik; Larchey-Wendling, Dominique","abstract_summary":" We study finite first-order satisfiability<br>(FSAT) in the constructive setting of dependent type<br>theory. Employing synthetic accounts of<br>enumerability and decidability, we give a full<br>classification of FSAT depending on the first-order signature<br>of non-logical symbols. On the one hand, our<br>development focuses on Trakhtenbrot\u2019s theorem, stating<br>that FSAT is undecidable as soon as the signature<br>contains an at least binary relation symbol. Our proof<br>proceeds by a many-one reduction chain starting from the<br>Post correspondence problem. On the other hand, we<br>establish the decidability of FSAT for monadic<br>first-order logic, i.e. where the signature only contains<br>at most unary...","title_summary":" Trakhtenbrot\u2019s Theorem in Coq: A Constructive<br>Approach to Finite Model Theory","x":-24.6889324188,"y":44.449508667,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.6889324188,"tsne_y":44.449508667,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"bqd7jq42","source_x":"PMC","title":"Formal Proof of the Group Law for Edwards Elliptic Curves","doi":"10.1007\/978-3-030-51054-1_15","abstract":"This article gives an elementary computational proof of the group law for Edwards elliptic curves. The associative law is expressed as a polynomial identity over the integers that is directly checked by polynomial division. Unlike other proofs, no preliminaries such as intersection numbers, B\u00e9zout\u2019s theorem, projective geometry, divisors, or Riemann Roch are required. The proof of the group law has been formalized in the Isabelle\/HOL proof assistant.","publish_time":1591401600000,"author_summary":" Hales, Thomas; Raya, Rodrigo","abstract_summary":" This article gives an elementary<br>computational proof of the group law for Edwards elliptic<br>curves. The associative law is expressed as a<br>polynomial identity over the integers that is directly<br>checked by polynomial division. Unlike other proofs,<br>no preliminaries such as intersection numbers,<br>B\u00e9zout\u2019s theorem, projective geometry, divisors, or<br>Riemann Roch are required. The proof of the group law has<br>been formalized in the Isabelle\/HOL proof<br>assistant.","title_summary":" Formal Proof of the Group Law for Edwards<br>Elliptic Curves","x":-21.8574237823,"y":46.1448974609,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.8574237823,"tsne_y":46.1448974609,"subcluster":26,"subcluster_description":"Symmetrykauffman Bracket Skein Module","shape":"p"},{"cord_uid":"75hcqhms","source_x":"PMC","title":"Formalization of Forcing in Isabelle\/ZF","doi":"10.1007\/978-3-030-51054-1_13","abstract":"We formalize the theory of forcing in the set theory framework of Isabelle\/ZF. Under the assumption of the existence of a countable transitive model of [Formula: see text] , we construct a proper generic extension and show that the latter also satisfies [Formula: see text] . In doing so, we remodularized Paulson\u2019s ZF-Constructibility library.","publish_time":1591401600000,"author_summary":" Gunther, Emmanuel; Pagano, Miguel; S\u00e1nchez<br>Terraf, Pedro","abstract_summary":" We formalize the theory of forcing in the set<br>theory framework of Isabelle\/ZF. Under the<br>assumption of the existence of a countable transitive<br>model of [Formula: see text] , we construct a proper<br>generic extension and show that the latter also<br>satisfies [Formula: see text] . In doing so, we<br>remodularized Paulson\u2019s ZF-Constructibility library.","title_summary":" Formalization of Forcing in Isabelle\/ZF","x":-24.125629425,"y":45.7623939514,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.125629425,"tsne_y":45.7623939514,"subcluster":16,"subcluster_description":"Strictly Local Tree Transducersequivalence","shape":"p"},{"cord_uid":"jb48ct8s","source_x":"PMC","title":"Verified Approximation Algorithms","doi":"10.1007\/978-3-030-51054-1_17","abstract":"We present the first formal verification of approximation algorithms for NP-complete optimization problems: vertex cover, independent set, load balancing, and bin packing. We uncover incompletenesses in existing proofs and improve the approximation ratio in one case.","publish_time":1591401600000,"author_summary":" E\u00dfmann, Robin; Nipkow, Tobias; Robillard,<br>Simon","abstract_summary":" We present the first formal verification of<br>approximation algorithms for NP-complete optimization<br>problems: vertex cover, independent set, load<br>balancing, and bin packing. We uncover incompletenesses<br>in existing proofs and improve the approximation<br>ratio in one case.","title_summary":" Verified Approximation Algorithms","x":-22.697435379,"y":46.851688385,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.697435379,"tsne_y":46.851688385,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"x9iwfcua","source_x":"PMC","title":"Extensible Extraction of Efficient Imperative Programs with Foreign Functions, Manually Managed Memory, and Proofs","doi":"10.1007\/978-3-030-51054-1_7","abstract":"We present an original approach to sound program extraction in a proof assistant, using syntax-driven automation to derive correct-by-construction imperative programs from nondeterministic functional source code. Our approach does not require committing to a single inflexible compilation strategy and instead makes it straightforward to create domain-specific code translators. In addition to a small set of core definitions, our framework is a large, user-extensible collection of compilation rules each phrased to handle specific language constructs, code patterns, or data manipulations. By mixing and matching these pieces of logic, users can easily tailor extraction to their own domains and programs, getting maximum performance and ensuring correctness of the resulting assembly code. Using this approach, we complete the first proof-generating pipeline that goes automatically from high-level specifications to assembly code. In our main case study, the original specifications are phrased to resemble SQL-style queries, while the final assembly code does manual memory management, calls out to foreign data structures and functions, and is suitable to deploy on resource-constrained platforms. The pipeline runs entirely within the Coq proof assistant, leading to final, linked assembly code with overall full-functional-correctness proofs in separation logic.","publish_time":1591401600000,"author_summary":" Pit-Claudel, Cl\u00e9ment; Wang, Peng; Delaware,<br>Benjamin; Gross, Jason; Chlipala, Adam","abstract_summary":" We present an original approach to sound<br>program extraction in a proof assistant, using<br>syntax-driven automation to derive<br>correct-by-construction imperative programs from nondeterministic<br>functional source code. Our approach does not require<br>committing to a single inflexible compilation strategy<br>and instead makes it straightforward to create<br>domain-specific code translators. In addition to a small set of<br>core definitions, our framework is a large,<br>user-extensible collection of compilation rules each phrased<br>to handle specific language constructs, code<br>patterns, or data manipulations. By mixing and matching<br>these pieces of logic, users can easily tailor<br>extraction to their own domains and programs, getting<br>maximum...","title_summary":" Extensible Extraction of Efficient<br>Imperative Programs with Foreign Functions, Manually<br>Managed Memory, and Proofs","x":-26.5193595886,"y":43.1393432617,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5193595886,"tsne_y":43.1393432617,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"m66dk8i6","source_x":"PMC","title":"MOIN: A Nested Sequent Theorem Prover for Intuitionistic Modal Logics (System Description)","doi":"10.1007\/978-3-030-51054-1_25","abstract":"We present a simple Prolog prover for intuitionistic modal logics based on nested sequent proof systems. We have implemented single-conclusion systems (Gentzen-style) and multi-conclusion systems (Maehara-style) for all logics in the intuitionistic modal IS5-cube. While the single-conclusion system are better investigated and have an internal cut-elimination, the multi-conclusion systems can provide a countermodel in case the proof search fails. To our knowledge this is the first automated theorem prover for intuitionistic modal logics. For wider usability, we also implemented classical normal modal logics in the S5-cube.","publish_time":1591401600000,"author_summary":" Girlando, Marianna; Stra\u00dfburger, Lutz","abstract_summary":" We present a simple Prolog prover for<br>intuitionistic modal logics based on nested sequent proof<br>systems. We have implemented single-conclusion<br>systems (Gentzen-style) and multi-conclusion<br>systems (Maehara-style) for all logics in the<br>intuitionistic modal IS5-cube. While the single-conclusion<br>system are better investigated and have an internal<br>cut-elimination, the multi-conclusion systems can provide a<br>countermodel in case the proof search fails. To our knowledge<br>this is the first automated theorem prover for<br>intuitionistic modal logics. For wider usability, we also<br>implemented classical normal modal logics in the S5-cube.","title_summary":" MOIN: A Nested Sequent Theorem Prover for<br>Intuitionistic Modal Logics (System Description)","x":-25.4175510406,"y":44.7498016357,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.4175510406,"tsne_y":44.7498016357,"subcluster":38,"subcluster_description":"Proof Cyclesmechanised Modal Model","shape":"p"},{"cord_uid":"r3iofe7p","source_x":"PMC","title":"Beyond Notations: Hygienic Macro Expansion for Theorem Proving Languages","doi":"10.1007\/978-3-030-51054-1_10","abstract":"In interactive theorem provers (ITPs), extensible syntax is not only crucial to lower the cognitive burden of manipulating complex mathematical objects, but plays a critical role in developing reusable abstractions in libraries. Most ITPs support such extensions in the form of restrictive \u201csyntax sugar\u201d substitutions and other ad hoc mechanisms, which are too rudimentary to support many desirable abstractions. As a result, libraries are littered with unnecessary redundancy. Tactic languages in these systems are plagued by a seemingly unrelated issue: accidental name capture, which often produces unexpected and counterintuitive behavior. We take ideas from the Scheme family of programming languages and solve these two problems simultaneously by proposing a novel hygienic macro system custom-built for ITPs. We further describe how our approach can be extended to cover type-directed macro expansion resulting in a single, uniform system offering multiple abstraction levels that range from supporting simplest syntax sugars to elaboration of formerly baked-in syntax. We have implemented our new macro system and integrated it into the upcoming version (v4) of the Lean theorem prover. Despite its expressivity, the macro system is simple enough that it can easily be integrated into other systems. ELECTRONIC SUPPLEMENTARY MATERIAL: The online version of this chapter (10.1007\/978-3-030-51054-1_10) contains supplementary material, which is available to authorized users.","publish_time":1591401600000,"author_summary":" Ullrich, Sebastian; de Moura, Leonardo","abstract_summary":" In interactive theorem provers (ITPs),<br>extensible syntax is not only crucial to lower the<br>cognitive burden of manipulating complex mathematical<br>objects, but plays a critical role in developing<br>reusable abstractions in libraries. Most ITPs support<br>such extensions in the form of restrictive \u201csyntax<br>sugar\u201d substitutions and other ad hoc mechanisms,<br>which are too rudimentary to support many desirable<br>abstractions. As a result, libraries are littered with<br>unnecessary redundancy. Tactic languages in these systems<br>are plagued by a seemingly unrelated issue:<br>accidental name capture, which often produces unexpected<br>and counterintuitive behavior. We take ideas from<br>the Scheme family of programming languages...","title_summary":" Beyond Notations: Hygienic Macro Expansion<br>for Theorem Proving Languages","x":-25.9487686157,"y":44.0034065247,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.9487686157,"tsne_y":44.0034065247,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"25d8fxlg","source_x":"PMC","title":"Efficient Verified Implementation of Introsort and Pdqsort","doi":"10.1007\/978-3-030-51054-1_18","abstract":"Sorting algorithms are an important part of most standard libraries, and both, their correctness and efficiency is crucial for many applications. As generic sorting algorithm, the GNU C++ Standard Library implements the introsort algorithm, a combination of quicksort, heapsort, and insertion sort. The Boost C++ Libraries implement pdqsort, an extension of introsort that achieves linear runtime on inputs with certain patterns. We verify introsort and pdqsort in the Isabelle LLVM verification framework, closely following the state-of-the-art implementations from GNU and Boost. On an extensive benchmark set, our verified implementations perform on par with the originals.","publish_time":1591401600000,"author_summary":" Lammich, Peter","abstract_summary":" Sorting algorithms are an important part of<br>most standard libraries, and both, their<br>correctness and efficiency is crucial for many<br>applications. As generic sorting algorithm, the GNU C++<br>Standard Library implements the introsort algorithm, a<br>combination of quicksort, heapsort, and insertion sort.<br>The Boost C++ Libraries implement pdqsort, an<br>extension of introsort that achieves linear runtime on<br>inputs with certain patterns. We verify introsort and<br>pdqsort in the Isabelle LLVM verification framework,<br>closely following the state-of-the-art<br>implementations from GNU and Boost. On an extensive benchmark<br>set, our verified implementations perform on par<br>with the originals.","title_summary":" Efficient Verified Implementation of<br>Introsort and Pdqsort","x":-26.4864521027,"y":42.1824150085,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.4864521027,"tsne_y":42.1824150085,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"u8wjxnw2","source_x":"PMC","title":"Validating Mathematical Structures","doi":"10.1007\/978-3-030-51054-1_8","abstract":"Sharing of notations and theories across an inheritance hierarchy of mathematical structures, e.g., groups and rings, is important for productivity when formalizing mathematics in proof assistants. The packed classes methodology is a generic design pattern to define and combine mathematical structures in a dependent type theory with records. When combined with mechanisms for implicit coercions and unification hints, packed classes enable automated structure inference and subtyping in hierarchies, e.g., that a ring can be used in place of a group. However, large hierarchies based on packed classes are challenging to implement and maintain. We identify two hierarchy invariants that ensure modularity of reasoning and predictability of inference with packed classes, and propose algorithms to check these invariants. We implement our algorithms as tools for the Coq proof assistant, and show that they significantly improve the development process of Mathematical Components, a library for formalized mathematics.","publish_time":1591401600000,"author_summary":" Sakaguchi, Kazuhiko","abstract_summary":" Sharing of notations and theories across an<br>inheritance hierarchy of mathematical structures, e.g.,<br>groups and rings, is important for productivity when<br>formalizing mathematics in proof assistants. The packed<br>classes methodology is a generic design pattern to<br>define and combine mathematical structures in a<br>dependent type theory with records. When combined with<br>mechanisms for implicit coercions and unification hints,<br>packed classes enable automated structure inference<br>and subtyping in hierarchies, e.g., that a ring can<br>be used in place of a group. However, large<br>hierarchies based on packed classes are challenging to<br>implement and maintain. We identify two hierarchy<br>invariants that ensure...","title_summary":" Validating Mathematical Structures","x":-25.9646396637,"y":44.1315994263,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.9646396637,"tsne_y":44.1315994263,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"lree4ldb","source_x":"PMC","title":"Competing Inheritance Paths in Dependent Type Theory: A Case Study in Functional Analysis","doi":"10.1007\/978-3-030-51054-1_1","abstract":"This paper discusses the design of a hierarchy of structures which combine linear algebra with concepts related to limits, like topology and norms, in dependent type theory. This hierarchy is the backbone of a new library of formalized classical analysis, for the Coq proof assistant. It extends the Mathematical Components library, geared towards algebra, with topics in analysis. Issues of a more general nature related to the inheritance of poorer structures from richer ones arise due to this combination. We present and discuss a solution, coined forgetful inheritance, based on packed classes and unification hints.","publish_time":1591401600000,"author_summary":" Affeldt, Reynald; Cohen, Cyril; Kerjean,<br>Marie; Mahboubi, Assia; Rouhling, Damien;<br>Sakaguchi, Kazuhiko","abstract_summary":" This paper discusses the design of a hierarchy<br>of structures which combine linear algebra with<br>concepts related to limits, like topology and norms, in<br>dependent type theory. This hierarchy is the backbone of a<br>new library of formalized classical analysis, for<br>the Coq proof assistant. It extends the<br>Mathematical Components library, geared towards algebra,<br>with topics in analysis. Issues of a more general<br>nature related to the inheritance of poorer<br>structures from richer ones arise due to this combination.<br>We present and discuss a solution, coined<br>forgetful inheritance, based on packed classes and<br>unification hints.","title_summary":" Competing Inheritance Paths in Dependent Type<br>Theory: A Case Study in Functional Analysis","x":-24.8284511566,"y":45.4840927124,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.8284511566,"tsne_y":45.4840927124,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"f4x76b9h","source_x":"PMC","title":"A Fast Verified Liveness Analysis in SSA Form","doi":"10.1007\/978-3-030-51054-1_19","abstract":"Liveness analysis is a standard compiler analysis, enabling several optimizations such as deadcode elimination. The SSA form is a popular compiler intermediate language allowing for simple and fast optimizations. Boissinot et al. [7] designed a fast liveness analysis by combining the specific properties of SSA with graph-theoretic ideas such as depth-first search and dominance. We formalize their approach in the Coq proof assistant, inside the CompCertSSA verified C compiler. We also compare experimentally this approach on CompCert\u2019s benchmarks with respect to the classic data-flow-based liveness analysis, and observe performance gains.","publish_time":1591401600000,"author_summary":" L\u00e9chenet, Jean-Christophe; Blazy, Sandrine;<br>Pichardie, David","abstract_summary":" Liveness analysis is a standard compiler<br>analysis, enabling several optimizations such as<br>deadcode elimination. The SSA form is a popular compiler<br>intermediate language allowing for simple and fast<br>optimizations. Boissinot et al. [7] designed a fast liveness<br>analysis by combining the specific properties of SSA<br>with graph-theoretic ideas such as depth-first<br>search and dominance. We formalize their approach in<br>the Coq proof assistant, inside the CompCertSSA<br>verified C compiler. We also compare experimentally<br>this approach on CompCert\u2019s benchmarks with<br>respect to the classic data-flow-based liveness<br>analysis, and observe performance gains.","title_summary":" A Fast Verified Liveness Analysis in SSA Form","x":-26.8111362457,"y":43.0706100464,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.8111362457,"tsne_y":43.0706100464,"subcluster":23,"subcluster_description":"Finite State Processesa Fast","shape":"p"},{"cord_uid":"irb9n4wz","source_x":"PMC","title":"Efficient Automated Reasoning About Sets and Multisets with Cardinality Constraints","doi":"10.1007\/978-3-030-51074-9_1","abstract":"When reasoning about container data structures that can hold duplicate elements, multisets are the obvious choice for representing the data structure abstractly. However, the decidability and complexity of constraints on multisets has been much less studied and understood than for constraints on sets. In this presentation, we outline an efficient decision procedure for reasoning about multisets with cardinality constraints. We describe how to translate, in linear time, multisets constraints to constraints in an extension of quantifier-free linear integer arithmetic, which we call LIA*. LIA* extends linear integer arithmetic with unbounded sums over values satisfying a given linear arithmetic formula. We show how to reduce a LIA* formula to an equisatisfiable linear integer arithmetic formula. However, this approach requires an explicit computation of semilinear sets and in practice it scales poorly even on simple benchmarks. We then describe a recent more efficient approach for checking satisfiability of LIA*. The approach is based on the use of under- and over-approximations of LIA* formulas. This way we avoid the space overhead and explicitly computing semilinear sets. Finally, we report on our prototype tool which can efficiently reason about sets and multisets formulas with cardinality constraints.","publish_time":1590796800000,"author_summary":" Piskac, Ruzica","abstract_summary":" When reasoning about container data<br>structures that can hold duplicate elements, multisets<br>are the obvious choice for representing the data<br>structure abstractly. However, the decidability and<br>complexity of constraints on multisets has been much less<br>studied and understood than for constraints on sets. In<br>this presentation, we outline an efficient<br>decision procedure for reasoning about multisets with<br>cardinality constraints. We describe how to translate, in<br>linear time, multisets constraints to constraints in<br>an extension of quantifier-free linear integer<br>arithmetic, which we call LIA*. LIA* extends linear integer<br>arithmetic with unbounded sums over values satisfying a<br>given linear arithmetic formula. We...","title_summary":" Efficient Automated Reasoning About Sets and<br>Multisets with Cardinality Constraints","x":-24.9190120697,"y":43.8177375793,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.9190120697,"tsne_y":43.8177375793,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"chwcgydw","source_x":"PMC","title":"Combined Covers and Beth Definability","doi":"10.1007\/978-3-030-51074-9_11","abstract":"Uniform interpolants were largely studied in non-classical propositional logics since the nineties, and their connection to model completeness was pointed out in the literature. A successive parallel research line inside the automated reasoning community investigated uniform quantifier-free interpolants (sometimes referred to as \u201ccovers\u201d) in first-order theories. In this paper, we investigate cover transfer to theory combinations in the disjoint signatures case. We prove that, for convex theories, cover algorithms can be transferred to theory combinations under the same hypothesis needed to transfer quantifier-free interpolation (i.e., the equality interpolating property, aka strong amalgamation property). The key feature of our algorithm relies on the extensive usage of the Beth definability property for primitive fragments to convert implicitly defined variables into their explicitly defining terms. In the non-convex case, we show by a counterexample that cover may not exist in the combined theories, even in case combined quantifier-free interpolants do exist.","publish_time":1590796800000,"author_summary":" Calvanese, Diego; Ghilardi, Silvio; Gianola,<br>Alessandro; Montali, Marco; Rivkin, Andrey","abstract_summary":" Uniform interpolants were largely studied in<br>non-classical propositional logics since the nineties, and<br>their connection to model completeness was pointed<br>out in the literature. A successive parallel<br>research line inside the automated reasoning community<br>investigated uniform quantifier-free interpolants<br>(sometimes referred to as \u201ccovers\u201d) in first-order<br>theories. In this paper, we investigate cover transfer to<br>theory combinations in the disjoint signatures case.<br>We prove that, for convex theories, cover<br>algorithms can be transferred to theory combinations<br>under the same hypothesis needed to transfer<br>quantifier-free interpolation (i.e., the equality<br>interpolating property, aka strong amalgamation property).<br>The key feature of our algorithm relies...","title_summary":" Combined Covers and Beth Definability","x":-24.6316795349,"y":44.2392158508,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.6316795349,"tsne_y":44.2392158508,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"tvir6fc4","source_x":"PMC","title":"Monadic Decomposition in Integer Linear Arithmetic","doi":"10.1007\/978-3-030-51074-9_8","abstract":"Monadic decomposability is a notion of variable independence, which asks whether a given formula in a first-order theory is expressible as a Boolean combination of monadic predicates in the theory. Recently, Veanes et al. showed the usefulness of monadic decomposability in the context of SMT (i.e. the input formula is quantifier-free), and found various interesting applications including string analysis. However, checking monadic decomposability is undecidable in general. Decidability for certain theories is known (e.g. Presburger Arithmetic, Tarski\u2019s Real-Closed Field), but there are very few results regarding their computational complexity. In this paper, we study monadic decomposability of integer linear arithmetic in the setting of SMT. We show that this decision problem is coNP-complete and, when monadically decomposable, a formula admits a decomposition of exponential size in the worst case. We provide a new application of our results to string constraint solving with length constraints. We then extend our results to variadic decomposability, where predicates could admit multiple free variables (in contrast to monadic decomposability). Finally, we give an application to quantifier elimination in integer linear arithmetic where the variables in a block of quantifiers, if independent, could be eliminated with an exponential (instead of the standard doubly exponential) blow-up.","publish_time":1590796800000,"author_summary":" Hague, Matthew; Lin, Anthony W.; R\u00fcmmer,<br>Philipp; Wu, Zhilin","abstract_summary":" Monadic decomposability is a notion of<br>variable independence, which asks whether a given<br>formula in a first-order theory is expressible as a<br>Boolean combination of monadic predicates in the<br>theory. Recently, Veanes et al. showed the usefulness<br>of monadic decomposability in the context of SMT<br>(i.e. the input formula is quantifier-free), and<br>found various interesting applications including<br>string analysis. However, checking monadic<br>decomposability is undecidable in general. Decidability for<br>certain theories is known (e.g. Presburger<br>Arithmetic, Tarski\u2019s Real-Closed Field), but there are<br>very few results regarding their computational<br>complexity. In this paper, we study monadic<br>decomposability of integer linear arithmetic...","title_summary":" Monadic Decomposition in Integer Linear<br>Arithmetic","x":-24.1087741852,"y":43.9523391724,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.1087741852,"tsne_y":43.9523391724,"subcluster":28,"subcluster_description":"Automata Networksmonadic Decomposition","shape":"p"},{"cord_uid":"fpvvulmv","source_x":"PMC","title":"Covered Clauses Are Not Propagation Redundant","doi":"10.1007\/978-3-030-51074-9_3","abstract":"Propositional proof systems based on recently-developed redundancy properties admit short refutations for many formulas traditionally considered hard. Redundancy properties are also used by procedures which simplify formulas in conjunctive normal form by removing redundant clauses. Revisiting the covered clause elimination procedure, we prove the correctness of an explicit algorithm for identifying covered clauses, as it has previously only been implicitly described. While other elimination procedures produce redundancy witnesses for compactly reconstructing solutions to the original formula, we prove that witnesses for covered clauses are hard to compute. Further, we show that not all covered clauses are propagation redundant, the most general, polynomially-verifiable standard redundancy property. Finally, we close a gap in the literature by demonstrating the complexity of clause redundancy itself.","publish_time":1590796800000,"author_summary":" Barnett, Lee A.; Cerna, David; Biere, Armin","abstract_summary":" Propositional proof systems based on<br>recently-developed redundancy properties admit short<br>refutations for many formulas traditionally considered<br>hard. Redundancy properties are also used by<br>procedures which simplify formulas in conjunctive normal<br>form by removing redundant clauses. Revisiting the<br>covered clause elimination procedure, we prove the<br>correctness of an explicit algorithm for identifying<br>covered clauses, as it has previously only been<br>implicitly described. While other elimination<br>procedures produce redundancy witnesses for compactly<br>reconstructing solutions to the original formula, we prove<br>that witnesses for covered clauses are hard to<br>compute. Further, we show that not all covered clauses<br>are propagation redundant, the most...","title_summary":" Covered Clauses Are Not Propagation Redundant","x":-25.3248119354,"y":44.0125236511,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3248119354,"tsne_y":44.0125236511,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"d6rg4ube","source_x":"PMC","title":"A Decision Procedure for String to Code Point Conversion","doi":"10.1007\/978-3-030-51074-9_13","abstract":"In text encoding standards such as Unicode, text strings are sequences of code points, each of which can be represented as a natural number. We present a decision procedure for a concatenation-free theory of strings that includes length and a conversion function from strings to integer code points. Furthermore, we show how many common string operations, such as conversions between lowercase and uppercase, can be naturally encoded using this conversion function. We describe our implementation of this approach in the SMT solver CVC4, which contains a high-performance string subsolver, and show that the use of a native procedure for code points significantly improves its performance with respect to other state-of-the-art string solvers.","publish_time":1590796800000,"author_summary":" Reynolds, Andrew; N\u00f6tzli, Andres; Barrett,<br>Clark; Tinelli, Cesare","abstract_summary":" In text encoding standards such as Unicode,<br>text strings are sequences of code points, each of<br>which can be represented as a natural number. We<br>present a decision procedure for a concatenation-free<br>theory of strings that includes length and a<br>conversion function from strings to integer code points.<br>Furthermore, we show how many common string operations, such<br>as conversions between lowercase and uppercase,<br>can be naturally encoded using this conversion<br>function. We describe our implementation of this<br>approach in the SMT solver CVC4, which contains a<br>high-performance string subsolver, and show that the use of a<br>native procedure for code...","title_summary":" A Decision Procedure for String to Code Point<br>Conversion","x":-24.5973548889,"y":43.5783538818,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.5973548889,"tsne_y":43.5783538818,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"mh2hyd82","source_x":"PMC","title":"Deciding Simple Infinity Axiom Sets with One Binary Relation by Means of Superpostulates","doi":"10.1007\/978-3-030-51074-9_12","abstract":"Modern logic engines widely fail to decide axiom sets that are satisfiable only in an infinite domain. This paper specifies an algorithm that automatically generates a database of independent infinity axiom sets with fewer than 1000 characters. It starts with complete theories of pure first-order logic with only one binary relation (FOL[Formula: see text]) and generates further infinity axiom sets S of FOL[Formula: see text] with fewer than 1000 characters such that no other infinity axiom set with fewer than 1000 characters exists in the database that implies S. We call the generated infinity axiom sets S \u201csuperpostulates\u201d. Any formula that is derivable from (satisfiable) superpostulates is also satisfiable. Thus far, we have generated a database with 2346 infinity superpostulates by running our algorithm. This paper ends by identifying three practical uses of the algorithmic generation of such a database: (i) for systematic investigations of infinity axiom sets, (ii) for deciding infinity axiom sets and (iii) for the development of saturation algorithms.","publish_time":1590796800000,"author_summary":" Lampert, Timm; Nakano, Anderson","abstract_summary":" Modern logic engines widely fail to decide<br>axiom sets that are satisfiable only in an infinite<br>domain. This paper specifies an algorithm that<br>automatically generates a database of independent infinity<br>axiom sets with fewer than 1000 characters. It starts<br>with complete theories of pure first-order logic<br>with only one binary relation (FOL[Formula: see<br>text]) and generates further infinity axiom sets S of<br>FOL[Formula: see text] with fewer than 1000 characters such<br>that no other infinity axiom set with fewer than 1000<br>characters exists in the database that implies S. We call<br>the generated infinity axiom sets S<br>\u201csuperpostulates\u201d. Any formula...","title_summary":" Deciding Simple Infinity Axiom Sets with One<br>Binary Relation by Means of Superpostulates","x":-24.8573455811,"y":44.5237960815,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.8573455811,"tsne_y":44.5237960815,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"m68sa88q","source_x":"PMC","title":"An SMT Theory of Fixed-Point Arithmetic","doi":"10.1007\/978-3-030-51074-9_2","abstract":"Fixed-point arithmetic is a popular alternative to floating-point arithmetic on embedded systems. Existing work on the verification of fixed-point programs relies on custom formalizations of fixed-point arithmetic, which makes it hard to compare the described techniques or reuse the implementations. In this paper, we address this issue by proposing and formalizing an SMT theory of fixed-point arithmetic. We present an intuitive yet comprehensive syntax of the fixed-point theory, and provide formal semantics for it based on rational arithmetic. We also describe two decision procedures for this theory: one based on the theory of bit-vectors and the other on the theory of reals. We implement the two decision procedures, and evaluate our implementations using existing mature SMT solvers on a benchmark suite we created. Finally, we perform a case study of using the theory we propose to verify properties of quantized neural networks.","publish_time":1590796800000,"author_summary":" Baranowski, Marek; He, Shaobo; Lechner,<br>Mathias; Nguyen, Thanh Son; Rakamari\u0107, Zvonimir","abstract_summary":" Fixed-point arithmetic is a popular<br>alternative to floating-point arithmetic on embedded<br>systems. Existing work on the verification of<br>fixed-point programs relies on custom formalizations of<br>fixed-point arithmetic, which makes it hard to compare the<br>described techniques or reuse the implementations. In<br>this paper, we address this issue by proposing and<br>formalizing an SMT theory of fixed-point arithmetic. We<br>present an intuitive yet comprehensive syntax of the<br>fixed-point theory, and provide formal semantics for it<br>based on rational arithmetic. We also describe two<br>decision procedures for this theory: one based on the<br>theory of bit-vectors and the other on the theory...","title_summary":" An SMT Theory of Fixed-Point Arithmetic","x":-25.2873573303,"y":41.7485313416,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.2873573303,"tsne_y":41.7485313416,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"l0x0dthn","source_x":"PMC","title":"The Resolution of Keller\u2019s Conjecture","doi":"10.1007\/978-3-030-51074-9_4","abstract":"We consider three graphs, [Formula: see text], [Formula: see text], and [Formula: see text], related to Keller\u2019s conjecture in dimension 7. The conjecture is false for this dimension if and only if at least one of the graphs contains a clique of size [Formula: see text]. We present an automated method to solve this conjecture by encoding the existence of such a clique as a propositional formula. We apply satisfiability solving combined with symmetry-breaking techniques to determine that no such clique exists. This result implies that every unit cube tiling of [Formula: see text] contains a facesharing pair of cubes. Since a faceshare-free unit cube tiling of [Formula: see text] exists (which we also verify), this completely resolves Keller\u2019s conjecture.","publish_time":1590796800000,"author_summary":" Brakensiek, Joshua; Heule, Marijn; Mackey,<br>John; Narv\u00e1ez, David","abstract_summary":" We consider three graphs, [Formula: see text],<br>[Formula: see text], and [Formula: see text], related to<br>Keller\u2019s conjecture in dimension 7. The conjecture is<br>false for this dimension if and only if at least one of<br>the graphs contains a clique of size [Formula: see<br>text]. We present an automated method to solve this<br>conjecture by encoding the existence of such a clique as a<br>propositional formula. We apply satisfiability solving<br>combined with symmetry-breaking techniques to<br>determine that no such clique exists. This result implies<br>that every unit cube tiling of [Formula: see text]<br>contains a facesharing pair of cubes....","title_summary":" The Resolution of Keller\u2019s Conjecture","x":-22.7484092712,"y":44.2350654602,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7484092712,"tsne_y":44.2350654602,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"q0ymyyaz","source_x":"PMC","title":"Deciding the Word Problem for Ground Identities with Commutative and Extensional Symbols","doi":"10.1007\/978-3-030-51074-9_10","abstract":"The word problem for a finite set of ground identities is known to be decidable in polynomial time, and this is also the case if some of the function symbols are assumed to be commutative. We show that decidability in P is preserved if we also assume that certain function symbols f are extensional in the sense that [Formula: see text] implies [Formula: see text]. In addition, we investigate a variant of extensionality that is more appropriate for commutative function symbols, but which raises the complexity of the word problem to coNP.","publish_time":1590796800000,"author_summary":" Baader, Franz; Kapur, Deepak","abstract_summary":" The word problem for a finite set of ground<br>identities is known to be decidable in polynomial time, and<br>this is also the case if some of the function symbols<br>are assumed to be commutative. We show that<br>decidability in P is preserved if we also assume that certain<br>function symbols f are extensional in the sense that<br>[Formula: see text] implies [Formula: see text]. In<br>addition, we investigate a variant of extensionality<br>that is more appropriate for commutative function<br>symbols, but which raises the complexity of the word<br>problem to coNP.","title_summary":" Deciding the Word Problem for Ground<br>Identities with Commutative and Extensional Symbols","x":-23.4992218018,"y":44.9492492676,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.4992218018,"tsne_y":44.9492492676,"subcluster":24,"subcluster_description":"Word Problem","shape":"p"},{"cord_uid":"12whn748","source_x":"PMC","title":"Scalable Algorithms for Abduction via Enumerative Syntax-Guided Synthesis","doi":"10.1007\/978-3-030-51074-9_9","abstract":"The abduction problem in logic asks whether there exists a formula that is consistent with a given set of axioms and, together with these axioms, suffices to entail a given goal. We propose an approach for solving this problem that is based on syntax-guided enumeration. For scalability, we use a novel procedure that incrementally constructs a solution in disjunctive normal form that is built from enumerated formulas. The procedure can be configured to generate progressively weaker and simpler solutions over the course of a run of the procedure. Our approach is fully general and can be applied over any background logic that is handled by the underlying SMT solver in our approach. Our experiments show our approach compares favorably with other tools for abductive reasoning.","publish_time":1590796800000,"author_summary":" Reynolds, Andrew; Barbosa, Haniel; Larraz,<br>Daniel; Tinelli, Cesare","abstract_summary":" The abduction problem in logic asks whether<br>there exists a formula that is consistent with a given<br>set of axioms and, together with these axioms,<br>suffices to entail a given goal. We propose an approach<br>for solving this problem that is based on<br>syntax-guided enumeration. For scalability, we use a novel<br>procedure that incrementally constructs a solution in<br>disjunctive normal form that is built from enumerated<br>formulas. The procedure can be configured to generate<br>progressively weaker and simpler solutions over the course of<br>a run of the procedure. Our approach is fully<br>general and can be applied over any background...","title_summary":" Scalable Algorithms for Abduction via<br>Enumerative Syntax-Guided Synthesis","x":-25.544801712,"y":43.9362449646,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.544801712,"tsne_y":43.9362449646,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"hazko015","source_x":"PMC","title":"Politeness for the Theory of Algebraic Datatypes","doi":"10.1007\/978-3-030-51074-9_14","abstract":"Algebraic datatypes, and among them lists and trees, have attracted a lot of interest in automated reasoning and Satisfiability Modulo Theories (SMT). Since its latest stable version, the SMT-LIB standard defines a theory of algebraic datatypes, which is currently supported by several mainstream SMT solvers. In this paper, we study this particular theory of datatypes and prove that it is strongly polite, showing also how it can be combined with other arbitrary disjoint theories using polite combination. Our results cover both inductive and finite datatypes, as well as their union. The combination method uses a new, simple, and natural notion of additivity, that enables deducing strong politeness from (weak) politeness.","publish_time":1590796800000,"author_summary":" Sheng, Ying; Zohar, Yoni; Ringeissen,<br>Christophe; Lange, Jane; Fontaine, Pascal; Barrett, Clark","abstract_summary":" Algebraic datatypes, and among them lists and<br>trees, have attracted a lot of interest in automated<br>reasoning and Satisfiability Modulo Theories (SMT).<br>Since its latest stable version, the SMT-LIB<br>standard defines a theory of algebraic datatypes, which<br>is currently supported by several mainstream SMT<br>solvers. In this paper, we study this particular theory<br>of datatypes and prove that it is strongly polite,<br>showing also how it can be combined with other arbitrary<br>disjoint theories using polite combination. Our<br>results cover both inductive and finite datatypes, as<br>well as their union. The combination method uses a<br>new, simple, and natural notion...","title_summary":" Politeness for the Theory of Algebraic<br>Datatypes","x":-25.3080291748,"y":44.7568588257,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3080291748,"tsne_y":44.7568588257,"subcluster":38,"subcluster_description":"Proof Cyclesmechanised Modal Model","shape":"p"},{"cord_uid":"kzy2cwuk","source_x":"PMC","title":"Removing Algebraic Data Types from Constrained Horn Clauses Using Difference Predicates","doi":"10.1007\/978-3-030-51074-9_6","abstract":"We address the problem of proving the satisfiability of Constrained Horn Clauses (CHCs) with Algebraic Data Types (ADTs), such as lists and trees. We propose a new technique for transforming CHCs with ADTs into CHCs where predicates are defined over basic types, such as integers and booleans, only. Thus, our technique avoids the explicit use of inductive proof rules during satisfiability proofs. The main extension over previous techniques for ADT removal is a new transformation rule, called differential replacement, which allows us to introduce auxiliary predicates corresponding to the lemmas used when making inductive proofs. We present an algorithm that applies the new rule, together with the traditional folding\/unfolding rules, for the automatic removal of ADTs. We prove that if the set of the transformed clauses is satisfiable, then so is the set of the original clauses. By an experimental evaluation, we show that the use of the new rule significantly improves the effectiveness of ADT removal, and that our approach is competitive with respect to a state-of-the-art tool that extends the CVC4 solver with induction.","publish_time":1590796800000,"author_summary":" De Angelis, Emanuele; Fioravanti, Fabio;<br>Pettorossi, Alberto; Proietti, Maurizio","abstract_summary":" We address the problem of proving the<br>satisfiability of Constrained Horn Clauses (CHCs) with<br>Algebraic Data Types (ADTs), such as lists and trees. We<br>propose a new technique for transforming CHCs with ADTs<br>into CHCs where predicates are defined over basic<br>types, such as integers and booleans, only. Thus, our<br>technique avoids the explicit use of inductive proof<br>rules during satisfiability proofs. The main<br>extension over previous techniques for ADT removal is a<br>new transformation rule, called differential<br>replacement, which allows us to introduce auxiliary<br>predicates corresponding to the lemmas used when making<br>inductive proofs. We present an algorithm that...","title_summary":" Removing Algebraic Data Types from<br>Constrained Horn Clauses Using Difference Predicates","x":-25.1877708435,"y":43.9218063354,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.1877708435,"tsne_y":43.9218063354,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"4lfqrt29","source_x":"PMC","title":"Solving Bitvectors with MCSAT: Explanations from Bits and Pieces","doi":"10.1007\/978-3-030-51074-9_7","abstract":"We present a decision procedure for the theory of fixed-sized bitvectors in the MCSAT framework. MCSAT is an alternative to CDCL(T) for SMT solving and can be seen as an extension of CDCL to domains other than the Booleans. Our procedure uses BDDs to record and update the sets of feasible values of bitvector variables. For explaining conflicts and propagations, we develop specialized word-level interpolation for two common fragments of the theory. For full generality, explaining conflicts outside of the covered fragments resorts to local bitblasting. The approach is implemented in the Yices 2 SMT solver and we present experimental results.","publish_time":1590796800000,"author_summary":" Graham-Lengrand, St\u00e9phane; Jovanovi\u0107,<br>Dejan; Dutertre, Bruno","abstract_summary":" We present a decision procedure for the theory<br>of fixed-sized bitvectors in the MCSAT<br>framework. MCSAT is an alternative to CDCL(T) for SMT<br>solving and can be seen as an extension of CDCL to domains<br>other than the Booleans. Our procedure uses BDDs to<br>record and update the sets of feasible values of<br>bitvector variables. For explaining conflicts and<br>propagations, we develop specialized word-level<br>interpolation for two common fragments of the theory. For full<br>generality, explaining conflicts outside of the covered<br>fragments resorts to local bitblasting. The approach is<br>implemented in the Yices 2 SMT solver and we present<br>experimental...","title_summary":" Solving Bitvectors with MCSAT: Explanations<br>from Bits and Pieces","x":-24.8701190948,"y":42.8833389282,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.8701190948,"tsne_y":42.8833389282,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"3ygklm4h","source_x":"PMC","title":"Formalizing the Face Lattice of Polyhedra","doi":"10.1007\/978-3-030-51054-1_11","abstract":"Faces play a central role in the combinatorial and computational aspects of polyhedra. In this paper, we present the first formalization of faces of polyhedra in the proof assistant Coq. This builds on the formalization of a library providing the basic constructions and operations over polyhedra, including projections, convex hulls and images under linear maps. Moreover, we design a special mechanism which automatically introduces an appropriate representation of a polyhedron or a face, depending on the context of the proof. We demonstrate the usability of this approach by establishing some of the most important combinatorial properties of faces, namely that they constitute a family of graded atomistic and coatomistic lattices closed under sublattices.","publish_time":1591401600000,"author_summary":" Allamigeon, Xavier; Katz, Ricardo D.; Strub,<br>Pierre-Yves","abstract_summary":" Faces play a central role in the combinatorial<br>and computational aspects of polyhedra. In this<br>paper, we present the first formalization of faces of<br>polyhedra in the proof assistant Coq. This builds on the<br>formalization of a library providing the basic constructions<br>and operations over polyhedra, including<br>projections, convex hulls and images under linear maps.<br>Moreover, we design a special mechanism which<br>automatically introduces an appropriate representation of a<br>polyhedron or a face, depending on the context of the proof.<br>We demonstrate the usability of this approach by<br>establishing some of the most important combinatorial<br>properties of faces, namely that...","title_summary":" Formalizing the Face Lattice of Polyhedra","x":-21.6544189453,"y":46.0103302002,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.6544189453,"tsne_y":46.0103302002,"subcluster":26,"subcluster_description":"Symmetrykauffman Bracket Skein Module","shape":"p"},{"cord_uid":"72a2ptc7","source_x":"PMC","title":"How QBF Expansion Makes Strategy Extraction Hard","doi":"10.1007\/978-3-030-51074-9_5","abstract":"In this paper we show that the QBF proof checking format QRAT (Quantified Resolution Asymmetric Tautologies) by Heule, Biere and Seidl cannot have polynomial time strategy extraction unless P=PSPACE. In our proof, the crucial property that makes strategy extraction PSPACE-hard for this proof format is universal expansion, even expansion on a single variable. While expansion reasoning used in other QBF calculi can admit polynomial time strategy extraction, we find this is conditional on a property studied in proof complexity theory. We show that strategy extraction on expansion based systems can only happen when the underlying propositional calculus has the property of feasible interpolation.","publish_time":1590796800000,"author_summary":" Chew, Leroy; Clymo, Judith","abstract_summary":" In this paper we show that the QBF proof checking<br>format QRAT (Quantified Resolution Asymmetric<br>Tautologies) by Heule, Biere and Seidl cannot have<br>polynomial time strategy extraction unless P=PSPACE. In<br>our proof, the crucial property that makes<br>strategy extraction PSPACE-hard for this proof format<br>is universal expansion, even expansion on a<br>single variable. While expansion reasoning used in<br>other QBF calculi can admit polynomial time strategy<br>extraction, we find this is conditional on a property<br>studied in proof complexity theory. We show that<br>strategy extraction on expansion based systems can only<br>happen when the underlying propositional calculus<br>has the property...","title_summary":" How QBF Expansion Makes Strategy Extraction<br>Hard","x":-25.3227424622,"y":44.1221160889,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3227424622,"tsne_y":44.1221160889,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"b4id8axc","source_x":"PMC","title":"Verification of Closest Pair of Points Algorithms","doi":"10.1007\/978-3-030-51054-1_20","abstract":"We verify two related divide-and-conquer algorithms solving one of the fundamental problems in Computational Geometry, the Closest Pair of Points problem. Using the interactive theorem prover Isabelle\/HOL, we prove functional correctness and the optimal running time of [Formula: see text] of the algorithms. We generate executable code which is empirically competitive with handwritten reference implementations.","publish_time":1591401600000,"author_summary":" Rau, Martin; Nipkow, Tobias","abstract_summary":" We verify two related divide-and-conquer<br>algorithms solving one of the fundamental problems in<br>Computational Geometry, the Closest Pair of Points problem.<br>Using the interactive theorem prover Isabelle\/HOL,<br>we prove functional correctness and the optimal<br>running time of [Formula: see text] of the algorithms.<br>We generate executable code which is empirically<br>competitive with handwritten reference implementations.","title_summary":" Verification of Closest Pair of Points<br>Algorithms","x":-22.5539779663,"y":46.5937728882,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.5539779663,"tsne_y":46.5937728882,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"epo2tnxt","source_x":"PMC","title":"Logic-Independent Proof Search in Logical Frameworks: (Short Paper)","doi":"10.1007\/978-3-030-51074-9_22","abstract":"Logical frameworks like LF allow to specify the syntax and (natural deduction) inference rules for syntax\/proof-checking a wide variety of logical systems. A crucial feature that is missing for prototyping logics is a way to specify basic proof automation. We try to alleviate this problem by generating [Formula: see text]Prolog (ELPI) inference predicates from logic specifications and controlling them by logic-independent helper predicates that encapsulate the prover characteristics. We show the feasibility of the approach with three experiments: We directly automate ND calculi, we generate tableau theorem provers and model generators.","publish_time":1590796800000,"author_summary":" Kohlhase, Michael; Rabe, Florian; Sacerdoti<br>Coen, Claudio; Schaefer, Jan Frederik","abstract_summary":" Logical frameworks like LF allow to specify the<br>syntax and (natural deduction) inference rules for<br>syntax\/proof-checking a wide variety of logical systems. A crucial<br>feature that is missing for prototyping logics is a way<br>to specify basic proof automation. We try to<br>alleviate this problem by generating [Formula: see<br>text]Prolog (ELPI) inference predicates from logic<br>specifications and controlling them by logic-independent<br>helper predicates that encapsulate the prover<br>characteristics. We show the feasibility of the approach with<br>three experiments: We directly automate ND calculi,<br>we generate tableau theorem provers and model<br>generators.","title_summary":" Logic-Independent Proof Search in Logical<br>Frameworks: (Short Paper)","x":-25.7051181793,"y":44.4270744324,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.7051181793,"tsne_y":44.4270744324,"subcluster":39,"subcluster_description":"Feasibility Conditionslogic-Independent Proof Search","shape":"p"},{"cord_uid":"11lronuw","source_x":"PMC","title":"Layered Clause Selection for Theory Reasoning: (Short Paper)","doi":"10.1007\/978-3-030-51074-9_23","abstract":"Explicit theory axioms are added by a saturation-based theorem prover as one of the techniques for supporting theory reasoning. While simple and effective, adding theory axioms can also pollute the search space with many irrelevant consequences. As a result, the prover often gets lost in parts of the search space where the chance to find a proof is low. In this paper, we describe a new strategy for controlling the amount of reasoning with explicit theory axioms. The strategy refines a recently proposed two-layer-queue clause selection and combines it with a heuristic measure of the amount of theory reasoning in the derivation of a clause. We implemented the new strategy in the automatic theorem prover Vampire and present an evaluation showing that our work dramatically improves the state-of-the-art clause-selection strategy in the presence of theory axioms.","publish_time":1590796800000,"author_summary":" Gleiss, Bernhard; Suda, Martin","abstract_summary":" Explicit theory axioms are added by a<br>saturation-based theorem prover as one of the techniques for<br>supporting theory reasoning. While simple and effective,<br>adding theory axioms can also pollute the search space<br>with many irrelevant consequences. As a result, the<br>prover often gets lost in parts of the search space<br>where the chance to find a proof is low. In this paper,<br>we describe a new strategy for controlling the<br>amount of reasoning with explicit theory axioms. The<br>strategy refines a recently proposed two-layer-queue<br>clause selection and combines it with a heuristic<br>measure of the amount of theory reasoning in...","title_summary":" Layered Clause Selection for Theory<br>Reasoning: (Short Paper)","x":-25.5044822693,"y":44.3121566772,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.5044822693,"tsne_y":44.3121566772,"subcluster":39,"subcluster_description":"Feasibility Conditionslogic-Independent Proof Search","shape":"p"},{"cord_uid":"kwlz1nw5","source_x":"PMC","title":"A CTL* Model Checker for Petri Nets","doi":"10.1007\/978-3-030-51831-8_21","abstract":"This tool paper describes RGMEDD*, a CTL* model checker that computes the set of states (sat-sets) of a Petri net that satisfy a CTL* formula. The tool can be used as a stand-alone program or from the GreatSPN graphical interface. The tool is based on the decision diagram library Meddly, it uses Spot to translate (sub)formulae into B\u00fcchi automata and a variation of the Emerson-Lei algorithm to compute the sat-sets. Correctness has been assessed based on the Model Checking Context 2018 results (for LTL and CTL queries), the sat-set computation of GreatSPN (for CTL) and LTSmin (for LTL), and the [Formula: see text]-calculus model checker of LTSmin for proper CTL* formulae (using a translator from CTL* to [Formula: see text]-calculus available in LTSmin). As far as we know, RGMEDD* is the only available B\u00fcchi-based CTL* model checker.","publish_time":1591056000000,"author_summary":" Amparore, Elvio Gilberto; Donatelli,<br>Susanna; Gall\u00e0, Francesco","abstract_summary":" This tool paper describes RGMEDD*, a CTL* model<br>checker that computes the set of states (sat-sets) of a<br>Petri net that satisfy a CTL* formula. The tool can be<br>used as a stand-alone program or from the GreatSPN<br>graphical interface. The tool is based on the decision<br>diagram library Meddly, it uses Spot to translate<br>(sub)formulae into B\u00fcchi automata and a variation of the<br>Emerson-Lei algorithm to compute the sat-sets.<br>Correctness has been assessed based on the Model Checking<br>Context 2018 results (for LTL and CTL queries), the<br>sat-set computation of GreatSPN (for CTL) and LTSmin<br>(for LTL), and the...","title_summary":" A CTL* Model Checker for Petri Nets","x":-26.6521968842,"y":44.1229019165,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6521968842,"tsne_y":44.1229019165,"subcluster":33,"subcluster_description":"Netsstructural Reductions Revisiteda Study","shape":"p"},{"cord_uid":"nadpokhb","source_x":"PMC","title":"PSPACE-Completeness of the Soundness Problem of Safe Asymmetric-Choice Workflow Nets","doi":"10.1007\/978-3-030-51831-8_10","abstract":"Asymmetric-choice workflow nets (ACWF-nets) are an important subclass of workflow nets (WF-nets) that can model and analyse business processes of many systems, especially the interactions among multiple processes. Soundness of WF-nets is a basic property guaranteeing that these business processes are deadlock-\/livelock-free and each designed action has a potential chance to be executed. Aalst et al. proved that the soundness problem is decidable for general WF-nets and proposed a polynomial algorithm to check the soundness for free-choice workflow nets (FCWF-nets) that are a special subclass of ACWF-nets. Tiplea et al. proved that for safe acyclic WF-nets the soundness problem is co-NP-complete, and we proved that for safe WF-nets the soundness problem is PSPACE-complete. We also proved that for safe ACWF-nets the soundness problem is co-NP-hard, but this paper sharpens this result by proving that for safe ACWF-nets this problem is PSPACE-complete actually. This paper provides a polynomial-time reduction from the acceptance problem of linear bounded automata (LBA) to the soundness problem of safe ACWF-nets. The kernel of the reduction is to guarantee that an LBA with an input string does not accept the input string if and only if the constructed safe ACWF-net is sound. Based on our reduction, we easily prove that the liveness problem of safe AC-nets is also PSPACE-complete, but the best result on this problem was NP-hardness provided by Ohta and Tsuji. Therefore, we also strengthen their result.","publish_time":1591056000000,"author_summary":" Liu, Guanjun","abstract_summary":" Asymmetric-choice workflow nets (ACWF-nets)<br>are an important subclass of workflow nets<br>(WF-nets) that can model and analyse business processes<br>of many systems, especially the interactions<br>among multiple processes. Soundness of WF-nets is a<br>basic property guaranteeing that these business<br>processes are deadlock-\/livelock-free and each<br>designed action has a potential chance to be executed.<br>Aalst et al. proved that the soundness problem is<br>decidable for general WF-nets and proposed a polynomial<br>algorithm to check the soundness for free-choice<br>workflow nets (FCWF-nets) that are a special subclass of<br>ACWF-nets. Tiplea et al. proved that for safe acyclic<br>WF-nets the soundness problem is...","title_summary":" PSPACE-Completeness of the Soundness Problem<br>of Safe Asymmetric-Choice Workflow Nets","x":-27.0711936951,"y":44.2760238647,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.0711936951,"tsne_y":44.2760238647,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"b79pvsb1","source_x":"PMC","title":"Automatic Decomposition of Petri Nets into Automata Networks \u2013 A Synthetic Account","doi":"10.1007\/978-3-030-51831-8_1","abstract":"This article revisits the problem of decomposing a Petri net into a network of automata, a problem that has been around since the early 70s. We reformulate this problem as the transformation of an ordinary, one-safe Petri net into a flat, unit-safe NUPN (Nested-Unit Petri Net) and define a quality criterion based on the number of bits required for the structural encoding of markings. We propose various transformation methods, all of which we implemented in a tool chain that combines NUPN tools with third-party software, such as SAT solvers, SMT solvers, and tools for graph colouring and finding maximal cliques. We perform an extensive evaluation of these methods on a collection of more than 12,000 nets from diverse sources, including nets whose marking graph is too large for being explored exhaustively.","publish_time":1591056000000,"author_summary":" Bouvier, Pierre; Garavel, Hubert;<br>Ponce-de-Le\u00f3n, Hern\u00e1n","abstract_summary":" This article revisits the problem of<br>decomposing a Petri net into a network of automata, a problem<br>that has been around since the early 70s. We<br>reformulate this problem as the transformation of an<br>ordinary, one-safe Petri net into a flat, unit-safe NUPN<br>(Nested-Unit Petri Net) and define a quality criterion based<br>on the number of bits required for the structural<br>encoding of markings. We propose various<br>transformation methods, all of which we implemented in a tool<br>chain that combines NUPN tools with third-party<br>software, such as SAT solvers, SMT solvers, and tools for<br>graph colouring and finding maximal cliques....","title_summary":" Automatic Decomposition of Petri Nets into<br>Automata Networks \u2013 A Synthetic Account","x":-26.5499038696,"y":44.5092086792,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5499038696,"tsne_y":44.5092086792,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"ul5wbej4","source_x":"PMC","title":"Piecewise Affine Dynamical Models of Timed Petri Nets \u2013 Application to Emergency Call Centers","doi":"10.1007\/978-3-030-51831-8_13","abstract":"We study timed Petri nets, with preselection and priority routing. We represent the behavior of these systems by piecewise affine dynamical systems. We use tools from the theory of nonexpansive mappings to analyze these systems. We establish an equivalence theorem between priority-free fluid timed Petri nets and semi-Markov decision processes, from which we derive the convergence to a periodic regime and the polynomial-time computability of the throughput. More generally, we develop an approach inspired by tropical geometry, characterizing the congestion phases as the cells of a polyhedral complex. We illustrate these results by a current application to the performance evaluation of emergency call centers in the Paris area.","publish_time":1591056000000,"author_summary":" Allamigeon, Xavier; Boyet, Marin; Gaubert,<br>St\u00e9phane","abstract_summary":" We study timed Petri nets, with preselection<br>and priority routing. We represent the behavior of<br>these systems by piecewise affine dynamical<br>systems. We use tools from the theory of nonexpansive<br>mappings to analyze these systems. We establish an<br>equivalence theorem between priority-free fluid timed<br>Petri nets and semi-Markov decision processes, from<br>which we derive the convergence to a periodic regime<br>and the polynomial-time computability of the<br>throughput. More generally, we develop an approach<br>inspired by tropical geometry, characterizing the<br>congestion phases as the cells of a polyhedral complex. We<br>illustrate these results by a current application to the<br>performance evaluation...","title_summary":" Piecewise Affine Dynamical Models of Timed<br>Petri Nets \u2013 Application to Emergency Call Centers","x":-27.181344986,"y":45.1112098694,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.181344986,"tsne_y":45.1112098694,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"01l0skgt","source_x":"PMC","title":"A New Property of Choice-Free Petri Net Systems","doi":"10.1007\/978-3-030-51831-8_5","abstract":"When a Petri net system of some class is synthesised from a labelled transition system, it may be interesting to derive structural properties of the corresponding reachability graphs and to use them in a pre-synthesis phase in order to quickly reject inadequate transition systems, and provide fruitful error messages. The same is true for simultaneous syntheses problems. This was exploited for the synthesis of choice-free nets for instance, for which several interesting properties have been derived. We exhibit here a new property for this class, and analyse if this gets us closer to a full characterisation of choice-free synthesizable transition systems.","publish_time":1591056000000,"author_summary":" Best, Eike; Devillers, Raymond; Erofeev,<br>Evgeny","abstract_summary":" When a Petri net system of some class is<br>synthesised from a labelled transition system, it may be<br>interesting to derive structural properties of the<br>corresponding reachability graphs and to use them in a<br>pre-synthesis phase in order to quickly reject inadequate<br>transition systems, and provide fruitful error messages.<br>The same is true for simultaneous syntheses<br>problems. This was exploited for the synthesis of<br>choice-free nets for instance, for which several<br>interesting properties have been derived. We exhibit here a<br>new property for this class, and analyse if this<br>gets us closer to a full characterisation of<br>choice-free synthesizable transition...","title_summary":" A New Property of Choice-Free Petri Net Systems","x":-26.857963562,"y":44.5985717773,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.857963562,"tsne_y":44.5985717773,"subcluster":37,"subcluster_description":"Coloured Petri Nets","shape":"p"},{"cord_uid":"pjnxv3zg","source_x":"PMC","title":"Subsumption Demodulation in First-Order Theorem Proving","doi":"10.1007\/978-3-030-51074-9_17","abstract":"Motivated by applications of first-order theorem proving to software analysis, we introduce a new inference rule, called subsumption demodulation, to improve support for reasoning with conditional equalities in superposition-based theorem proving. We show that subsumption demodulation is a simplification rule that does not require radical changes to the underlying superposition calculus. We implemented subsumption demodulation in the theorem prover Vampire, by extending Vampire with a new clause index and adapting its multi-literal matching component. Our experiments, using the TPTP and SMT-LIB repositories, show that subsumption demodulation in Vampire can solve many new problems that could so far not be solved by state-of-the-art reasoners.","publish_time":1590796800000,"author_summary":" Gleiss, Bernhard; Kov\u00e1cs, Laura; Rath, Jakob","abstract_summary":" Motivated by applications of first-order<br>theorem proving to software analysis, we introduce a<br>new inference rule, called subsumption<br>demodulation, to improve support for reasoning with<br>conditional equalities in superposition-based theorem<br>proving. We show that subsumption demodulation is a<br>simplification rule that does not require radical changes to<br>the underlying superposition calculus. We<br>implemented subsumption demodulation in the theorem<br>prover Vampire, by extending Vampire with a new clause<br>index and adapting its multi-literal matching<br>component. Our experiments, using the TPTP and SMT-LIB<br>repositories, show that subsumption demodulation in Vampire<br>can solve many new problems that could so far not be<br>solved...","title_summary":" Subsumption Demodulation in First-Order<br>Theorem Proving","x":-25.572271347,"y":44.4199142456,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.572271347,"tsne_y":44.4199142456,"subcluster":39,"subcluster_description":"Feasibility Conditionslogic-Independent Proof Search","shape":"p"},{"cord_uid":"2tcqmnga","source_x":"PMC","title":"Dynamic Recursive Petri Nets","doi":"10.1007\/978-3-030-51831-8_17","abstract":"In the early two-thousands, Recursive Petri nets (RPN) have been introduced in order to model distributed planning of multi-agent systems for which counters and recursivity were necessary. While having a great expressive power, RPN suffer two limitations: (1) they do not include more general features for transitions like reset arcs, transfer arcs, etc. (2) the initial marking associated with the recursive \u201ccall\u201d only depends on the calling transition and not on the current marking of the caller. Here we introduce Dynamic Recursive Petri nets (DRPN) which address these issues. We show that the standard extensions of Petri nets for which decidability of the coverability problem is preserved are particular cases of DPRN. Then we establish that w.r.t. coverability languages, DRPN are strictly more expressive than RPN. Finally we prove that the coverability problem is still decidable for DRPN.","publish_time":1591056000000,"author_summary":" Haddad, Serge; Khmelnitsky, Igor","abstract_summary":" In the early two-thousands, Recursive Petri<br>nets (RPN) have been introduced in order to model<br>distributed planning of multi-agent systems for which<br>counters and recursivity were necessary. While having a<br>great expressive power, RPN suffer two limitations:<br>(1) they do not include more general features for<br>transitions like reset arcs, transfer arcs, etc. (2) the<br>initial marking associated with the recursive \u201ccall\u201d<br>only depends on the calling transition and not on the<br>current marking of the caller. Here we introduce<br>Dynamic Recursive Petri nets (DRPN) which address<br>these issues. We show that the standard extensions of<br>Petri nets for which...","title_summary":" Dynamic Recursive Petri Nets","x":-26.4843482971,"y":44.3432922363,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.4843482971,"tsne_y":44.3432922363,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"d0l20uz9","source_x":"PMC","title":"SGGS Decision Procedures","doi":"10.1007\/978-3-030-51074-9_20","abstract":"SGGS (Semantically-Guided Goal-Sensitive reasoning) is a conflict-driven first-order theorem-proving method which is refutationally complete and model complete in the limit. These features make it attractive as a basis for decision procedures. In this paper we show that SGGS decides the stratified fragment which generalizes EPR, the PVD fragment, and a new fragment that we dub restrained. The new class has the small model property, as the size of SGGS-generated models can be upper-bounded, and is also decided by hyperresolution and ordered resolution. We report on experiments with a termination tool implementing a restrainedness test, and with an SGGS prototype named Koala.","publish_time":1590796800000,"author_summary":" Bonacina, Maria Paola; Winkler, Sarah","abstract_summary":" SGGS (Semantically-Guided Goal-Sensitive<br>reasoning) is a conflict-driven first-order<br>theorem-proving method which is refutationally complete and<br>model complete in the limit. These features make it<br>attractive as a basis for decision procedures. In this<br>paper we show that SGGS decides the stratified<br>fragment which generalizes EPR, the PVD fragment, and a<br>new fragment that we dub restrained. The new class<br>has the small model property, as the size of<br>SGGS-generated models can be upper-bounded, and is also<br>decided by hyperresolution and ordered resolution. We<br>report on experiments with a termination tool<br>implementing a restrainedness test, and with an SGGS<br>prototype named...","title_summary":" SGGS Decision Procedures","x":-25.9423351288,"y":43.8534126282,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.9423351288,"tsne_y":43.8534126282,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"wtzrmjfr","source_x":"PMC","title":"A Combinator-Based Superposition Calculus for Higher-Order Logic","doi":"10.1007\/978-3-030-51074-9_16","abstract":"We present a refutationally complete superposition calculus for a version of higher-order logic based on the combinatory calculus. We also introduce a novel method of dealing with extensionality. The calculus was implemented in the Vampire theorem prover and we test its performance against other leading higher-order provers. The results suggest that the method is competitive.","publish_time":1590796800000,"author_summary":" Bhayat, Ahmed; Reger, Giles","abstract_summary":" We present a refutationally complete<br>superposition calculus for a version of higher-order logic<br>based on the combinatory calculus. We also introduce<br>a novel method of dealing with extensionality.<br>The calculus was implemented in the Vampire<br>theorem prover and we test its performance against<br>other leading higher-order provers. The results<br>suggest that the method is competitive.","title_summary":" A Combinator-Based Superposition Calculus<br>for Higher-Order Logic","x":-24.3536777496,"y":45.8103179932,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.3536777496,"tsne_y":45.8103179932,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"uw8npjj7","source_x":"PMC","title":"Synthesis for Multi-weighted Games with Branching-Time Winning Conditions","doi":"10.1007\/978-3-030-51831-8_3","abstract":"We investigate the synthesis problem in a quantitative game-theoretic setting with branching-time objectives. The objectives are given in a recursive modal logic with semantics defined over a multi-weighted extension of a Kripke structure where each transition is annotated with multiple nonnegative weights representing quantitative resources such as discrete time, energy and cost. The objectives may express bounds on the accumulation of each resource both in a global scope and in a local scope (on subformulae) utilizing a reset operator. We show that both the model checking problem as well as the synthesis problem are decidable and that the model checking problem is EXPTIME-complete, while the synthesis problem is in 2-EXPTIME and is NEXPTIME-hard. Furthermore, we encode both problems to the calculation of maximal fixed points on dependency graphs, thus achieving on-the-fly algorithms with the possibility of early termination.","publish_time":1591056000000,"author_summary":" Kaufmann, Isabella; Larsen, Kim Guldstrand;<br>Srba, Ji\u0159\u00ed","abstract_summary":" We investigate the synthesis problem in a<br>quantitative game-theoretic setting with branching-time<br>objectives. The objectives are given in a recursive modal<br>logic with semantics defined over a multi-weighted<br>extension of a Kripke structure where each transition is<br>annotated with multiple nonnegative weights<br>representing quantitative resources such as discrete time,<br>energy and cost. The objectives may express bounds on<br>the accumulation of each resource both in a global<br>scope and in a local scope (on subformulae) utilizing<br>a reset operator. We show that both the model<br>checking problem as well as the synthesis problem are<br>decidable and that the model checking...","title_summary":" Synthesis for Multi-weighted Games with<br>Branching-Time Winning Conditions","x":-24.9425106049,"y":43.1941452026,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.9425106049,"tsne_y":43.1941452026,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"ewzwku2u","source_x":"PMC","title":"Efficient Unfolding of Coloured Petri Nets Using Interval Decision Diagrams","doi":"10.1007\/978-3-030-51831-8_16","abstract":"We consider coloured Petri nets, qualitative and quantitative ones alike, as supported by our PetriNuts tool family, comprising, among others, Snoopy, Marcie and Spike. Currently, most analysis and simulation techniques require to unfold the given coloured Petri net into its corresponding plain, uncoloured Petri net representation. This unfolding step is rather straightforward for finite discrete colour sets, but tends to be time-consuming due to the potentially huge number of possible transition bindings. We present an unfolding approach building on a special type of symbolic data structures, called Interval Decision Diagram, and compare its runtime performance with an unfolding engine employing an off-the-shelf library to solve constraint satisfaction problems. For this comparison we use the 22 scalable coloured models from the MCC benchmark suite, complemented by a few from our own collection.","publish_time":1591056000000,"author_summary":" Schwarick, Martin; Rohr, Christian; Liu, Fei;<br>Assaf, George; Chodak, Jacek; Heiner, Monika","abstract_summary":" We consider coloured Petri nets, qualitative<br>and quantitative ones alike, as supported by our<br>PetriNuts tool family, comprising, among others,<br>Snoopy, Marcie and Spike. Currently, most analysis and<br>simulation techniques require to unfold the given<br>coloured Petri net into its corresponding plain,<br>uncoloured Petri net representation. This unfolding step<br>is rather straightforward for finite discrete<br>colour sets, but tends to be time-consuming due to the<br>potentially huge number of possible transition bindings.<br>We present an unfolding approach building on a<br>special type of symbolic data structures, called<br>Interval Decision Diagram, and compare its runtime<br>performance with an unfolding engine employing...","title_summary":" Efficient Unfolding of Coloured Petri Nets<br>Using Interval Decision Diagrams","x":-26.9141712189,"y":44.5868682861,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.9141712189,"tsne_y":44.5868682861,"subcluster":37,"subcluster_description":"Coloured Petri Nets","shape":"p"},{"cord_uid":"kn4mdgxf","source_x":"PMC","title":"Formalizing a Seligman-Style Tableau System for Hybrid Logic: (Short Paper)","doi":"10.1007\/978-3-030-51074-9_27","abstract":"Hybrid logic is modal logic enriched with names for worlds. We formalize soundness and completeness proofs for a Seligman-style tableau system for hybrid logic in the proof assistant Isabelle\/HOL. The formalization shows how to lift certain rule restrictions, thereby simplifying the original un-formalized proof. Moreover, the completeness proof we formalize is synthetic which suggests we can extend this work to prove a wider range of results about hybrid logic.","publish_time":1590796800000,"author_summary":" From, Asta Halkj\u00e6r; Blackburn, Patrick;<br>Villadsen, J\u00f8rgen","abstract_summary":" Hybrid logic is modal logic enriched with names<br>for worlds. We formalize soundness and<br>completeness proofs for a Seligman-style tableau system for<br>hybrid logic in the proof assistant Isabelle\/HOL. The<br>formalization shows how to lift certain rule restrictions,<br>thereby simplifying the original un-formalized<br>proof. Moreover, the completeness proof we formalize<br>is synthetic which suggests we can extend this<br>work to prove a wider range of results about hybrid<br>logic.","title_summary":" Formalizing a Seligman-Style Tableau System<br>for Hybrid Logic: (Short Paper)","x":-25.3831291199,"y":44.825504303,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3831291199,"tsne_y":44.825504303,"subcluster":38,"subcluster_description":"Proof Cyclesmechanised Modal Model","shape":"p"},{"cord_uid":"k9vf3nli","source_x":"PMC","title":"The Information Systems Modeling Suite: Modeling the Interplay Between Information and Processes","doi":"10.1007\/978-3-030-51831-8_22","abstract":"According to our recent proposal, an information system is a combination of a process model captured as a Petri Net with Identifiers, an information model specified in the first-order logic over finite sets with equality, and a specification of how the transitions in the net manipulate information facts. The Information Systems Modeling (ISM) Suite is an integrated environment for developing, simulating, and analyzing models of information systems, released under an open-source license. This paper presents the basic features of the ISM Suite.","publish_time":1591056000000,"author_summary":" van der Werf, Jan Martijn E. M.; Polyvyanyy,<br>Artem","abstract_summary":" According to our recent proposal, an<br>information system is a combination of a process model<br>captured as a Petri Net with Identifiers, an information<br>model specified in the first-order logic over finite<br>sets with equality, and a specification of how the<br>transitions in the net manipulate information facts. The<br>Information Systems Modeling (ISM) Suite is an integrated<br>environment for developing, simulating, and analyzing<br>models of information systems, released under an<br>open-source license. This paper presents the basic<br>features of the ISM Suite.","title_summary":" The Information Systems Modeling Suite:<br>Modeling the Interplay Between Information and<br>Processes","x":-28.8643321991,"y":42.5363693237,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-28.8643321991,"tsne_y":42.5363693237,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"fe9xv1u4","source_x":"PMC","title":"A Knuth-Bendix-Like Ordering for Orienting Combinator Equations","doi":"10.1007\/978-3-030-51074-9_15","abstract":"We extend the graceful higher-order basic Knuth-Bendix order (KBO) of Becker et al. to an ordering that orients combinator equations left-to-right. The resultant ordering is highly suited to parameterising the first-order superposition calculus when dealing with the theory of higher-order logic, as it prevents inferences between the combinator axioms. We prove a number of desirable properties about the ordering including it having the subterm property for ground terms, being transitive and being well-founded. The ordering fails to be a reduction ordering as it lacks compatibility with certain contexts. We provide an intuition of why this need not be an obstacle when using it to parameterise superposition.","publish_time":1590796800000,"author_summary":" Bhayat, Ahmed; Reger, Giles","abstract_summary":" We extend the graceful higher-order basic<br>Knuth-Bendix order (KBO) of Becker et al. to an ordering that<br>orients combinator equations left-to-right. The<br>resultant ordering is highly suited to parameterising<br>the first-order superposition calculus when<br>dealing with the theory of higher-order logic, as it<br>prevents inferences between the combinator axioms. We<br>prove a number of desirable properties about the<br>ordering including it having the subterm property for<br>ground terms, being transitive and being<br>well-founded. The ordering fails to be a reduction ordering as<br>it lacks compatibility with certain contexts. We<br>provide an intuition of why this need not be an obstacle...","title_summary":" A Knuth-Bendix-Like Ordering for Orienting<br>Combinator Equations","x":-24.6010971069,"y":45.2637367249,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.6010971069,"tsne_y":45.2637367249,"subcluster":14,"subcluster_description":"Orienting Combinator Equationsshort Q-Resolution","shape":"p"},{"cord_uid":"k7s5kqky","source_x":"PMC","title":"MCC: A Tool for Unfolding Colored Petri Nets in PNML Format","doi":"10.1007\/978-3-030-51831-8_23","abstract":"MCC is a tool designed for a very specific task: to transform the models of High-Level Petri nets, given in the PNML syntax, into equivalent Place\/Transition nets. The name of the tool derives from the annual Model-Checking Contest, a competition of model-checking tools that provides a large and diverse collection of PNML models. This choice in naming serves to underline the main focus of the tool, which is to provide an open and efficient solution that lowers the access cost for developers wanting to engage in this competition. We describe the architecture and functionalities of our tool and show how it compares with other existing solutions. Despite the fact that the problem we target is abundantly covered in the literature, we show that it is still possible to innovate. To substantiate this assertion, we put a particular emphasis on two distinctive features of MCC that have proved useful when dealing with some of the most challenging colored models in the contest.","publish_time":1591056000000,"author_summary":" Dal Zilio, Silvano","abstract_summary":" MCC is a tool designed for a very specific task:<br>to transform the models of High-Level Petri nets,<br>given in the PNML syntax, into equivalent<br>Place\/Transition nets. The name of the tool derives from the<br>annual Model-Checking Contest, a competition of<br>model-checking tools that provides a large and diverse<br>collection of PNML models. This choice in naming serves to<br>underline the main focus of the tool, which is to provide an<br>open and efficient solution that lowers the access<br>cost for developers wanting to engage in this<br>competition. We describe the architecture and<br>functionalities of our tool and show how...","title_summary":" MCC: A Tool for Unfolding Colored Petri Nets in<br>PNML Format","x":-27.2028636932,"y":43.9423484802,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.2028636932,"tsne_y":43.9423484802,"subcluster":15,"subcluster_description":"Unfolding Colored Petri Nets","shape":"p"},{"cord_uid":"h7jgw07g","source_x":"PMC","title":"Cycl[Formula: see text]n \u2013 A Tool for Determining Stop-Transitions of Petri Nets","doi":"10.1007\/978-3-030-51831-8_20","abstract":"This paper introduces the tool Cycl[Formula: see text]n . The core functionality of Cycl[Formula: see text]n is to determine for a transition t of an unbounded Petri net whether or not t stops the net. A transition t stops the net (and is called a stop-transition) if each reachable marking of the net enables only finite occurrence sequences without occurrences of t. Cycl[Formula: see text]n provides a graphical user interface which also illustrates the graph structures leading to the computed result. This way, results are explained in a comprehensible manner, and the user gets a visual explanation of the cyclic behavior of the net causing these results.","publish_time":1591056000000,"author_summary":" Desel, J\u00f6rg; Finthammer, Marc; Frank, Andrea","abstract_summary":" This paper introduces the tool Cycl[Formula:<br>see text]n . The core functionality of<br>Cycl[Formula: see text]n is to determine for a transition t of<br>an unbounded Petri net whether or not t stops the<br>net. A transition t stops the net (and is called a<br>stop-transition) if each reachable marking of the net enables<br>only finite occurrence sequences without<br>occurrences of t. Cycl[Formula: see text]n provides a<br>graphical user interface which also illustrates the<br>graph structures leading to the computed result.<br>This way, results are explained in a comprehensible<br>manner, and the user gets a visual explanation of the<br>cyclic...","title_summary":" Cycl[Formula: see text]n \u2013 A Tool for<br>Determining Stop-Transitions of Petri Nets","x":-26.2186775208,"y":45.0118522644,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.2186775208,"tsne_y":45.0118522644,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"6itm44a6","source_x":"PMC","title":"Structural Reductions Revisited","doi":"10.1007\/978-3-030-51831-8_15","abstract":"Structural reductions are a powerful class of techniques that reason on a specification with the goal to reduce it before attempting to explore its behaviors. In this paper we present new structural reduction rules for verification of deadlock freedom and safety properties of Petri nets. These new rules are presented together with a large body of rules found in diverse literature. For some rules we leverage an SMT solver to compute if application conditions are met. We use a CEGAR approach based on progressively refining the classical state equation with new constraints, and memory-less exploration to confirm counter-examples. Extensive experimentation demonstrates the usefulness of this structural verification approach.","publish_time":1591056000000,"author_summary":" Thierry-Mieg, Yann","abstract_summary":" Structural reductions are a powerful class of<br>techniques that reason on a specification with the goal to<br>reduce it before attempting to explore its behaviors.<br>In this paper we present new structural reduction<br>rules for verification of deadlock freedom and<br>safety properties of Petri nets. These new rules are<br>presented together with a large body of rules found in<br>diverse literature. For some rules we leverage an SMT<br>solver to compute if application conditions are met.<br>We use a CEGAR approach based on progressively<br>refining the classical state equation with new<br>constraints, and memory-less exploration to confirm<br>counter-examples. Extensive experimentation...","title_summary":" Structural Reductions Revisited","x":-26.5247402191,"y":44.0926322937,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5247402191,"tsne_y":44.0926322937,"subcluster":33,"subcluster_description":"Netsstructural Reductions Revisiteda Study","shape":"p"},{"cord_uid":"12z1vmw5","source_x":"PMC","title":"SNexpression: A Symbolic Calculator for Symmetric Net Expressions","doi":"10.1007\/978-3-030-51831-8_19","abstract":"The paper presents SNexpression: a tool for the symbolic structural analysis of Symmetric Nets (SN). It can operate at a low level, handling expressions required to compute the structural properties of interest, but features also a net-based way of interaction allowing to submit commands referring directly to the net structure avoiding error prone input of low level expressions. The User Interface implements a command line interpreter and provides also a multi-page notebook to keep track of the submitted commands and their result.","publish_time":1591056000000,"author_summary":" Capra, Lorenzo; De Pierro, Massimiliano;<br>Franceschinis, Giuliana","abstract_summary":" The paper presents SNexpression: a tool for the<br>symbolic structural analysis of Symmetric Nets (SN). It<br>can operate at a low level, handling expressions<br>required to compute the structural properties of<br>interest, but features also a net-based way of<br>interaction allowing to submit commands referring<br>directly to the net structure avoiding error prone input<br>of low level expressions. The User Interface<br>implements a command line interpreter and provides also a<br>multi-page notebook to keep track of the submitted<br>commands and their result.","title_summary":" SNexpression: A Symbolic Calculator for<br>Symmetric Net Expressions","x":-26.1383171082,"y":44.298374176,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.1383171082,"tsne_y":44.298374176,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"66560790","source_x":"PMC","title":"Integrating Induction and Coinduction via Closure Operators and Proof Cycles","doi":"10.1007\/978-3-030-51074-9_21","abstract":"Coinductive reasoning about infinitary data structures has many applications in computer science. Nonetheless developing natural proof systems (especially ones amenable to automation) for reasoning about coinductive data remains a challenge. This paper presents a minimal, generic formal framework that uniformly captures applicable (i.e. finitary) forms of inductive and coinductive reasoning in an intuitive manner. The logic extends transitive closure logic, a general purpose logic for inductive reasoning based on the transitive closure operator, with a dual \u2018co-closure\u2019 operator that similarly captures applicable coinductive reasoning in a natural, effective manner. We develop a sound and complete non-well-founded proof system for the extended logic, whose cyclic subsystem provides the basis for an effective system for automated inductive and coinductive reasoning. To demonstrate the adequacy of the framework we show that it captures the canonical coinductive data type: streams.","publish_time":1590796800000,"author_summary":" Cohen, Liron; Rowe, Reuben N. S.","abstract_summary":" Coinductive reasoning about infinitary data<br>structures has many applications in computer science.<br>Nonetheless developing natural proof systems (especially<br>ones amenable to automation) for reasoning about<br>coinductive data remains a challenge. This paper presents a<br>minimal, generic formal framework that uniformly<br>captures applicable (i.e. finitary) forms of inductive<br>and coinductive reasoning in an intuitive manner.<br>The logic extends transitive closure logic, a<br>general purpose logic for inductive reasoning based on<br>the transitive closure operator, with a dual<br>\u2018co-closure\u2019 operator that similarly captures applicable<br>coinductive reasoning in a natural, effective manner. We<br>develop a sound and complete non-well-founded proof<br>system for the...","title_summary":" Integrating Induction and Coinduction via<br>Closure Operators and Proof Cycles","x":-25.3589477539,"y":44.598236084,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3589477539,"tsne_y":44.598236084,"subcluster":38,"subcluster_description":"Proof Cyclesmechanised Modal Model","shape":"p"},{"cord_uid":"jlnbgyzs","source_x":"PMC","title":"A Study on Team Bisimulations for BPP Nets","doi":"10.1007\/978-3-030-51831-8_8","abstract":"BPP nets, a subclass of finite P\/T nets, were equipped in [13] with an efficiently decidable, truly concurrent, behavioral equivalence, called team bisi-milarity. This equivalence is a very intuitive extension of classic bisimulation equivalence (over labeled transition systems) to BPP nets and it is checked in a distributed manner, without building a global model of the overall behavior of the marked BPP net. This paper has three goals. First, we provide BPP nets with various causality-based equivalences, notably a novel one, called causal-net bisimilarity, and (a version of) fully-concurrent bisimilarity [3]. Then, we define a variant equivalence, h-team bisimilarity, coarser than team bisimilarity. Then, we complete the study by comparing them with the causality-based semantics we have introduced: the main results are that team bisimilarity coincides with causal-net bisimilarity, while h-team bisimilarity with fully-concurrent bisimilarity.","publish_time":1591056000000,"author_summary":" Gorrieri, Roberto","abstract_summary":" BPP nets, a subclass of finite P\/T nets, were<br>equipped in [13] with an efficiently decidable, truly<br>concurrent, behavioral equivalence, called team<br>bisi-milarity. This equivalence is a very intuitive extension<br>of classic bisimulation equivalence (over<br>labeled transition systems) to BPP nets and it is<br>checked in a distributed manner, without building a<br>global model of the overall behavior of the marked BPP<br>net. This paper has three goals. First, we provide<br>BPP nets with various causality-based<br>equivalences, notably a novel one, called causal-net<br>bisimilarity, and (a version of) fully-concurrent<br>bisimilarity [3]. Then, we define a variant equivalence,<br>h-team bisimilarity, coarser...","title_summary":" A Study on Team Bisimulations for BPP Nets","x":-26.7022533417,"y":44.0933837891,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7022533417,"tsne_y":44.0933837891,"subcluster":33,"subcluster_description":"Netsstructural Reductions Revisiteda Study","shape":"p"},{"cord_uid":"fl999j54","source_x":"PMC","title":"Description Logics with Concrete Domains and General Concept Inclusions Revisited","doi":"10.1007\/978-3-030-51074-9_24","abstract":"Concrete domains have been introduced in the area of Description Logic to enable reference to concrete objects (such as numbers) and predefined predicates on these objects (such as numerical comparisons) when defining concepts. Unfortunately, in the presence of general concept inclusions (GCIs), which are supported by all modern DL systems, adding concrete domains may easily lead to undecidability. One contribution of this paper is to strengthen the existing undecidability results further by showing that concrete domains even weaker than the ones considered in the previous proofs may cause undecidability. To regain decidability in the presence of GCIs, quite strong restrictions, in sum called [Formula: see text]-admissibility, need to be imposed on the concrete domain. On the one hand, we generalize the notion of [Formula: see text]-admissibility from concrete domains with only binary predicates to concrete domains with predicates of arbitrary arity. On the other hand, we relate [Formula: see text]-admissibility to well-known notions from model theory. In particular, we show that finitely bounded, homogeneous structures yield [Formula: see text]-admissible concrete domains. This allows us to show [Formula: see text]-admissibility of concrete domains using existing results from model theory.","publish_time":1590796800000,"author_summary":" Baader, Franz; Rydval, Jakub","abstract_summary":" Concrete domains have been introduced in the<br>area of Description Logic to enable reference to<br>concrete objects (such as numbers) and predefined<br>predicates on these objects (such as numerical<br>comparisons) when defining concepts. Unfortunately, in the<br>presence of general concept inclusions (GCIs), which<br>are supported by all modern DL systems, adding<br>concrete domains may easily lead to undecidability. One<br>contribution of this paper is to strengthen the existing<br>undecidability results further by showing that concrete<br>domains even weaker than the ones considered in the<br>previous proofs may cause undecidability. To regain<br>decidability in the presence of GCIs, quite strong<br>restrictions,...","title_summary":" Description Logics with Concrete Domains and<br>General Concept Inclusions Revisited","x":-25.4067821503,"y":44.3290634155,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.4067821503,"tsne_y":44.3290634155,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"a7izel0u","source_x":"PMC","title":"Soft Subexponentials and Multiplexing","doi":"10.1007\/978-3-030-51074-9_29","abstract":"Linear logic and its refinements have been used as a specification language for a number of deductive systems. This has been accomplished by carefully studying the structural restrictions of linear logic modalities. Examples of such refinements are subexponentials, light linear logic, and soft linear logic. We bring together these refinements of linear logic in a non-commutative setting. We introduce a non-commutative substructural system with subexponential modalities controlled by a minimalistic set of rules. Namely, we disallow the contraction and weakening rules for the exponential modality and introduce two primitive subexponentials. One of the subexponentials allows the multiplexing rule in the style of soft linear logic and light linear logic. The second subexponential provides the exchange rule. For this system, we construct a sequent calculus, establish cut elimination, and also provide a complete focused proof system. We illustrate the expressive power of this system by simulating Turing computations and categorial grammar parsing for compound sentences. Using the former, we prove undecidability results. The new system employs Lambek\u2019s non-emptiness restriction, which is incompatible with the standard (sub)exponential setting. Lambek\u2019s restriction is crucial for applications in linguistics: without this restriction, categorial grammars incorrectly mark some ungrammatical phrases as being correct.","publish_time":1590796800000,"author_summary":" Kanovich, Max; Kuznetsov, Stepan; Nigam,<br>Vivek; Scedrov, Andre","abstract_summary":" Linear logic and its refinements have been used<br>as a specification language for a number of<br>deductive systems. This has been accomplished by<br>carefully studying the structural restrictions of<br>linear logic modalities. Examples of such<br>refinements are subexponentials, light linear logic, and<br>soft linear logic. We bring together these<br>refinements of linear logic in a non-commutative setting.<br>We introduce a non-commutative substructural<br>system with subexponential modalities controlled by<br>a minimalistic set of rules. Namely, we disallow<br>the contraction and weakening rules for the<br>exponential modality and introduce two primitive<br>subexponentials. One of the subexponentials allows the<br>multiplexing rule in the...","title_summary":" Soft Subexponentials and Multiplexing","x":-24.8499851227,"y":44.3675727844,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.8499851227,"tsne_y":44.3675727844,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"md4vp6m9","source_x":"PMC","title":"On the High Complexity of Petri Nets [Formula: see text]-Languages","doi":"10.1007\/978-3-030-51831-8_4","abstract":"We prove that [Formula: see text]-languages of (non-deterministic) Petri nets and [Formula: see text]-languages of (non-deterministic) Turing machines have the same topological complexity: the Borel and Wadge hierarchies of the class of [Formula: see text]-languages of (non-deterministic) Petri nets are equal to the Borel and Wadge hierarchies of the class of [Formula: see text]-languages of (non-deterministic) Turing machines. We also show that it is highly undecidable to determine the topological complexity of a Petri net [Formula: see text]-language. Moreover, we infer from the proofs of the above results that the equivalence and the inclusion problems for [Formula: see text]-languages of Petri nets are [Formula: see text]-complete, hence also highly undecidable.","publish_time":1591056000000,"author_summary":" Finkel, Olivier","abstract_summary":" We prove that [Formula: see text]-languages of<br>(non-deterministic) Petri nets and [Formula: see text]-languages<br>of (non-deterministic) Turing machines have the<br>same topological complexity: the Borel and Wadge<br>hierarchies of the class of [Formula: see text]-languages<br>of (non-deterministic) Petri nets are equal to<br>the Borel and Wadge hierarchies of the class of<br>[Formula: see text]-languages of (non-deterministic)<br>Turing machines. We also show that it is highly<br>undecidable to determine the topological complexity of a<br>Petri net [Formula: see text]-language. Moreover,<br>we infer from the proofs of the above results that<br>the equivalence and the inclusion problems for<br>[Formula: see text]-languages of...","title_summary":" On the High Complexity of Petri Nets [Formula:<br>see text]-Languages","x":-23.5718955994,"y":44.4385223389,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.5718955994,"tsne_y":44.4385223389,"subcluster":35,"subcluster_description":"Semi-Simple Splicing Systemsthe State","shape":"p"},{"cord_uid":"x7zl8a9j","source_x":"PMC","title":"Circular Traffic Queues and Petri\u2019s Cycloids","doi":"10.1007\/978-3-030-51831-8_9","abstract":"Two sorts of circular traffic systems are defined and their minimal length of recurrent transition sequences is computed. The result is used for finding cycloids that have an isomorphic reachability graph. Cycloids are particular Petri nets for modelling processes of actions or events, belonging to the fundaments of Petri\u2019s general systems theory. They have very different interpretations, ranging from Einstein\u2019s relativity theory to elementary information processing gates. The cycloid representation of circular traffic systems allows to identify basic synchronisation mechanisms and leads to a structure theory of such systems.","publish_time":1591056000000,"author_summary":" Valk, R\u00fcdiger","abstract_summary":" Two sorts of circular traffic systems are<br>defined and their minimal length of recurrent<br>transition sequences is computed. The result is used for<br>finding cycloids that have an isomorphic reachability<br>graph. Cycloids are particular Petri nets for<br>modelling processes of actions or events, belonging to<br>the fundaments of Petri\u2019s general systems theory.<br>They have very different interpretations, ranging<br>from Einstein\u2019s relativity theory to elementary<br>information processing gates. The cycloid representation<br>of circular traffic systems allows to identify<br>basic synchronisation mechanisms and leads to a<br>structure theory of such systems.","title_summary":" Circular Traffic Queues and Petri\u2019s Cycloids","x":-26.7289981842,"y":45.0424690247,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7289981842,"tsne_y":45.0424690247,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"nexvk07k","source_x":"PMC","title":"On-the-Fly Synthesis for Strictly Alternating Games","doi":"10.1007\/978-3-030-51831-8_6","abstract":"We study two-player zero-sum infinite reachability games with strictly alternating moves of the players allowing us to model a race between the two opponents. We develop an algorithm for deciding the winner of the game and suggest a notion of alternating simulation in order to speed up the computation of the winning strategy. The theory is applied to Petri net games, where the strictly alternating games are in general undecidable. We consider soft bounds on Petri net places in order to achieve decidability and implement the algorithms in our prototype tool. Finally, we compare the performance of our approach with an algorithm proposed in the seminal work by Liu and Smolka for calculating the minimum fixed points on dependency graphs. The results show that using alternating simulation almost always improves the performance in time and space and with exponential gain in some examples. Moreover, we show that there are Petri net games where our algorithm with alternating simulation terminates, whereas the algorithm without the alternating simulation loops for any possible search order.","publish_time":1591056000000,"author_summary":" Karra, Shyam Lal; Larsen, Kim Guldstrand;<br>Mu\u00f1iz, Marco; Srba, Ji\u0159\u00ed","abstract_summary":" We study two-player zero-sum infinite<br>reachability games with strictly alternating moves of the<br>players allowing us to model a race between the two<br>opponents. We develop an algorithm for deciding the winner<br>of the game and suggest a notion of alternating<br>simulation in order to speed up the computation of the<br>winning strategy. The theory is applied to Petri net<br>games, where the strictly alternating games are in<br>general undecidable. We consider soft bounds on Petri<br>net places in order to achieve decidability and<br>implement the algorithms in our prototype tool. Finally,<br>we compare the performance of our approach with...","title_summary":" On-the-Fly Synthesis for Strictly<br>Alternating Games","x":-24.4687080383,"y":42.8371925354,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.4687080383,"tsne_y":42.8371925354,"subcluster":10,"subcluster_description":"Winning Strategieson-The-Fly","shape":"p"},{"cord_uid":"ib4jf7dw","source_x":"PMC","title":"NP Reasoning in the Monotone [Formula: see text]-Calculus","doi":"10.1007\/978-3-030-51074-9_28","abstract":"Satisfiability checking for monotone modal logic is known to be (only) NP-complete. We show that this remains true when the logic is extended with alternation-free fixpoint operators as well as the universal modality; the resulting logic \u2013 the alternation-free monotone [Formula: see text]-calculus with the universal modality \u2013 contains both concurrent propositional dynamic logic (CPDL) and the alternation-free fragment of game logic as fragments. We obtain our result from a characterization of satisfiability by means of B\u00fcchi games with polynomially many Eloise nodes.","publish_time":1590796800000,"author_summary":" Hausmann, Daniel; Schr\u00f6der, Lutz","abstract_summary":" Satisfiability checking for monotone modal<br>logic is known to be (only) NP-complete. We show that<br>this remains true when the logic is extended with<br>alternation-free fixpoint operators as well as the universal<br>modality; the resulting logic \u2013 the alternation-free<br>monotone [Formula: see text]-calculus with the<br>universal modality \u2013 contains both concurrent<br>propositional dynamic logic (CPDL) and the alternation-free<br>fragment of game logic as fragments. We obtain our result<br>from a characterization of satisfiability by means<br>of B\u00fcchi games with polynomially many Eloise<br>nodes.","title_summary":" NP Reasoning in the Monotone [Formula: see<br>text]-Calculus","x":-24.9617347717,"y":44.7294464111,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.9617347717,"tsne_y":44.7294464111,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"wtbg8yvw","source_x":"PMC","title":"Interleaving vs True Concurrency: Some Instructive Security Examples","doi":"10.1007\/978-3-030-51831-8_7","abstract":"Information flow security properties were defined some years ago in terms of suitable equivalence checking problems. These definitions were provided by using sequential models of computations (e.g., labeled transition systems [17, 26]), and interleaving behavioral equivalences (e.g., bisimulation equivalence [27]). More recently, the distributed model of Petri nets has been used to study non-interference in [1, 5, 6], but also in these papers an interleaving semantics was used. By exploiting a simple process algebra, called CFM [18] and equipped with a Petri net semantics, we provide some examples showing that team equivalence, a truly-concurrent behavioral equivalence proposed in [19, 20], is much more suitable to define information flow security properties. The distributed non-interference property we propose, called DNI, is very easily checkable on CFM processes, as it is compositional, so that it does not suffer from the state-space explosion problem. Moreover, DNI is characterized syntactically on CFM by means of a type system.","publish_time":1591056000000,"author_summary":" Gorrieri, Roberto","abstract_summary":" Information flow security properties were<br>defined some years ago in terms of suitable equivalence<br>checking problems. These definitions were provided by<br>using sequential models of computations (e.g.,<br>labeled transition systems [17, 26]), and<br>interleaving behavioral equivalences (e.g., bisimulation<br>equivalence [27]). More recently, the distributed model of<br>Petri nets has been used to study non-interference in<br>[1, 5, 6], but also in these papers an interleaving<br>semantics was used. By exploiting a simple process<br>algebra, called CFM [18] and equipped with a Petri net<br>semantics, we provide some examples showing that team<br>equivalence, a truly-concurrent behavioral equivalence<br>proposed in [19, 20],...","title_summary":" Interleaving vs True Concurrency: Some<br>Instructive Security Examples","x":-26.5288505554,"y":43.777141571,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5288505554,"tsne_y":43.777141571,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"wn3j6k4z","source_x":"PMC","title":"A Comprehensive Framework for Saturation Theorem Proving","doi":"10.1007\/978-3-030-51074-9_18","abstract":"We present a framework for formal refutational completeness proofs of abstract provers that implement saturation calculi, such as ordered resolution or superposition. The framework relies on modular extensions of lifted redundancy criteria. It allows us to extend redundancy criteria so that they cover subsumption, and also to model entire prover architectures in such a way that the static refutational completeness of a calculus immediately implies the dynamic refutational completeness of a prover implementing the calculus, for instance within an Otter or [Image: see text] loop. Our framework is mechanized in Isabelle\/ [Image: see text] .","publish_time":1590796800000,"author_summary":" Waldmann, Uwe; Tourret, Sophie; Robillard,<br>Simon; Blanchette, Jasmin","abstract_summary":" We present a framework for formal refutational<br>completeness proofs of abstract provers that implement<br>saturation calculi, such as ordered resolution or<br>superposition. The framework relies on modular extensions of<br>lifted redundancy criteria. It allows us to extend<br>redundancy criteria so that they cover subsumption, and<br>also to model entire prover architectures in such a<br>way that the static refutational completeness of a<br>calculus immediately implies the dynamic refutational<br>completeness of a prover implementing the calculus, for<br>instance within an Otter or [Image: see text] loop. Our<br>framework is mechanized in Isabelle\/ [Image: see text] .","title_summary":" A Comprehensive Framework for Saturation<br>Theorem Proving","x":-25.6097869873,"y":44.546459198,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.6097869873,"tsne_y":44.546459198,"subcluster":39,"subcluster_description":"Feasibility Conditionslogic-Independent Proof Search","shape":"p"},{"cord_uid":"jppwhf0j","source_x":"PMC","title":"Possible Models Computation and Revision \u2013 A Practical Approach","doi":"10.1007\/978-3-030-51074-9_19","abstract":"This paper describes a method of computing plausible states of a system as a logical model. The problem of analyzing state-based systems as they evolve over time has been studied widely in the automated reasoning community (and others). This paper proposes a specific approach, one that is tailored to situational awareness applications. The main contribution is a calculus for a novel specification language that is built around disjunctive logic programming under a possible models semantics, stratification in terms of event times, default negation, and a model revision operator for dealing with incomplete or erroneous events \u2013 a typical problem in realistic applications. The paper proves the calculus correct wrt. a formal semantics of the specification language and it describes the calculus\u2019 implementation via embedding in Scala. This enables immediate access to rich data structures and external systems, which is important in practice.","publish_time":1590796800000,"author_summary":" Baumgartner, Peter","abstract_summary":" This paper describes a method of computing<br>plausible states of a system as a logical model. The<br>problem of analyzing state-based systems as they<br>evolve over time has been studied widely in the<br>automated reasoning community (and others). This paper<br>proposes a specific approach, one that is tailored to<br>situational awareness applications. The main<br>contribution is a calculus for a novel specification<br>language that is built around disjunctive logic<br>programming under a possible models semantics,<br>stratification in terms of event times, default negation, and a<br>model revision operator for dealing with incomplete<br>or erroneous events \u2013 a typical problem in...","title_summary":" Possible Models Computation and Revision \u2013 A<br>Practical Approach","x":-26.2299480438,"y":44.227191925,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.2299480438,"tsne_y":44.227191925,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"sv5ll441","source_x":"PMC","title":"Constructive Hybrid Games","doi":"10.1007\/978-3-030-51074-9_26","abstract":"Hybrid games combine discrete, continuous, and adversarial dynamics. Differential game logic ([Image: see text]) enables proving (classical) existence of winning strategies. We introduce constructive differential game logic (CdGL) for hybrid games, where proofs that a player can win the game correspond to computable winning strategies. This constitutes the logical foundation for synthesis of correct control and monitoring code for safety-critical cyber-physical systems. Our contributions include novel semantics as well as soundness and consistency.","publish_time":1590796800000,"author_summary":" Bohrer, Brandon; Platzer, Andr\u00e9","abstract_summary":" Hybrid games combine discrete, continuous,<br>and adversarial dynamics. Differential game<br>logic ([Image: see text]) enables proving<br>(classical) existence of winning strategies. We introduce<br>constructive differential game logic (CdGL) for hybrid<br>games, where proofs that a player can win the game<br>correspond to computable winning strategies. This<br>constitutes the logical foundation for synthesis of<br>correct control and monitoring code for<br>safety-critical cyber-physical systems. Our contributions<br>include novel semantics as well as soundness and<br>consistency.","title_summary":" Constructive Hybrid Games","x":-24.2642745972,"y":42.6299209595,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.2642745972,"tsne_y":42.6299209595,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"2gr1ofol","source_x":"PMC","title":"Mechanised Modal Model Theory","doi":"10.1007\/978-3-030-51074-9_30","abstract":"In this paper, we discuss the mechanisation of some fundamental propositional modal model theory. The focus on models is novel: previous work in mechanisations of modal logic have centered on proof systems and applications in model-checking. We have mechanised a number of fundamental results from the first two chapters of a standard textbook (Blackburn et al. [1]). Among others, one important result, the Van Benthem characterisation theorem, characterises the connection between modal logic and first order logic. This latter captures the desired saturation property of ultraproduct models on countably incomplete ultrafilters.","publish_time":1590796800000,"author_summary":" Xu, Yiming; Norrish, Michael","abstract_summary":" In this paper, we discuss the mechanisation of<br>some fundamental propositional modal model<br>theory. The focus on models is novel: previous work in<br>mechanisations of modal logic have centered on proof systems<br>and applications in model-checking. We have<br>mechanised a number of fundamental results from the first<br>two chapters of a standard textbook (Blackburn et<br>al. [1]). Among others, one important result, the<br>Van Benthem characterisation theorem,<br>characterises the connection between modal logic and first<br>order logic. This latter captures the desired<br>saturation property of ultraproduct models on countably<br>incomplete ultrafilters.","title_summary":" Mechanised Modal Model Theory","x":-25.3696079254,"y":44.8668479919,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3696079254,"tsne_y":44.8668479919,"subcluster":38,"subcluster_description":"Proof Cyclesmechanised Modal Model","shape":"p"},{"cord_uid":"dy889vni","source_x":"PMC","title":"A Formally Verified, Optimized Monitor for Metric First-Order Dynamic Logic","doi":"10.1007\/978-3-030-51074-9_25","abstract":"Runtime monitors for rich specification languages are sophisticated algorithms, especially when they are heavily optimized. To gain trust in them and safely explore the space of possible optimizations, it is important to verify the monitors themselves. We describe the development and correctness proof in Isabelle\/HOL of a monitor for metric first-order dynamic logic. This monitor significantly extends previous work on formally verified monitors by supporting aggregations, regular expressions (the dynamic part), and optimizations including multi-way joins adopted from databases and a new sliding window algorithm.","publish_time":1590796800000,"author_summary":" Basin, David; Dardinier, Thibault; Heimes,<br>Lukas; Krsti\u0107, Sr\u0111an; Raszyk, Martin; Schneider,<br>Joshua; Traytel, Dmitriy","abstract_summary":" Runtime monitors for rich specification<br>languages are sophisticated algorithms, especially<br>when they are heavily optimized. To gain trust in<br>them and safely explore the space of possible<br>optimizations, it is important to verify the monitors<br>themselves. We describe the development and correctness<br>proof in Isabelle\/HOL of a monitor for metric<br>first-order dynamic logic. This monitor significantly<br>extends previous work on formally verified monitors by<br>supporting aggregations, regular expressions (the<br>dynamic part), and optimizations including multi-way<br>joins adopted from databases and a new sliding window<br>algorithm.","title_summary":" A Formally Verified, Optimized Monitor for<br>Metric First-Order Dynamic Logic","x":-26.9195976257,"y":43.2540092468,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.9195976257,"tsne_y":43.2540092468,"subcluster":23,"subcluster_description":"Finite State Processesa Fast","shape":"p"},{"cord_uid":"jmtlhdqo","source_x":"PMC","title":"Designing New Phase Selection Heuristics","doi":"10.1007\/978-3-030-51825-7_6","abstract":"CDCL-based SAT solvers have transformed the field of automated reasoning owing to their demonstrated efficiency at handling problems arising from diverse domains. The success of CDCL solvers is owed to the design of clever heuristics that enable the tight coupling of different components. One of the core components is phase selection, wherein the solver, during branching, decides the polarity of the branch to be explored for a given variable. Most of the state-of-the-art CDCL SAT solvers employ phase-saving as a phase selection heuristic, which was proposed to address the potential inefficiencies arising from far-backtracking. In light of the emergence of chronological backtracking in CDCL solvers, we re-examine the efficiency of phase saving. Our empirical evaluation leads to a surprising conclusion: The usage of saved phase and random selection of polarity for decisions following a chronological backtracking leads to an indistinguishable runtime performance in terms of instances solved and PAR-2 score. We introduce Decaying Polarity Score (DPS) to capture the trend of the polarities attained by the variable, and upon observing lack of performance improvement due to DPS, we turn to a more sophisticated heuristic seeking to capture the activity of literals and the trend of polarities: Literal State Independent Decaying Sum (LSIDS). We find the 2019 winning SAT solver, Maple_LCM_Dist_ChronoBTv3, augmented with LSIDS solves 6 more instances while achieving a reduction of over 125 seconds in PAR-2 score, a significant improvement in the context of the SAT competition.","publish_time":1593129600000,"author_summary":" Shaw, Arijit; Meel, Kuldeep S.","abstract_summary":" CDCL-based SAT solvers have transformed the<br>field of automated reasoning owing to their<br>demonstrated efficiency at handling problems arising from<br>diverse domains. The success of CDCL solvers is owed to<br>the design of clever heuristics that enable the<br>tight coupling of different components. One of the<br>core components is phase selection, wherein the<br>solver, during branching, decides the polarity of the<br>branch to be explored for a given variable. Most of the<br>state-of-the-art CDCL SAT solvers employ phase-saving as a phase<br>selection heuristic, which was proposed to address the<br>potential inefficiencies arising from<br>far-backtracking. In light of the emergence of...","title_summary":" Designing New Phase Selection Heuristics","x":-25.2413959503,"y":42.8348197937,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.2413959503,"tsne_y":42.8348197937,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"rc86imwz","source_x":"PMC","title":"Community and LBD-Based Clause Sharing Policy for Parallel SAT Solving","doi":"10.1007\/978-3-030-51825-7_2","abstract":"Modern parallel SAT solvers rely heavily on effective clause sharing policies for their performance. The core problem being addressed by these policies can be succinctly stated as \u201cthe problem of identifying high-quality learnt clauses\u201d. These clauses, when shared between the worker nodes of parallel solvers, should lead to better performance. The term \u201chigh-quality clauses\u201d is often defined in terms of metrics that solver designers have identified over years of empirical study. Some of the more well-known metrics to identify high-quality clauses for sharing include clause length, literal block distance (LBD), and clause usage in propagation. In this paper, we propose a new metric aimed at identifying high-quality learnt clauses and a concomitant clause-sharing policy based on a combination of LBD and community structure of Boolean formulas. The concept of community structure has been proposed as a possible explanation for the extraordinary performance of SAT solvers in industrial instances. Hence, it is a natural candidate as a basis for a metric to identify high-quality clauses. To be more precise, our metric identifies clauses that have low LBD and low community number as ones that are high-quality for applications such as verification and testing. The community number of a clause C measures the number of different communities of a formula that the variables in C span. We perform extensive empirical analysis of our metric and clause-sharing policy, and show that our method significantly outperforms state-of-the-art techniques on the benchmark from the parallel track of the last four SAT competitions.","publish_time":1593129600000,"author_summary":" Vallade, Vincent; Le Frioux, Ludovic; Baarir,<br>Souheib; Sopena, Julien; Ganesh, Vijay; Kordon,<br>Fabrice","abstract_summary":" Modern parallel SAT solvers rely heavily on<br>effective clause sharing policies for their<br>performance. The core problem being addressed by these<br>policies can be succinctly stated as \u201cthe problem of<br>identifying high-quality learnt clauses\u201d. These clauses,<br>when shared between the worker nodes of parallel<br>solvers, should lead to better performance. The term<br>\u201chigh-quality clauses\u201d is often defined in terms of metrics<br>that solver designers have identified over years of<br>empirical study. Some of the more well-known metrics to<br>identify high-quality clauses for sharing include<br>clause length, literal block distance (LBD), and<br>clause usage in propagation. In this paper, we propose...","title_summary":" Community and LBD-Based Clause Sharing Policy<br>for Parallel SAT Solving","x":-25.2758731842,"y":42.7447547913,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.2758731842,"tsne_y":42.7447547913,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"j435znze","source_x":"PMC","title":"Trail Saving on Backtrack","doi":"10.1007\/978-3-030-51825-7_4","abstract":"A CDCL SAT solver can backtrack a large distance when it learns a new clause, e.g, when the new learnt clause is a unit clause the solver has to backtrack to level zero. When the length of the backtrack is large, the solver can end up reproducing many of the same decisions and propagations when it redescends the search tree. Different techniques have been proposed to reduce this potential redundancy, e.g., partial\/chronological backtracking and trail saving on restarts. In this paper we present a new trail saving technique that is not restricted to restarts, unlike prior trail saving methods. Our technique makes a copy of the part of the trail that is backtracked over. This saved copy can then be used to improve the efficiency of the solver\u2019s subsequent redescent. Furthermore, the saved trail also provides the solver with the ability to look ahead along the previous trail which can be exploited to improve its efficiency. Our new trail saving technique offers different tradeoffs in comparison with chronological backtracking and often yields superior performance. We also show that our technique is able to improve the performance of state-of-the-art solvers.","publish_time":1593129600000,"author_summary":" Hickey, Randy; Bacchus, Fahiem","abstract_summary":" A CDCL SAT solver can backtrack a large distance<br>when it learns a new clause, e.g, when the new learnt<br>clause is a unit clause the solver has to backtrack to<br>level zero. When the length of the backtrack is large,<br>the solver can end up reproducing many of the same<br>decisions and propagations when it redescends the search<br>tree. Different techniques have been proposed to<br>reduce this potential redundancy, e.g.,<br>partial\/chronological backtracking and trail saving on restarts. In<br>this paper we present a new trail saving technique<br>that is not restricted to restarts, unlike prior<br>trail saving methods. Our...","title_summary":" Trail Saving on Backtrack","x":-25.1253795624,"y":42.563621521,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.1253795624,"tsne_y":42.563621521,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"4fkk47xt","source_x":"PMC","title":"Clause Size Reduction with all-UIP Learning","doi":"10.1007\/978-3-030-51825-7_3","abstract":"Almost all CDCL SAT solvers use the 1-UIP clause learning scheme for learning new clauses from conflicts, and our current understanding of SAT solving provides good reasons for using that scheme. In particular, the 1-UIP scheme yields asserting clauses, and these asserting clauses have minimum LBD among all possible asserting clauses. As a result of these advantages, other clause learning schemes, like i-UIP and all-UIP, that were proposed in early work are not used in modern solvers. In this paper, we propose a new technique for exploiting the all-UIP clause learning scheme. Our technique is to employ all-UIP learning under the constraint that the learnt clause\u2019s LBD does not increase (over the minimum established by the 1-UIP clause). Our method can learn clauses that are significantly smaller than the 1-UIP clause while preserving the minimum LBD. Unlike previous clause minimization methods, our technique is not limited to learning a sub-clause of the 1-UIP clause. We show empirically that our method can improve the performance of state of the art solvers.","publish_time":1593129600000,"author_summary":" Feng, Nick; Bacchus, Fahiem","abstract_summary":" Almost all CDCL SAT solvers use the 1-UIP clause<br>learning scheme for learning new clauses from<br>conflicts, and our current understanding of SAT solving<br>provides good reasons for using that scheme. In<br>particular, the 1-UIP scheme yields asserting clauses, and<br>these asserting clauses have minimum LBD among all<br>possible asserting clauses. As a result of these<br>advantages, other clause learning schemes, like i-UIP and<br>all-UIP, that were proposed in early work are not used in<br>modern solvers. In this paper, we propose a new<br>technique for exploiting the all-UIP clause learning<br>scheme. Our technique is to employ all-UIP learning<br>under...","title_summary":" Clause Size Reduction with all-UIP Learning","x":-25.1965789795,"y":42.7356452942,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.1965789795,"tsne_y":42.7356452942,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"2k7bbnup","source_x":"PMC","title":"Sorting Parity Encodings by Reusing Variables","doi":"10.1007\/978-3-030-51825-7_1","abstract":"Parity reasoning is challenging for CDCL solvers: Refuting a formula consisting of two contradictory, differently ordered parity constraints of modest size is hard. Two alternative methods can solve these reordered parity formulas efficiently: binary decision diagrams and Gaussian Elimination (which requires detection of the parity constraints). Yet, implementations of these techniques either lack support of proof logging or introduce many extension variables. The compact, commonly-used encoding of parity constraints uses Tseitin variables. We present a technique for short clausal proofs that exploits these Tseitin variables to reorder the constraints within the DRAT system. The size of our refutations of reordered parity formulas is [Formula: see text].","publish_time":1593129600000,"author_summary":" Chew, Leroy; Heule, Marijn J. H.","abstract_summary":" Parity reasoning is challenging for CDCL<br>solvers: Refuting a formula consisting of two<br>contradictory, differently ordered parity constraints of<br>modest size is hard. Two alternative methods can solve<br>these reordered parity formulas efficiently:<br>binary decision diagrams and Gaussian Elimination<br>(which requires detection of the parity<br>constraints). Yet, implementations of these techniques<br>either lack support of proof logging or introduce many<br>extension variables. The compact, commonly-used<br>encoding of parity constraints uses Tseitin variables.<br>We present a technique for short clausal proofs<br>that exploits these Tseitin variables to reorder<br>the constraints within the DRAT system. The size of<br>our refutations of reordered...","title_summary":" Sorting Parity Encodings by Reusing Variables","x":-25.0610466003,"y":43.3230323792,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.0610466003,"tsne_y":43.3230323792,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"clxihvig","source_x":"PMC","title":"Four Flavors of Entailment","doi":"10.1007\/978-3-030-51825-7_5","abstract":"We present a novel approach for enumerating partial models of a propositional formula, inspired by how theory solvers and the SAT solver interact in lazy SMT. Using various forms of dual reasoning allows our CDCL-based algorithm to enumerate partial models with no need for exploring and shrinking full models. Our focus is on model enumeration without repetition, with potential applications in weighted model counting and weighted model integration for probabilistic inference over Boolean and hybrid domains. Chronological backtracking renders the use of blocking clauses obsolete. We provide a formalization and examples. We further discuss important design choices for a future implementation related to the strength of dual reasoning, including unit propagation, using SAT or QBF oracles.","publish_time":1593129600000,"author_summary":" M\u00f6hle, Sibylle; Sebastiani, Roberto; Biere,<br>Armin","abstract_summary":" We present a novel approach for enumerating<br>partial models of a propositional formula, inspired by<br>how theory solvers and the SAT solver interact in<br>lazy SMT. Using various forms of dual reasoning<br>allows our CDCL-based algorithm to enumerate partial<br>models with no need for exploring and shrinking full<br>models. Our focus is on model enumeration without<br>repetition, with potential applications in weighted model<br>counting and weighted model integration for<br>probabilistic inference over Boolean and hybrid domains.<br>Chronological backtracking renders the use of blocking<br>clauses obsolete. We provide a formalization and<br>examples. We further discuss important design choices<br>for a future...","title_summary":" Four Flavors of Entailment","x":-25.3841896057,"y":43.8912811279,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3841896057,"tsne_y":43.8912811279,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"llto2m5p","source_x":"PMC","title":"Distributed Cube and Conquer with Paracooba","doi":"10.1007\/978-3-030-51825-7_9","abstract":"Cube and conquer is currently the most effective approach to solve hard combinatorial problems in parallel. It organizes the search in two phases. First, a look-ahead solver splits the problem into many sub-problems, called cubes, which are then solved in parallel by incremental CDCL solvers. In this tool paper we present the first fully integrated and automatic distributed cube-and-conquer solver Paracooba targeting cluster and cloud computing. Previous work was limited to multi-core parallelism or relied on manual orchestration of the solving process. Our approach uses one master per problem to initialize the solving process and automatically discovers and releases compute nodes through elastic resource usage. Multiple problems can be solved in parallel on shared compute nodes, controlled by a custom peer-to-peer based load-balancing protocol. Experiments show the scalability of our approach.","publish_time":1593129600000,"author_summary":" Heisinger, Maximilian; Fleury, Mathias;<br>Biere, Armin","abstract_summary":" Cube and conquer is currently the most<br>effective approach to solve hard combinatorial problems<br>in parallel. It organizes the search in two<br>phases. First, a look-ahead solver splits the problem<br>into many sub-problems, called cubes, which are<br>then solved in parallel by incremental CDCL<br>solvers. In this tool paper we present the first fully<br>integrated and automatic distributed cube-and-conquer<br>solver Paracooba targeting cluster and cloud<br>computing. Previous work was limited to multi-core<br>parallelism or relied on manual orchestration of the<br>solving process. Our approach uses one master per<br>problem to initialize the solving process and<br>automatically discovers and releases compute...","title_summary":" Distributed Cube and Conquer with Paracooba","x":-26.3031673431,"y":39.968536377,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.3031673431,"tsne_y":39.968536377,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"segf4wj9","source_x":"PMC","title":"Improving Implementation of SAT Competitions 2017\u20132019 Winners","doi":"10.1007\/978-3-030-51825-7_11","abstract":"The results of annual SAT competitions are often viewed as the milestones showcasing the progress in SAT solvers. However, their competitive nature leads to the situation when the majority of this year\u2019s solvers are based on previous year\u2019s winner. And since the main focus is always on novelty, it means that there are times when some implementation details have a potential for improvement, but they are just inherited from solver to solver for several years in a row. In this study we propose small modifications of implementations of existing heuristics in several related SAT solvers. These modifications mostly consist in employing a deterministic strategy for switching between branching heuristics and in augmentations of the treatment of Tier2 and Core clauses. In our experiments we show that the proposed changes have a positive effect on solvers\u2019 performance both individually and in combination with each other.","publish_time":1593129600000,"author_summary":" Kochemazov, Stepan","abstract_summary":" The results of annual SAT competitions are<br>often viewed as the milestones showcasing the<br>progress in SAT solvers. However, their competitive<br>nature leads to the situation when the majority of this<br>year\u2019s solvers are based on previous year\u2019s winner.<br>And since the main focus is always on novelty, it<br>means that there are times when some implementation<br>details have a potential for improvement, but they are<br>just inherited from solver to solver for several<br>years in a row. In this study we propose small<br>modifications of implementations of existing heuristics in<br>several related SAT solvers. These modifications<br>mostly consist in...","title_summary":" Improving Implementation of SAT Competitions<br>2017\u20132019 Winners","x":-25.1413021088,"y":42.601234436,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.1413021088,"tsne_y":42.601234436,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"lj3ibdfv","source_x":"PMC","title":"Satisfiability Solving Meets Evolutionary Optimisation in Designing Approximate Circuits","doi":"10.1007\/978-3-030-51825-7_33","abstract":"Approximate circuits that trade the chip area or power consumption for the precision of the computation play a key role in development of energy-aware systems. Designing complex approximate circuits is, however, very difficult, especially, when a given approximation error has to be guaranteed. Evolutionary search algorithms together with SAT-based error evaluation currently represent one of the most successful approaches for automated circuit approximation. In this paper, we apply satisfiability solving not only for circuit evaluation but also for its minimisation. We consider and evaluate several approaches to this task, both inspired by existing works as well as novel ones. Our experiments show that a combined strategy, integrating evolutionary search and SMT-based sub-circuit minimisation (using quantified theory of arrays) that we propose, is able to find complex approximate circuits (e.g. 16-bit multipliers) with considerably better trade-offs between the circuit precision and size than existing approaches.","publish_time":1593129600000,"author_summary":" \u010ce\u0161ka, Milan; Maty\u00e1\u0161, Ji\u0159\u00ed; Mrazek, Vojtech;<br>Vojnar, Tom\u00e1\u0161","abstract_summary":" Approximate circuits that trade the chip area<br>or power consumption for the precision of the<br>computation play a key role in development of energy-aware<br>systems. Designing complex approximate circuits is,<br>however, very difficult, especially, when a given<br>approximation error has to be guaranteed. Evolutionary<br>search algorithms together with SAT-based error<br>evaluation currently represent one of the most successful<br>approaches for automated circuit approximation. In this<br>paper, we apply satisfiability solving not only for<br>circuit evaluation but also for its minimisation. We<br>consider and evaluate several approaches to this task,<br>both inspired by existing works as well as novel<br>ones. Our...","title_summary":" Satisfiability Solving Meets Evolutionary<br>Optimisation in Designing Approximate Circuits","x":-24.6063327789,"y":41.9426994324,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.6063327789,"tsne_y":41.9426994324,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"nnm6d4qu","source_x":"PMC","title":"On the Effect of Learned Clauses on Stochastic Local Search","doi":"10.1007\/978-3-030-51825-7_7","abstract":"There are two competing paradigms in successful SAT solvers: Conflict-driven clause learning (CDCL) and stochastic local search (SLS). CDCL uses systematic exploration of the search space and has the ability to learn new clauses. SLS examines the neighborhood of the current complete assignment. Unlike CDCL, it lacks the ability to learn from its mistakes. This work revolves around the question whether it is beneficial for SLS to add new clauses to the original formula. We experimentally demonstrate that clauses with a large number of correct literals w. r. t. a fixed solution are beneficial to the runtime of SLS. We call such clauses high-quality clauses. Empirical evaluations show that short clauses learned by CDCL possess the high-quality attribute. We study several domains of randomly generated instances and deduce the most beneficial strategies to add high-quality clauses as a preprocessing step. The strategies are implemented in an SLS solver, and it is shown that this considerably improves the state-of-the-art on randomly generated instances. The results are statistically significant.","publish_time":1593129600000,"author_summary":" Lorenz, Jan-Hendrik; W\u00f6rz, Florian","abstract_summary":" There are two competing paradigms in<br>successful SAT solvers: Conflict-driven clause learning<br>(CDCL) and stochastic local search (SLS). CDCL uses<br>systematic exploration of the search space and has the<br>ability to learn new clauses. SLS examines the<br>neighborhood of the current complete assignment. Unlike<br>CDCL, it lacks the ability to learn from its mistakes.<br>This work revolves around the question whether it is<br>beneficial for SLS to add new clauses to the original<br>formula. We experimentally demonstrate that clauses<br>with a large number of correct literals w. r. t. a<br>fixed solution are beneficial to the runtime of SLS.<br>We...","title_summary":" On the Effect of Learned Clauses on Stochastic<br>Local Search","x":-25.1929340363,"y":42.7078666687,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.1929340363,"tsne_y":42.7078666687,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"9941v74p","source_x":"PMC","title":"Reproducible Efficient Parallel SAT Solving","doi":"10.1007\/978-3-030-51825-7_10","abstract":"In this paper, we propose a new reproducible and efficient parallel SAT solving algorithm. Unlike sequential SAT solvers, most parallel solvers do not guarantee reproducible behavior due to maximizing the performance. The unstable and non-deterministic behavior of parallel SAT solvers hinders a wider adoption of parallel solvers to the practical applications. In order to achieve robust and efficient parallel SAT solving, we propose two techniques to significantly reduce idle time in deterministic parallel SAT solving: delayed clause exchange and accurate estimation of execution time of clause exchange interval between solvers. The experimental results show that our reproducible parallel SAT solver has comparable performance to non-deterministic parallel SAT solvers even in a many-core environment.","publish_time":1593129600000,"author_summary":" Nabeshima, Hidetomo; Inoue, Katsumi","abstract_summary":" In this paper, we propose a new reproducible and<br>efficient parallel SAT solving algorithm. Unlike<br>sequential SAT solvers, most parallel solvers do not<br>guarantee reproducible behavior due to maximizing the<br>performance. The unstable and non-deterministic behavior<br>of parallel SAT solvers hinders a wider adoption<br>of parallel solvers to the practical<br>applications. In order to achieve robust and efficient<br>parallel SAT solving, we propose two techniques to<br>significantly reduce idle time in deterministic parallel SAT<br>solving: delayed clause exchange and accurate<br>estimation of execution time of clause exchange interval<br>between solvers. The experimental results show that<br>our reproducible parallel SAT solver...","title_summary":" Reproducible Efficient Parallel SAT Solving","x":-25.4242630005,"y":42.5621147156,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.4242630005,"tsne_y":42.5621147156,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"f38d8eri","source_x":"PMC","title":"On Weakening Strategies for PB Solvers","doi":"10.1007\/978-3-030-51825-7_23","abstract":"Current pseudo-Boolean solvers implement different variants of the cutting planes proof system to infer new constraints during conflict analysis. One of these variants is generalized resolution, which allows to infer strong constraints, but suffers from the growth of coefficients it generates while combining pseudo-Boolean constraints. Another variant consists in using weakening and division, which is more efficient in practice but may infer weaker constraints. In both cases, weakening is mandatory to derive conflicting constraints. However, its impact on the performance of pseudo-Boolean solvers has not been assessed so far. In this paper, new application strategies for this rule are studied, aiming to infer strong constraints with small coefficients. We implemented them in Sat4j and observed that each of them improves the runtime of the solver. While none of them performs better than the others on all benchmarks, applying weakening on the conflict side has surprising good performance, whereas applying partial weakening and division on both the conflict and the reason sides provides the best results overall.","publish_time":1593129600000,"author_summary":" Le Berre, Daniel; Marquis, Pierre; Wallon,<br>Romain","abstract_summary":" Current pseudo-Boolean solvers implement<br>different variants of the cutting planes proof system to<br>infer new constraints during conflict analysis. One<br>of these variants is generalized resolution,<br>which allows to infer strong constraints, but<br>suffers from the growth of coefficients it generates<br>while combining pseudo-Boolean constraints.<br>Another variant consists in using weakening and<br>division, which is more efficient in practice but may<br>infer weaker constraints. In both cases, weakening<br>is mandatory to derive conflicting constraints.<br>However, its impact on the performance of<br>pseudo-Boolean solvers has not been assessed so far. In this<br>paper, new application strategies for this rule are<br>studied,...","title_summary":" On Weakening Strategies for PB Solvers","x":-25.1484165192,"y":42.8866233826,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.1484165192,"tsne_y":42.8866233826,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"o0ofhta0","source_x":"PMC","title":"Matrix Multiplication: Verifying Strong Uniquely Solvable Puzzles","doi":"10.1007\/978-3-030-51825-7_32","abstract":"Cohn and Umans proposed a framework for developing fast matrix multiplication algorithms based on the embedding computation in certain groups algebras [9]. In subsequent work with Kleinberg and Szegedy, they connected this to the search for combinatorial objects called strong uniquely solvable puzzles (strong USPs) [8]. We begin a systematic computer-aided search for these objects. We develop and implement algorithms based on reductions to [Formula: see text] and [Formula: see text] to verify that puzzles are strong USPs and to search for large strong USPs. We produce tight bounds on the maximum size of a strong USP for width [Formula: see text], and construct puzzles of small width that are larger than previous work. Although our work only deals with puzzles of small-constant width and does not produce a new, faster matrix multiplication algorithm, we provide evidence that there exist families of strong USPs that imply matrix multiplication algorithms that are more efficient than those currently known.","publish_time":1593129600000,"author_summary":" Anderson, Matthew; Ji, Zongliang; Xu, Anthony<br>Yang","abstract_summary":" Cohn and Umans proposed a framework for<br>developing fast matrix multiplication algorithms based<br>on the embedding computation in certain groups<br>algebras [9]. In subsequent work with Kleinberg and<br>Szegedy, they connected this to the search for<br>combinatorial objects called strong uniquely solvable<br>puzzles (strong USPs) [8]. We begin a systematic<br>computer-aided search for these objects. We develop and<br>implement algorithms based on reductions to [Formula:<br>see text] and [Formula: see text] to verify that<br>puzzles are strong USPs and to search for large strong<br>USPs. We produce tight bounds on the maximum size of a<br>strong USP for width [Formula:...","title_summary":" Matrix Multiplication: Verifying Strong<br>Uniquely Solvable Puzzles","x":-23.0325660706,"y":43.345703125,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.0325660706,"tsne_y":43.345703125,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"0z9gktlu","source_x":"PMC","title":"Strong (D)QBF Dependency Schemes via Tautology-Free Resolution Paths","doi":"10.1007\/978-3-030-51825-7_28","abstract":"We suggest a general framework to study dependency schemes for dependency quantified Boolean formulas (DQBF). As our main contribution, we exhibit a new tautology-free DQBF dependency scheme that generalises the reflexive resolution path dependency scheme. We establish soundness of the tautology-free scheme, implying that it can be used in any DQBF proof system. We further explore the power of DQBF resolution systems parameterised by dependency schemes and show that our new scheme results in exponentially shorter proofs in comparison to the reflexive resolution path dependency scheme when used in the expansion DQBF system [Formula: see text]. On QBFs, we demonstrate that our new scheme is exponentially stronger than the reflexive resolution path dependency scheme when used in Q-resolution, thus resulting in the strongest QBF dependency scheme known to date.","publish_time":1593129600000,"author_summary":" Beyersdorff, Olaf; Blinkhorn, Joshua; Peitl,<br>Tom\u00e1\u0161","abstract_summary":" We suggest a general framework to study<br>dependency schemes for dependency quantified Boolean<br>formulas (DQBF). As our main contribution, we exhibit a<br>new tautology-free DQBF dependency scheme that<br>generalises the reflexive resolution path dependency<br>scheme. We establish soundness of the tautology-free<br>scheme, implying that it can be used in any DQBF proof<br>system. We further explore the power of DQBF resolution<br>systems parameterised by dependency schemes and show<br>that our new scheme results in exponentially<br>shorter proofs in comparison to the reflexive<br>resolution path dependency scheme when used in the<br>expansion DQBF system [Formula: see text]. On QBFs, we<br>demonstrate...","title_summary":" Strong (D)QBF Dependency Schemes via<br>Tautology-Free Resolution Paths","x":-25.1738204956,"y":44.1092224121,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.1738204956,"tsne_y":44.1092224121,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"nc0kaocu","source_x":"PMC","title":"SAT Heritage: A Community-Driven Effort for Archiving, Building and Running More Than Thousand SAT Solvers","doi":"10.1007\/978-3-030-51825-7_8","abstract":"SAT research has a long history of source code and binary releases, thanks to competitions organized every year. However, since every cycle of competitions has its own set of rules and an adhoc way of publishing source code and binaries, compiling or even running any solver may be harder than what it seems. Moreover, there has been more than a thousand solvers published so far, some of them released in the early 90\u2019s. If the SAT community wants to archive and be able to keep track of all the solvers that made its history, it urgently needs to deploy an important effort. We propose to initiate a community-driven effort to archive and to allow easy compilation and running of all SAT solvers that have been released so far. We rely on the best tools for archiving and building binaries (thanks to Docker, GitHub and Zenodo) and provide a consistent and easy way for this. Thanks to our tool, building (or running) a solver from its source (or from its binary) can be done in one line.","publish_time":1593129600000,"author_summary":" Audemard, Gilles; Paulev\u00e9, Lo\u00efc; Simon,<br>Laurent","abstract_summary":" SAT research has a long history of source code<br>and binary releases, thanks to competitions<br>organized every year. However, since every cycle of<br>competitions has its own set of rules and an adhoc way of<br>publishing source code and binaries, compiling or even<br>running any solver may be harder than what it seems.<br>Moreover, there has been more than a thousand solvers<br>published so far, some of them released in the early 90\u2019s.<br>If the SAT community wants to archive and be able to<br>keep track of all the solvers that made its history,<br>it urgently needs to deploy an...","title_summary":" SAT Heritage: A Community-Driven Effort for<br>Archiving, Building and Running More Than Thousand SAT<br>Solvers","x":-25.7583293915,"y":42.5324821472,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.7583293915,"tsne_y":42.5324821472,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"jiza40dv","source_x":"PMC","title":"Incremental Encoding of Pseudo-Boolean Goal Functions Based on Comparator Networks","doi":"10.1007\/978-3-030-51825-7_36","abstract":"Incremental techniques have been widely used in solving problems reducible to SAT and MaxSAT instances. When an algorithm requires making subsequent runs of a SAT-solver on a slightly changing input formula, it is usually beneficial to change the strategy, so that the algorithm only operates on a single instance of a SAT-solver. One way to do this is via a mechanism called assumptions, which allows to accumulate and reuse knowledge from one iteration to the next and, in consequence, the provided input formula need not to be rebuilt during computation. In this paper we propose an encoding of a Pseudo-Boolean goal function that is based on sorting networks and can be provided to a SAT-solver only once. Then, during an optimization process, different bounds on the value of the function can be given to the solver by appropriate sets of assumptions. The experimental results show that the proposed technique is sound, that is, it increases the number of solved instances and reduces the average time and memory used by the solver on solved instances.","publish_time":1593129600000,"author_summary":" Karpi\u0144ski, Micha\u0142; Piotr\u00f3w, Marek","abstract_summary":" Incremental techniques have been widely used<br>in solving problems reducible to SAT and MaxSAT<br>instances. When an algorithm requires making subsequent<br>runs of a SAT-solver on a slightly changing input<br>formula, it is usually beneficial to change the<br>strategy, so that the algorithm only operates on a single<br>instance of a SAT-solver. One way to do this is via a<br>mechanism called assumptions, which allows to<br>accumulate and reuse knowledge from one iteration to the<br>next and, in consequence, the provided input<br>formula need not to be rebuilt during computation. In<br>this paper we propose an encoding of a<br>Pseudo-Boolean...","title_summary":" Incremental Encoding of Pseudo-Boolean Goal<br>Functions Based on Comparator Networks","x":-24.8704051971,"y":42.8327445984,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.8704051971,"tsne_y":42.8327445984,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"ddz2pdx1","source_x":"PMC","title":"Towards a Better Understanding of (Partial Weighted) MaxSAT Proof Systems","doi":"10.1007\/978-3-030-51825-7_16","abstract":"MaxSAT is a very popular language for discrete optimization with many domains of application. While there has been a lot of progress in MaxSAT solvers during the last decade, the theoretical analysis of MaxSAT inference has not followed the pace. Aiming at compensating that lack of balance, in this paper we do a proof complexity approach to MaxSAT resolution-based proof systems. First, we give some basic definitions on completeness and show that refutational completeness makes compleness redundant, as it happens in SAT. Then we take three inference rules such that adding them sequentially allows us to navigate from the weakest to the strongest resolution-based MaxSAT system available (i.e., from standalone MaxSAT resolution to the recently proposed ResE), each rule making the system stronger. Finally, we show that the strongest system captures the recently proposed concept of Circular Proof while being conceptually simpler, since weights, which are intrinsic in MaxSAT, naturally guarantee the flow condition required for the SAT case.","publish_time":1593129600000,"author_summary":" Larrosa, Javier; Rollon, Emma","abstract_summary":" MaxSAT is a very popular language for discrete<br>optimization with many domains of application. While there<br>has been a lot of progress in MaxSAT solvers during<br>the last decade, the theoretical analysis of<br>MaxSAT inference has not followed the pace. Aiming at<br>compensating that lack of balance, in this paper we do a proof<br>complexity approach to MaxSAT resolution-based proof<br>systems. First, we give some basic definitions on<br>completeness and show that refutational completeness makes<br>compleness redundant, as it happens in SAT. Then we take<br>three inference rules such that adding them<br>sequentially allows us to navigate from the weakest...","title_summary":" Towards a Better Understanding of (Partial<br>Weighted) MaxSAT Proof Systems","x":-25.3418045044,"y":43.051940918,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3418045044,"tsne_y":43.051940918,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"401tdbjo","source_x":"PMC","title":"Taming High Treewidth with Abstraction, Nested Dynamic Programming, and Database Technology","doi":"10.1007\/978-3-030-51825-7_25","abstract":"Treewidth is one of the most prominent structural parameters. While numerous theoretical results establish tractability under the assumption of fixed treewidth, the practical success of exploiting this parameter is far behind what theoretical runtime bounds have promised. In particular, a naive application of dynamic programming (DP) on tree decompositions (TDs) suffers already from instances of medium width. In this paper, we present several measures to advance this paradigm towards general applicability in practice: We present nested DP, where different levels of abstractions are used to (recursively) compute TDs of a given instance. Further, we integrate the concept of hybrid solving, where subproblems hidden by the abstraction are solved by classical search-based solvers, which leads to an interleaving of parameterized and classical solving. Finally, we provide nested DP algorithms and implementations relying on database technology for variants and extensions of Boolean satisfiability. Experiments indicate that the advancements are promising.","publish_time":1593129600000,"author_summary":" Hecher, Markus; Thier, Patrick; Woltran,<br>Stefan","abstract_summary":" Treewidth is one of the most prominent<br>structural parameters. While numerous theoretical<br>results establish tractability under the assumption<br>of fixed treewidth, the practical success of<br>exploiting this parameter is far behind what theoretical<br>runtime bounds have promised. In particular, a naive<br>application of dynamic programming (DP) on tree<br>decompositions (TDs) suffers already from instances of medium<br>width. In this paper, we present several measures to<br>advance this paradigm towards general applicability<br>in practice: We present nested DP, where<br>different levels of abstractions are used to<br>(recursively) compute TDs of a given instance. Further, we<br>integrate the concept of hybrid solving,...","title_summary":" Taming High Treewidth with Abstraction,<br>Nested Dynamic Programming, and Database Technology","x":-25.0473690033,"y":43.0940246582,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.0473690033,"tsne_y":43.0940246582,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"spwu6zko","source_x":"PMC","title":"Short Q-Resolution Proofs with Homomorphisms","doi":"10.1007\/978-3-030-51825-7_29","abstract":"We introduce new proof systems for quantified Boolean formulas (QBFs) by enhancing Q-resolution systems with rules which exploit local and global symmetries. The rules are based on homomorphisms that admit non-injective mappings between literals. This results in systems that are stronger than Q-resolution with (injective) symmetry rules. We further strengthen the systems by utilizing a dependency system D in a way that surpasses Q(D)-resolution in relative strength.","publish_time":1593129600000,"author_summary":" Shukla, Ankit; Slivovsky, Friedrich;<br>Szeider, Stefan","abstract_summary":" We introduce new proof systems for quantified<br>Boolean formulas (QBFs) by enhancing Q-resolution<br>systems with rules which exploit local and global<br>symmetries. The rules are based on homomorphisms that admit<br>non-injective mappings between literals. This results in<br>systems that are stronger than Q-resolution with<br>(injective) symmetry rules. We further strengthen the<br>systems by utilizing a dependency system D in a way that<br>surpasses Q(D)-resolution in relative strength.","title_summary":" Short Q-Resolution Proofs with Homomorphisms","x":-24.4726219177,"y":45.282119751,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.4726219177,"tsne_y":45.282119751,"subcluster":14,"subcluster_description":"Orienting Combinator Equationsshort Q-Resolution","shape":"p"},{"cord_uid":"g9kkx2b5","source_x":"PMC","title":"MaxSAT Resolution and Subcube Sums","doi":"10.1007\/978-3-030-51825-7_21","abstract":"We study the MaxRes rule in the context of certifying unsatisfiability. We show that it can be exponentially more powerful than tree-like resolution, and when augmented with weakening (the system MaxResW), p-simulates tree-like resolution. In devising a lower bound technique specific to MaxRes (and not merely inheriting lower bounds from Res), we define a new semialgebraic proof system called the SubCubeSums proof system. This system, which p-simulates MaxResW, is a special case of the Sherali\u2013Adams proof system. In expressivity, it is the integral restriction of conical juntas studied in the contexts of communication complexity and extension complexity. We show that it is not simulated by Res. Using a proof technique qualitatively different from the lower bounds that MaxResW inherits from Res, we show that Tseitin contradictions on expander graphs are hard to refute in SubCubeSums. We also establish a lower bound technique via lifting: for formulas requiring large degree in SubCubeSums, their XOR-ification requires large size in SubCubeSums.","publish_time":1593129600000,"author_summary":" Filmus, Yuval; Mahajan, Meena; Sood, Gaurav;<br>Vinyals, Marc","abstract_summary":" We study the MaxRes rule in the context of<br>certifying unsatisfiability. We show that it can be<br>exponentially more powerful than tree-like resolution, and<br>when augmented with weakening (the system<br>MaxResW), p-simulates tree-like resolution. In<br>devising a lower bound technique specific to MaxRes (and<br>not merely inheriting lower bounds from Res), we<br>define a new semialgebraic proof system called the<br>SubCubeSums proof system. This system, which p-simulates<br>MaxResW, is a special case of the Sherali\u2013Adams proof<br>system. In expressivity, it is the integral<br>restriction of conical juntas studied in the contexts of<br>communication complexity and extension complexity. We show<br>that...","title_summary":" MaxSAT Resolution and Subcube Sums","x":-24.3426170349,"y":43.9741706848,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.3426170349,"tsne_y":43.9741706848,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"2hnk90p3","source_x":"PMC","title":"Speeding up Quantified Bit-Vector SMT Solvers by Bit-Width Reductions and Extensions","doi":"10.1007\/978-3-030-51825-7_27","abstract":"Recent experiments have shown that satisfiability of a quantified bit-vector formula coming from practical applications almost never changes after reducing all bit-widths in the formula to a small number of bits. This paper proposes a novel technique based on this observation. Roughly speaking, a given quantified bit-vector formula is reduced and sent to a solver, an obtained model is then extended to the original bit-widths and verified against the original formula. We also present an experimental evaluation demonstrating that this technique can significantly improve the performance of state-of-the-art smt solvers Boolector, CVC4, and Q3B on quantified bit-vector formulas from the smt-lib repository.","publish_time":1593129600000,"author_summary":" Jon\u00e1\u0161, Martin; Strej\u010dek, Jan","abstract_summary":" Recent experiments have shown that<br>satisfiability of a quantified bit-vector formula coming from<br>practical applications almost never changes after<br>reducing all bit-widths in the formula to a small number<br>of bits. This paper proposes a novel technique<br>based on this observation. Roughly speaking, a given<br>quantified bit-vector formula is reduced and sent to a<br>solver, an obtained model is then extended to the<br>original bit-widths and verified against the original<br>formula. We also present an experimental evaluation<br>demonstrating that this technique can significantly improve<br>the performance of state-of-the-art smt solvers<br>Boolector, CVC4, and Q3B on quantified bit-vector<br>formulas from the...","title_summary":" Speeding up Quantified Bit-Vector SMT Solvers<br>by Bit-Width Reductions and Extensions","x":-24.8979930878,"y":42.6823921204,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.8979930878,"tsne_y":42.6823921204,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"uirxxouz","source_x":"PMC","title":"Abstract Cores in Implicit Hitting Set MaxSat Solving","doi":"10.1007\/978-3-030-51825-7_20","abstract":"Maximum Satisfiability (MaxSat) solving is an active area of research motivated by numerous successful applications to solving NP-hard combinatorial optimization problems. One of the most successful approaches to solving MaxSat instances arising from real world applications is the Implicit Hitting Set (IHS) approach. IHS solvers are complete MaxSat solvers that harness the strengths of both Boolean Satisfiability (SAT) and Integer Linear Programming (IP) solvers by decoupling core-extraction and optimization. While such solvers show state-of-the-art performance on many instances, it is known that there exist MaxSat instances on which IHS solvers need to extract an exponential number of cores before terminating. Motivated by the structure of the simplest of these problematic instances, we propose a technique we call abstract cores that provides a compact representation for a potentially exponential number of regular cores. We demonstrate how to incorporate abstract core reasoning into the IHS algorithm and report on an empirical evaluation demonstrating that including abstract cores into a state-of-the-art IHS solver improves its performance enough to surpass the best performing solvers of the most recent 2019 MaxSat Evaluation.","publish_time":1593129600000,"author_summary":" Berg, Jeremias; Bacchus, Fahiem; Poole, Alex","abstract_summary":" Maximum Satisfiability (MaxSat) solving is an<br>active area of research motivated by numerous<br>successful applications to solving NP-hard<br>combinatorial optimization problems. One of the most<br>successful approaches to solving MaxSat instances<br>arising from real world applications is the Implicit<br>Hitting Set (IHS) approach. IHS solvers are complete<br>MaxSat solvers that harness the strengths of both<br>Boolean Satisfiability (SAT) and Integer Linear<br>Programming (IP) solvers by decoupling core-extraction<br>and optimization. While such solvers show<br>state-of-the-art performance on many instances, it is known that<br>there exist MaxSat instances on which IHS solvers<br>need to extract an exponential number of cores<br>before terminating....","title_summary":" Abstract Cores in Implicit Hitting Set MaxSat<br>Solving","x":-24.9979343414,"y":42.7160491943,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.9979343414,"tsne_y":42.7160491943,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"vc04cnay","source_x":"PMC","title":"Positional Games and QBF: The Corrective Encoding","doi":"10.1007\/978-3-030-51825-7_31","abstract":"Positional games are a mathematical class of two-player games comprising Tic-tac-toe and its generalizations. We propose a novel encoding of these games into Quantified Boolean Formulas (QBFs) such that a game instance admits a winning strategy for first player if and only if the corresponding formula is true. Our approach improves over previous QBF encodings of games in multiple ways. First, it is generic and lets us encode other positional games, such as Hex. Second, structural properties of positional games together with a careful treatment of illegal moves let us generate more compact instances that can be solved faster by state-of-the-art QBF solvers. We establish the latter fact through extensive experiments. Finally, the compactness of our new encoding makes it feasible to translate realistic game problems. We identify a few such problems of historical significance and put them forward to the QBF community as milestones of increasing difficulty.","publish_time":1593129600000,"author_summary":" Mayer-Eichberger, Valentin; Saffidine,<br>Abdallah","abstract_summary":" Positional games are a mathematical class of<br>two-player games comprising Tic-tac-toe and its<br>generalizations. We propose a novel encoding of these games into<br>Quantified Boolean Formulas (QBFs) such that a game<br>instance admits a winning strategy for first player if<br>and only if the corresponding formula is true. Our<br>approach improves over previous QBF encodings of games<br>in multiple ways. First, it is generic and lets us<br>encode other positional games, such as Hex. Second,<br>structural properties of positional games together with a<br>careful treatment of illegal moves let us generate more<br>compact instances that can be solved faster by...","title_summary":" Positional Games and QBF: The Corrective<br>Encoding","x":-24.5386352539,"y":42.841091156,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.5386352539,"tsne_y":42.841091156,"subcluster":10,"subcluster_description":"Winning Strategieson-The-Fly","shape":"p"},{"cord_uid":"3b1u20qm","source_x":"PMC","title":"Towards a Complexity-Theoretic Understanding of Restarts in SAT Solvers","doi":"10.1007\/978-3-030-51825-7_17","abstract":"Restarts are a widely-used class of techniques integral to the efficiency of Conflict-Driven Clause Learning (CDCL) Boolean SAT solvers. While the utility of such policies has been well-established empirically, a theoretical understanding of whether restarts are indeed crucial to the power of CDCL solvers is missing. In this paper, we prove a series of theoretical results that characterize the power of restarts for various models of SAT solvers. More precisely, we make the following contributions. First, we prove an exponential separation between a drunk randomized CDCL solver model with restarts and the same model without restarts using a family of satisfiable instances. Second, we show that the configuration of CDCL solver with VSIDS branching and restarts (with activities erased after restarts) is exponentially more powerful than the same configuration without restarts for a family of unsatisfiable instances. To the best of our knowledge, these are the first separation results involving restarts in the context of SAT solvers. Third, we show that restarts do not add any proof complexity-theoretic power vis-a-vis a number of models of CDCL and DPLL solvers with non-deterministic static variable and value selection.","publish_time":1593129600000,"author_summary":" Li, Chunxiao; Fleming, Noah; Vinyals, Marc;<br>Pitassi, Toniann; Ganesh, Vijay","abstract_summary":" Restarts are a widely-used class of techniques<br>integral to the efficiency of Conflict-Driven Clause<br>Learning (CDCL) Boolean SAT solvers. While the utility<br>of such policies has been well-established<br>empirically, a theoretical understanding of whether<br>restarts are indeed crucial to the power of CDCL solvers<br>is missing. In this paper, we prove a series of<br>theoretical results that characterize the power of<br>restarts for various models of SAT solvers. More<br>precisely, we make the following contributions. First, we<br>prove an exponential separation between a drunk<br>randomized CDCL solver model with restarts and the same<br>model without restarts using a family of...","title_summary":" Towards a Complexity-Theoretic<br>Understanding of Restarts in SAT Solvers","x":-25.143737793,"y":42.9890213013,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.143737793,"tsne_y":42.9890213013,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"dkk5ogrb","source_x":"PMC","title":"Simplified and Improved Separations Between Regular and General Resolution by Lifting","doi":"10.1007\/978-3-030-51825-7_14","abstract":"We give a significantly simplified proof of the exponential separation between regular and general resolution of Alekhnovich et al. (2007) as a consequence of a general theorem lifting proof depth to regular proof length in resolution. This simpler proof then allows us to strengthen the separation further, and to construct families of theoretically very easy benchmarks that are surprisingly hard for SAT solvers in practice.","publish_time":1593129600000,"author_summary":" Vinyals, Marc; Elffers, Jan; Johannsen, Jan;<br>Nordstr\u00f6m, Jakob","abstract_summary":" We give a significantly simplified proof of the<br>exponential separation between regular and general<br>resolution of Alekhnovich et al. (2007) as a consequence of<br>a general theorem lifting proof depth to regular<br>proof length in resolution. This simpler proof then<br>allows us to strengthen the separation further, and to<br>construct families of theoretically very easy<br>benchmarks that are surprisingly hard for SAT solvers in<br>practice.","title_summary":" Simplified and Improved Separations Between<br>Regular and General Resolution by Lifting","x":-23.6020431519,"y":46.294757843,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.6020431519,"tsne_y":46.294757843,"subcluster":18,"subcluster_description":"Capturing Complexity Classes","shape":"p"},{"cord_uid":"qqwxt1se","source_x":"PMC","title":"A Faster Algorithm for Propositional Model Counting Parameterized by Incidence Treewidth","doi":"10.1007\/978-3-030-51825-7_19","abstract":"The propositional model counting problem (#SAT) is known to be fixed-parameter-tractable (FPT) when parameterized by the width k of a given tree decomposition of the incidence graph. The running time of the fastest known FPT algorithm contains the exponential factor of [Formula: see text]. We improve this factor to [Formula: see text] by utilizing fast algorithms for computing the zeta transform and covering product of functions representing partial model counts, thereby achieving the same running time as FPT algorithms that are parameterized by the less general treewidth of the primal graph. Our new algorithm is asymptotically optimal unless the Strong Exponential Time Hypothesis (SETH) fails.","publish_time":1593129600000,"author_summary":" Slivovsky, Friedrich; Szeider, Stefan","abstract_summary":" The propositional model counting problem<br>(#SAT) is known to be fixed-parameter-tractable<br>(FPT) when parameterized by the width k of a given tree<br>decomposition of the incidence graph. The running time of the<br>fastest known FPT algorithm contains the exponential<br>factor of [Formula: see text]. We improve this factor<br>to [Formula: see text] by utilizing fast<br>algorithms for computing the zeta transform and covering<br>product of functions representing partial model<br>counts, thereby achieving the same running time as FPT<br>algorithms that are parameterized by the less general<br>treewidth of the primal graph. Our new algorithm is<br>asymptotically optimal unless the Strong...","title_summary":" A Faster Algorithm for Propositional Model<br>Counting Parameterized by Incidence Treewidth","x":-23.8840484619,"y":43.5054664612,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.8840484619,"tsne_y":43.5054664612,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"vqohqhwj","source_x":"PMC","title":"Reasoning About Strong Inconsistency in ASP","doi":"10.1007\/978-3-030-51825-7_24","abstract":"The last decade has witnessed remarkable improvements in the analysis of inconsistent formulas, namely in the case of Boolean Satisfiability (SAT) formulas. However, these successes have been restricted to monotonic logics. Recent work proposed the notion of strong inconsistency for a number of non-monotonic logics, including Answer Set Programming (ASP). This paper shows how algorithms for reasoning about inconsistency in monotonic logics can be extended to the case of ASP programs, in the concrete case of strong inconsistency. Initial experimental results illustrate the potential of the proposed approach.","publish_time":1593129600000,"author_summary":" Menc\u00eda, Carlos; Marques-Silva, Joao","abstract_summary":" The last decade has witnessed remarkable<br>improvements in the analysis of inconsistent formulas,<br>namely in the case of Boolean Satisfiability (SAT)<br>formulas. However, these successes have been restricted<br>to monotonic logics. Recent work proposed the<br>notion of strong inconsistency for a number of<br>non-monotonic logics, including Answer Set Programming<br>(ASP). This paper shows how algorithms for reasoning<br>about inconsistency in monotonic logics can be<br>extended to the case of ASP programs, in the concrete case<br>of strong inconsistency. Initial experimental<br>results illustrate the potential of the proposed<br>approach.","title_summary":" Reasoning About Strong Inconsistency in ASP","x":-25.4480609894,"y":44.6829452515,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.4480609894,"tsne_y":44.6829452515,"subcluster":38,"subcluster_description":"Proof Cyclesmechanised Modal Model","shape":"p"},{"cord_uid":"86q6amxv","source_x":"PMC","title":"Reducing Bit-Vector Polynomials to SAT Using Gr\u00f6bner Bases","doi":"10.1007\/978-3-030-51825-7_26","abstract":"We address the satisfiability of systems of polynomial equations over bit-vectors. Instead of conventional bit-blasting, we exploit word-level inference to translate these systems into non-linear pseudo-boolean constraints. We derive the pseudo-booleans by simulating bit assignments through the addition of (linear) polynomials and applying a strong form of propagation by computing Gr\u00f6bner bases. By handling bit assignments symbolically, the number of Gr\u00f6bner basis calculations, along with the number of assignments, is reduced. The final Gr\u00f6bner basis yields expressions for the bit-vectors in terms of the symbolic bits, together with non-linear pseudo-boolean constraints on the symbolic variables, modulo a power of two. The pseudo-booleans can be solved by translation into classical linear pseudo-boolean constraints (without a modulo) or by encoding them as propositional formulae, for which a novel translation process is described.","publish_time":1593129600000,"author_summary":" Seed, Thomas; King, Andy; Evans, Neil","abstract_summary":" We address the satisfiability of systems of<br>polynomial equations over bit-vectors. Instead of<br>conventional bit-blasting, we exploit word-level<br>inference to translate these systems into non-linear<br>pseudo-boolean constraints. We derive the pseudo-booleans by<br>simulating bit assignments through the addition of<br>(linear) polynomials and applying a strong form of<br>propagation by computing Gr\u00f6bner bases. By handling bit<br>assignments symbolically, the number of Gr\u00f6bner basis<br>calculations, along with the number of assignments, is<br>reduced. The final Gr\u00f6bner basis yields expressions for<br>the bit-vectors in terms of the symbolic bits,<br>together with non-linear pseudo-boolean constraints<br>on the symbolic variables, modulo a power of two....","title_summary":" Reducing Bit-Vector Polynomials to SAT Using<br>Gr\u00f6bner Bases","x":-24.1061325073,"y":42.9672088623,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.1061325073,"tsne_y":42.9672088623,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"ne1pi1p9","source_x":"PMC","title":"SAT-Based Encodings for Optimal Decision Trees with Explicit Paths","doi":"10.1007\/978-3-030-51825-7_35","abstract":"Decision trees play an important role both in Machine Learning and Knowledge Representation. They are attractive due to their immediate interpretability. In the spirit of Occam\u2019s razor, and interpretability, it is desirable to calculate the smallest tree. This, however, has proven to be a challenging task and greedy approaches are typically used to learn trees in practice. Nevertheless, recent work showed that by the use of SAT solvers one may calculate the optimal size tree for real-world benchmarks. This paper proposes a novel SAT-based encoding that explicitly models paths in the tree, which enables us to control the tree\u2019s depth as well as size. At the level of individual SAT calls, we investigate splitting the search space into tree topologies. Our tool outperforms the existing implementation. But also, the experimental results show that minimizing the depth first and then minimizing the number of nodes enables solving a larger set of instances.","publish_time":1593129600000,"author_summary":" Janota, Mikol\u00e1\u0161; Morgado, Ant\u00f3nio","abstract_summary":" Decision trees play an important role both in<br>Machine Learning and Knowledge Representation. They<br>are attractive due to their immediate<br>interpretability. In the spirit of Occam\u2019s razor, and<br>interpretability, it is desirable to calculate the smallest tree.<br>This, however, has proven to be a challenging task and<br>greedy approaches are typically used to learn trees in<br>practice. Nevertheless, recent work showed that by the<br>use of SAT solvers one may calculate the optimal<br>size tree for real-world benchmarks. This paper<br>proposes a novel SAT-based encoding that explicitly<br>models paths in the tree, which enables us to control<br>the tree\u2019s depth...","title_summary":" SAT-Based Encodings for Optimal Decision<br>Trees with Explicit Paths","x":-25.0595245361,"y":42.7767486572,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.0595245361,"tsne_y":42.7767486572,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"8crdtoq5","source_x":"PMC","title":"Mycielski Graphs and [Formula: see text] Proofs","doi":"10.1007\/978-3-030-51825-7_15","abstract":"Mycielski graphs are a family of triangle-free graphs [Formula: see text] with arbitrarily high chromatic number. [Formula: see text] has chromatic number k and there is a short informal proof of this fact, yet finding proofs of it via automated reasoning techniques has proved to be a challenging task. In this paper, we study the complexity of clausal proofs of the uncolorability of [Formula: see text] with [Formula: see text] colors. In particular, we consider variants of the [Formula: see text] (propagation redundancy) proof system that are without new variables, and with or without deletion. These proof systems are of interest due to their potential uses for proof search. As our main result, we present a sublinear-length and constant-width [Formula: see text] proof without new variables or deletion. We also implement a proof generator and verify the correctness of our proof. Furthermore, we consider formulas extended with clauses from the proof until a short resolution proof exists, and investigate the performance of CDCL in finding the short proof. This turns out to be difficult for CDCL with the standard heuristics. Finally, we describe an approach inspired by SAT sweeping to find proofs of these extended formulas.","publish_time":1593129600000,"author_summary":" Yolcu, Emre; Wu, Xinyu; Heule, Marijn J. H.","abstract_summary":" Mycielski graphs are a family of triangle-free<br>graphs [Formula: see text] with arbitrarily high<br>chromatic number. [Formula: see text] has chromatic<br>number k and there is a short informal proof of this<br>fact, yet finding proofs of it via automated<br>reasoning techniques has proved to be a challenging task.<br>In this paper, we study the complexity of clausal<br>proofs of the uncolorability of [Formula: see text]<br>with [Formula: see text] colors. In particular, we<br>consider variants of the [Formula: see text]<br>(propagation redundancy) proof system that are without new<br>variables, and with or without deletion. These proof<br>systems are of...","title_summary":" Mycielski Graphs and [Formula: see text]<br>Proofs","x":-22.7615222931,"y":43.9550056458,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7615222931,"tsne_y":43.9550056458,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"gh6r60c5","source_x":"PMC","title":"On the Sparsity of XORs in Approximate Model Counting","doi":"10.1007\/978-3-030-51825-7_18","abstract":"Given a Boolean formula [Formula: see text], the problem of model counting, also referred to as #SAT, is to compute the number of solutions of [Formula: see text]. The hashing-based techniques for approximate counting have emerged as a dominant approach, promising achievement of both scalability and rigorous theoretical guarantees. The standard construction of strongly 2-universal hash functions employs dense XORs (i.e., involving half of the variables in expectation), which is widely known to cause degradation in the runtime performance of state of the art [Formula: see text] solvers. Consequently, the past few years have witnessed an intense activity in the design of sparse XORs as hash functions. Such constructions have been proposed with beliefs to provide runtime performance improvement along with theoretical guarantees similar to that of dense XORs. The primary contribution of this paper is a rigorous theoretical and empirical analysis to understand the effect of the sparsity of XORs. In contradiction to prior beliefs of applicability of analysis for sparse hash functions to all the hashing-based techniques, we prove a contradictory result. We show that the best-known bounds obtained for sparse XORs are still too weak to yield theoretical guarantees for a large class of hashing-based techniques, including the state of the art approach [Formula: see text]. We then turn to a rigorous empirical analysis of the performance benefits of sparse hash functions. To this end, we first design, to the best of our knowledge, the most efficient algorithm called [Formula: see text] using sparse hash functions, which achieves at least up to two orders of magnitude performance improvement over its predecessor. Contradicting the current beliefs, we observe that [Formula: see text] still falls short of [Formula: see text] in runtime performance despite the usage of dense XORs in [Formula: see text]. In conclusion, our work showcases that the question of whether it is possible to use short XORs to achieve scalability while providing strong theoretical guarantees is still wide open.","publish_time":1593129600000,"author_summary":" Agrawal, Durgesh; Bhavishya; Meel, Kuldeep S.","abstract_summary":" Given a Boolean formula [Formula: see text],<br>the problem of model counting, also referred to as<br>#SAT, is to compute the number of solutions of<br>[Formula: see text]. The hashing-based techniques for<br>approximate counting have emerged as a dominant approach,<br>promising achievement of both scalability and rigorous<br>theoretical guarantees. The standard construction of<br>strongly 2-universal hash functions employs dense XORs<br>(i.e., involving half of the variables in<br>expectation), which is widely known to cause degradation in<br>the runtime performance of state of the art<br>[Formula: see text] solvers. Consequently, the past few<br>years have witnessed an intense activity in the...","title_summary":" On the Sparsity of XORs in Approximate Model<br>Counting","x":-23.5609397888,"y":42.7515296936,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.5609397888,"tsne_y":42.7515296936,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"yo5d6oac","source_x":"PMC","title":"Equivalence Between Systems Stronger Than Resolution","doi":"10.1007\/978-3-030-51825-7_13","abstract":"In recent years there has been an increasing interest in studying proof systems stronger than Resolution, with the aim of building more efficient SAT solvers based on them. In defining these proof systems, we try to find a balance between the power of the proof system (the size of the proofs required to refute a formula) and the difficulty of finding the proofs. Among those proof systems we can mention Circular Resolution, MaxSAT Resolution with Extensions and MaxSAT Resolution with the Dual-Rail encoding. In this paper we study the relative power of those proof systems from a theoretical perspective. We prove that Circular Resolution and MaxSAT Resolution with extension are polynomially equivalent proof systems. This result is generalized to arbitrary sets of inference rules with proof constructions based on circular graphs or based on weighted clauses. We also prove that when we restrict the Split rule (that both systems use) to bounded size clauses, these two restricted systems are also equivalent. Finally, we show the relationship between these two restricted systems and Dual-Rail MaxSAT Resolution.","publish_time":1593129600000,"author_summary":" Bonet, Maria Luisa; Levy, Jordi","abstract_summary":" In recent years there has been an increasing<br>interest in studying proof systems stronger than<br>Resolution, with the aim of building more efficient SAT<br>solvers based on them. In defining these proof systems,<br>we try to find a balance between the power of the<br>proof system (the size of the proofs required to<br>refute a formula) and the difficulty of finding the<br>proofs. Among those proof systems we can mention<br>Circular Resolution, MaxSAT Resolution with<br>Extensions and MaxSAT Resolution with the Dual-Rail<br>encoding. In this paper we study the relative power of<br>those proof systems from a theoretical perspective.<br>We...","title_summary":" Equivalence Between Systems Stronger Than<br>Resolution","x":-25.0498809814,"y":43.8563575745,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.0498809814,"tsne_y":43.8563575745,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"74nwwx3m","source_x":"PMC","title":"A Lower Bound on DNNF Encodings of Pseudo-Boolean Constraints","doi":"10.1007\/978-3-030-51825-7_22","abstract":"Two major considerations when encoding pseudo-Boolean (PB) constraints into SAT are the size of the encoding and its propagation strength, that is, the guarantee that it has a good behaviour under unit propagation. Several encodings with propagation strength guarantees rely upon prior compilation of the constraints into DNNF (decomposable negation normal form), BDD (binary decision diagram), or some other sub-variants. However it has been shown that there exist PB-constraints whose ordered BDD (OBDD) representations, and thus the inferred CNF encodings, all have exponential size. Since DNNFs are more succinct than OBDDs, preferring encodings via DNNF to avoid size explosion seems a legitimate choice. Yet in this paper, we prove the existence of PB-constraints whose DNNFs all require exponential size.","publish_time":1593129600000,"author_summary":" de Colnet, Alexis","abstract_summary":" Two major considerations when encoding<br>pseudo-Boolean (PB) constraints into SAT are the size of the<br>encoding and its propagation strength, that is, the<br>guarantee that it has a good behaviour under unit<br>propagation. Several encodings with propagation strength<br>guarantees rely upon prior compilation of the constraints<br>into DNNF (decomposable negation normal form), BDD<br>(binary decision diagram), or some other<br>sub-variants. However it has been shown that there exist<br>PB-constraints whose ordered BDD (OBDD) representations, and<br>thus the inferred CNF encodings, all have<br>exponential size. Since DNNFs are more succinct than OBDDs,<br>preferring encodings via DNNF to avoid size explosion<br>seems...","title_summary":" A Lower Bound on DNNF Encodings of<br>Pseudo-Boolean Constraints","x":-24.9536762238,"y":43.2917747498,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.9536762238,"tsne_y":43.2917747498,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"qg43oamv","source_x":"PMC","title":"Multi-linear Strategy Extraction for QBF Expansion Proofs via Local Soundness","doi":"10.1007\/978-3-030-51825-7_30","abstract":"In applications, QBF solvers are expected to not only decide whether a given formula is true or false but also return a solution in the form of a strategy. Determining whether strategies can be efficiently extracted from proof traces generated by QBF solvers is a fundamental research task. Most resolution-based proof systems are known to implicitly support polynomial-time strategy extraction through a simulation of the evaluation game associated with an input formula, but this approach introduces large constant factors and results in unwieldy circuit representations. In this work, we present an explicit polynomial-time strategy extraction algorithm for the [Formula: see text] proof system. This system is used by expansion-based solvers that implement counterexample-guided abstraction refinement (CEGAR), currently one of the most effective QBF solving paradigms. Our argument relies on a Curry-Howard style correspondence between strategies and [Formula: see text] derivations, where each strategy realizes an invariant obtained from an annotated clause derived in the proof system.","publish_time":1593129600000,"author_summary":" Schlaipfer, Matthias; Slivovsky, Friedrich;<br>Weissenbacher, Georg; Zuleger, Florian","abstract_summary":" In applications, QBF solvers are expected to<br>not only decide whether a given formula is true or<br>false but also return a solution in the form of a<br>strategy. Determining whether strategies can be<br>efficiently extracted from proof traces generated by QBF<br>solvers is a fundamental research task. Most<br>resolution-based proof systems are known to implicitly support<br>polynomial-time strategy extraction through a simulation of<br>the evaluation game associated with an input<br>formula, but this approach introduces large constant<br>factors and results in unwieldy circuit<br>representations. In this work, we present an explicit<br>polynomial-time strategy extraction algorithm for the<br>[Formula: see...","title_summary":" Multi-linear Strategy Extraction for QBF<br>Expansion Proofs via Local Soundness","x":-25.3169231415,"y":43.8361663818,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3169231415,"tsne_y":43.8361663818,"subcluster":27,"subcluster_description":"Comprehensive Systemsmultilevel Typed Graph","shape":"p"},{"cord_uid":"klau8576","source_x":"PMC","title":"On CDCL-Based Proof Systems with the Ordered Decision Strategy","doi":"10.1007\/978-3-030-51825-7_12","abstract":"We prove that CDCL SAT-solvers with the ordered decision strategy and the DECISION learning scheme are equivalent to ordered resolution. We also prove that, by replacing this learning scheme with its opposite, which learns the first possible non-conflict clause, they become equivalent to general resolution. In both results, we allow nondeterminism in the solver\u2019s ability to perform unit propagation, conflict analysis, and restarts in a way that is similar to previous works in the literature. To aid the presentation of our results, and possibly future research, we define a model and language for CDCL-based proof systems \u2013 particularly those with nonstandard features \u2013 that allow for succinct and precise theorem statements.","publish_time":1593129600000,"author_summary":" Mull, Nathan; Pang, Shuo; Razborov, Alexander","abstract_summary":" We prove that CDCL SAT-solvers with the ordered<br>decision strategy and the DECISION learning scheme are<br>equivalent to ordered resolution. We also prove that, by<br>replacing this learning scheme with its opposite, which<br>learns the first possible non-conflict clause, they<br>become equivalent to general resolution. In both<br>results, we allow nondeterminism in the solver\u2019s<br>ability to perform unit propagation, conflict<br>analysis, and restarts in a way that is similar to previous<br>works in the literature. To aid the presentation of<br>our results, and possibly future research, we<br>define a model and language for CDCL-based proof<br>systems \u2013 particularly those with...","title_summary":" On CDCL-Based Proof Systems with the Ordered<br>Decision Strategy","x":-25.3379020691,"y":43.5632171631,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.3379020691,"tsne_y":43.5632171631,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"43csumwz","source_x":"PMC","title":"MACER: A Modular Framework for Accelerated Compilation Error Repair","doi":"10.1007\/978-3-030-52237-7_9","abstract":"Automated compilation error repair, the problem of suggesting fixes to buggy programs that fail to compile, has pedagogical applications for novice programmers who find compiler error messages cryptic and unhelpful. Existing works frequently involve black-box application of generative models, e.g. sequence-to-sequence prediction (TRACER) or reinforcement learning (RLAssist). Although convenient, this approach is inefficient at targeting specific error types as well as increases training costs. We present MACER, a novel technique for accelerated error repair based on a modular segregation of the repair process into repair identification and repair application. MACER uses powerful yet inexpensive learning techniques such as multi-label classifiers and rankers to first identify the type of repair required and then apply the suggested repair. Experiments indicate that this fine-grained approach offers not only superior error correction, but also much faster training and prediction. On a benchmark dataset of 4K buggy programs collected from actual student submissions, MACER outperforms existing methods by 20% at suggesting fixes for popular errors while being competitive or better at other errors. MACER offers a training time speedup of [Formula: see text] over TRACER and [Formula: see text] over RLAssist, and a test time speedup of [Formula: see text] over both.","publish_time":1591660800000,"author_summary":" Chhatbar, Darshak; Ahmed, Umair Z.; Kar,<br>Purushottam","abstract_summary":" Automated compilation error repair, the<br>problem of suggesting fixes to buggy programs that fail<br>to compile, has pedagogical applications for<br>novice programmers who find compiler error messages<br>cryptic and unhelpful. Existing works frequently<br>involve black-box application of generative models,<br>e.g. sequence-to-sequence prediction (TRACER) or<br>reinforcement learning (RLAssist). Although convenient,<br>this approach is inefficient at targeting specific<br>error types as well as increases training costs. We<br>present MACER, a novel technique for accelerated error<br>repair based on a modular segregation of the repair<br>process into repair identification and repair<br>application. MACER uses powerful yet inexpensive learning<br>techniques such as multi-label classifiers...","title_summary":" MACER: A Modular Framework for Accelerated<br>Compilation Error Repair","x":-26.3939914703,"y":41.6703872681,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.3939914703,"tsne_y":41.6703872681,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"fyyw2hlb","source_x":"PMC","title":"When Similarities Among Devices are Taken for Granted: Another Look at Portability","doi":"10.1007\/978-3-030-51938-4_17","abstract":"The original idea of profiling implies attacking one device with a leakage model generated from an \u201cidentical copy\u201d, but this concept cannot be always enforced. The leakage model is commonly generated with traces from an \u201copen device\u201d, assuming that a model which works for one device should work for another copy as well. In practice, applying a leakage model to a different copy of the same device (commonly called portability) is a hard problem to deal with, as intrinsic differences in the devices or the experimental setups used to obtain the traces cause behavioural variations which lead to an unsuccessful attack. In this paper we propose a novel similarity assessment technique that allows evaluators to quantify the differences among various copies of the same device. Moreover, we support this technique with actual experiments to show that this metric is directly related to the portability issue. Finally, we derive a method that improves the performance of template attacks.","publish_time":1591401600000,"author_summary":" Rioja, Unai; Batina, Lejla; Armendariz, Igor","abstract_summary":" The original idea of profiling implies<br>attacking one device with a leakage model generated from<br>an \u201cidentical copy\u201d, but this concept cannot be<br>always enforced. The leakage model is commonly<br>generated with traces from an \u201copen device\u201d, assuming<br>that a model which works for one device should work<br>for another copy as well. In practice, applying a<br>leakage model to a different copy of the same device<br>(commonly called portability) is a hard problem to deal<br>with, as intrinsic differences in the devices or the<br>experimental setups used to obtain the traces cause<br>behavioural variations which lead to an unsuccessful...","title_summary":" When Similarities Among Devices are Taken for<br>Granted: Another Look at Portability","x":-26.9731483459,"y":41.1256828308,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.9731483459,"tsne_y":41.1256828308,"subcluster":3,"subcluster_description":"Polyglot Data Access Layer","shape":"p"},{"cord_uid":"zszcw0xz","source_x":"PMC","title":"A SAT-Based Approach for Index Calculus on Binary Elliptic Curves","doi":"10.1007\/978-3-030-51938-4_11","abstract":"Logical cryptanalysis, first introduced by Massacci in 2000, is a viable alternative to common algebraic cryptanalysis techniques over boolean fields. With xor operations being at the core of many cryptographic problems, recent research in this area has focused on handling xor clauses efficiently. In this paper, we investigate solving the point decomposition step of the index calculus method for prime-degree extension fields [Formula: see text], using sat solving methods. We experimented with different sat solvers and decided on using WDSat, a solver dedicated to this specific problem. We extend this solver by adding a novel symmetry breaking technique and optimizing the time complexity of the point decomposition step by a factor of m! for the [Formula: see text](th) summation polynomial. While asymptotically solving the point decomposition problem with this method has exponential worst time complexity in the dimension l of the vector space defining the factor base, experimental running times show that the presented sat solving technique is significantly faster than current algebraic methods based on Gr\u00f6bner basis computation. For the values l and n considered in the experiments, the WDSat solver coupled with our symmetry breaking technique is up to 300 times faster than Magma\u2019s F4 implementation, and this factor grows with l and n.","publish_time":1591401600000,"author_summary":" Trimoska, Monika; Ionica, Sorina; Dequen,<br>Gilles","abstract_summary":" Logical cryptanalysis, first introduced by<br>Massacci in 2000, is a viable alternative to common<br>algebraic cryptanalysis techniques over boolean<br>fields. With xor operations being at the core of many<br>cryptographic problems, recent research in this area has<br>focused on handling xor clauses efficiently. In this<br>paper, we investigate solving the point<br>decomposition step of the index calculus method for<br>prime-degree extension fields [Formula: see text], using<br>sat solving methods. We experimented with<br>different sat solvers and decided on using WDSat, a solver<br>dedicated to this specific problem. We extend this solver<br>by adding a novel symmetry breaking technique and<br>optimizing...","title_summary":" A SAT-Based Approach for Index Calculus on<br>Binary Elliptic Curves","x":-23.8726634979,"y":42.2499313354,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.8726634979,"tsne_y":42.2499313354,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"abq396hw","source_x":"PMC","title":"Online Template Attack on ECDSA:: Extracting Keys via the Other Side","doi":"10.1007\/978-3-030-51938-4_16","abstract":"We retrieve the ephemeral private key from the power trace of a single scalar multiplication in an ECDSA signature generation and from that the signing private key using an online template attack. The innovation is that we generate the profiling traces using ECDSA signature verification on the same device. The attack can be prevented by randomization of the (projective) coordinates of the base point.","publish_time":1591401600000,"author_summary":" Roelofs, Niels; Samwel, Niels; Batina, Lejla;<br>Daemen, Joan","abstract_summary":" We retrieve the ephemeral private key from the<br>power trace of a single scalar multiplication in an<br>ECDSA signature generation and from that the signing<br>private key using an online template attack. The<br>innovation is that we generate the profiling traces using<br>ECDSA signature verification on the same device. The<br>attack can be prevented by randomization of the<br>(projective) coordinates of the base point.","title_summary":" Online Template Attack on ECDSA:: Extracting<br>Keys via the Other Side","x":-24.0975055695,"y":40.3030433655,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0975055695,"tsne_y":40.3030433655,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"sz8aa992","source_x":"PMC","title":"LMS vs XMSS: Comparison of Stateful Hash-Based Signature Schemes on ARM Cortex-M4","doi":"10.1007\/978-3-030-51938-4_13","abstract":"Stateful hash-based signature schemes are among the most efficient approaches for post-quantum signature schemes. Although not suitable for general use, they may be suitable for some use cases on constrained devices. LMS and XMSS are hash-based signature schemes that are conjectured to be quantum secure. In this work, we compared multiple instantiations of both schemes on an ARM Cortex-M4. More precisely, we compared performance, stack consumption, and other figures for key generation, signing and verifying. To achieve this, we evaluated LMS and XMSS using optimised implementations of SHA-256, SHAKE256, Gimli-Hash, and different variants of Keccak. Furthermore, we present slightly optimised implementations of XMSS achieving speedups of up to [Formula: see text] for key generation, [Formula: see text] for signing, and [Formula: see text] for verifying.","publish_time":1591401600000,"author_summary":" Campos, Fabio; Kohlstadt, Tim; Reith,<br>Steffen; St\u00f6ttinger, Marc","abstract_summary":" Stateful hash-based signature schemes are<br>among the most efficient approaches for<br>post-quantum signature schemes. Although not suitable for<br>general use, they may be suitable for some use cases on<br>constrained devices. LMS and XMSS are hash-based signature<br>schemes that are conjectured to be quantum secure. In<br>this work, we compared multiple instantiations of<br>both schemes on an ARM Cortex-M4. More precisely, we<br>compared performance, stack consumption, and other<br>figures for key generation, signing and verifying. To<br>achieve this, we evaluated LMS and XMSS using optimised<br>implementations of SHA-256, SHAKE256, Gimli-Hash, and<br>different variants of Keccak. Furthermore, we present<br>slightly optimised...","title_summary":" LMS vs XMSS: Comparison of Stateful Hash-Based<br>Signature Schemes on ARM Cortex-M4","x":-24.158290863,"y":40.452671051,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.158290863,"tsne_y":40.452671051,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"dhnunmn6","source_x":"PMC","title":"Attacking RSA Using an Arbitrary Parameter","doi":"10.1007\/978-3-030-51938-4_19","abstract":"In this paper, we introduce a parameter u that is related to N via an arbitrary relation. By knowing the parameter along with RSA public key pairs, (N, e), we conduct two new attacks on the RSA cryptosystem. The first attack works on the equation [Formula: see text] where [Formula: see text] is the best known lower bound of [Formula: see text]. It combines the continued fraction method and Coppersmith\u2019s method to factor N in polynomial time. The second attack shows that given [Formula: see text] for [Formula: see text] and a fixed X, we can simultaneously factor the k RSA moduli. It manipulates the result from diophantine approximation to enable the conditions of Coppersmith\u2019s method. These attacks show that there are more possible weak RSA key pairs.","publish_time":1591401600000,"author_summary":" Ariffin, Muhammad Rezal Kamel; Ghafar, Amir<br>Hamzah Abd; Asbullah, Muhammad Asyraf","abstract_summary":" In this paper, we introduce a parameter u that is<br>related to N via an arbitrary relation. By knowing the<br>parameter along with RSA public key pairs, (N, e), we<br>conduct two new attacks on the RSA cryptosystem. The<br>first attack works on the equation [Formula: see<br>text] where [Formula: see text] is the best known<br>lower bound of [Formula: see text]. It combines the<br>continued fraction method and Coppersmith\u2019s method to<br>factor N in polynomial time. The second attack shows<br>that given [Formula: see text] for [Formula: see<br>text] and a fixed X, we can simultaneously factor the k...","title_summary":" Attacking RSA Using an Arbitrary Parameter","x":-24.0058364868,"y":40.6739845276,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0058364868,"tsne_y":40.6739845276,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"xcba98f2","source_x":"PMC","title":"Hash-Based Signatures Revisited: A Dynamic FORS with Adaptive Chosen Message Security","doi":"10.1007\/978-3-030-51938-4_12","abstract":"FORS is the underlying hash-based few-time signing scheme in SPHINCS[Formula: see text], one of the nine signature schemes which advanced to round 2 of the NIST Post-Quantum Cryptography standardization competition. In this paper, we analyze the security of FORS with respect to adaptive chosen message attacks. We show that in such a setting, the security of FORS decreases significantly with each signed message when compared to its security against non-adaptive chosen message attacks. We propose a chaining mechanism that with slightly more computation, dynamically binds the Obtain Random Subset (ORS) generation with signing, hence, eliminating the offline advantage of adaptive chosen message adversaries. We apply our chaining mechanism to FORS and present DFORS whose security against adaptive chosen message attacks is equal to the non-adaptive security of FORS. In a nutshell, using SPHINCS[Formula: see text]-128s parameters, FORS provides 75-bit security and DFORS achieves 150-bit security with respect to adaptive chosen message attacks after signing one message. We note that our analysis does not affect the claimed security of SPHINCS[Formula: see text]. Nevertheless, this work provides a better understanding of FORS and other HORS variants, and furnishes a solution if new adaptive cryptanalytic techniques on SPHINCS[Formula: see text] emerge.","publish_time":1591401600000,"author_summary":" Yehia, Mahmoud; AlTawy, Riham; Aaron<br>Gulliver, T.","abstract_summary":" FORS is the underlying hash-based few-time<br>signing scheme in SPHINCS[Formula: see text], one of<br>the nine signature schemes which advanced to round<br>2 of the NIST Post-Quantum Cryptography<br>standardization competition. In this paper, we analyze the<br>security of FORS with respect to adaptive chosen message<br>attacks. We show that in such a setting, the security of<br>FORS decreases significantly with each signed<br>message when compared to its security against<br>non-adaptive chosen message attacks. We propose a chaining<br>mechanism that with slightly more computation,<br>dynamically binds the Obtain Random Subset (ORS)<br>generation with signing, hence, eliminating the offline<br>advantage of adaptive...","title_summary":" Hash-Based Signatures Revisited: A Dynamic<br>FORS with Adaptive Chosen Message Security","x":-24.0885257721,"y":40.375213623,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0885257721,"tsne_y":40.375213623,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"v1woxuck","source_x":"PMC","title":"LESS is More: Code-Based Signatures Without Syndromes","doi":"10.1007\/978-3-030-51938-4_3","abstract":"Devising efficient and secure signature schemes based on coding theory is still considered a challenge by the cryptographic community. In this paper, we construct a signature scheme by exploring a new approach to the area. To do this, we design a zero-knowledge identification scheme, which we then render static via standard means (e.g. Fiat-Shamir). We show that practical instances of our protocol have the potential to outperform the state of the art on code-based signatures, achieving small data sizes with a low computational complexity.","publish_time":1591401600000,"author_summary":" Biasse, Jean-Fran\u00e7ois; Micheli, Giacomo;<br>Persichetti, Edoardo; Santini, Paolo","abstract_summary":" Devising efficient and secure signature<br>schemes based on coding theory is still considered a<br>challenge by the cryptographic community. In this paper,<br>we construct a signature scheme by exploring a new<br>approach to the area. To do this, we design a<br>zero-knowledge identification scheme, which we then render<br>static via standard means (e.g. Fiat-Shamir). We show<br>that practical instances of our protocol have the<br>potential to outperform the state of the art on code-based<br>signatures, achieving small data sizes with a low<br>computational complexity.","title_summary":" LESS is More: Code-Based Signatures Without<br>Syndromes","x":-24.093460083,"y":40.4919815063,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.093460083,"tsne_y":40.4919815063,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"wqsg37yx","source_x":"PMC","title":"A Tale of Three Signatures: Practical Attack of ECDSA with wNAF","doi":"10.1007\/978-3-030-51938-4_18","abstract":"Attacking ECDSA with wNAF implementation for the scalar multiplication first requires some side channel analysis to collect information, then lattice based methods to recover the secret key. In this paper, we reinvestigate the construction of the lattice used in one of these methods, the Extended Hidden Number Problem (EHNP). We find the secret key with only 3 signatures, thus reaching a known theoretical bound, whereas best previous methods required at least 4 signatures in practice. Given a specific leakage model, our attack is more efficient than previous attacks, and for most cases, has better probability of success. To obtain such results, we perform a detailed analysis of the parameters used in the attack and introduce a preprocessing method which reduces by a factor up to 7 the total time to recover the secret key for some parameters. We perform an error resilience analysis which has never been done before in the setup of EHNP. Our construction find the secret key with a small amount of erroneous traces, up to [Formula: see text] of false digits, and [Formula: see text] with a specific type of error.","publish_time":1591401600000,"author_summary":" De Micheli, Gabrielle; Piau, R\u00e9mi; Pierrot,<br>C\u00e9cile","abstract_summary":" Attacking ECDSA with wNAF implementation for<br>the scalar multiplication first requires some<br>side channel analysis to collect information, then<br>lattice based methods to recover the secret key. In this<br>paper, we reinvestigate the construction of the<br>lattice used in one of these methods, the Extended<br>Hidden Number Problem (EHNP). We find the secret key<br>with only 3 signatures, thus reaching a known<br>theoretical bound, whereas best previous methods required<br>at least 4 signatures in practice. Given a<br>specific leakage model, our attack is more efficient<br>than previous attacks, and for most cases, has<br>better probability of success. To obtain such...","title_summary":" A Tale of Three Signatures: Practical Attack of<br>ECDSA with wNAF","x":-24.0809345245,"y":40.3883895874,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0809345245,"tsne_y":40.3883895874,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"xus30o7i","source_x":"PMC","title":"MixColumns Coefficient Property and Security of the AES with A Secret S-Box","doi":"10.1007\/978-3-030-51938-4_6","abstract":"The MixColumns operation is an important component providing diffusion for the AES. The branch number of it ensures that any continuous four rounds of the AES have at least 25 active S-Boxes, which makes the AES secure against the differential and linear cryptanalysis. However, the choices of the coefficients of the MixColumns matrix may undermine the AES security against some novel-type attacks. A particular property of the AES MixColumns matrix coefficient has been noticed in recent papers that each row or column of the matrix has elements that sum to zero. Several attacks have been developed taking advantage of the coefficient property. In this paper we investigate further the influence of the specific coefficient property on the AES security. Our target, which is also one of the targets of the previous works, is a 5-round AES variant with a secret S-Box. We will show how we take advantage of the coefficient property to extract the secret key directly without any assistance of the S-Box information. Compared with the previous similar attacks, the present attacks here are the best in terms of the complexity under the chosen-plaintext scenario.","publish_time":1591401600000,"author_summary":" An, Xin; Hu, Kai; Wang, Meiqin","abstract_summary":" The MixColumns operation is an important<br>component providing diffusion for the AES. The branch<br>number of it ensures that any continuous four rounds of<br>the AES have at least 25 active S-Boxes, which makes<br>the AES secure against the differential and linear<br>cryptanalysis. However, the choices of the coefficients of the<br>MixColumns matrix may undermine the AES security against<br>some novel-type attacks. A particular property of<br>the AES MixColumns matrix coefficient has been<br>noticed in recent papers that each row or column of the<br>matrix has elements that sum to zero. Several attacks<br>have been developed taking advantage of the...","title_summary":" MixColumns Coefficient Property and Security<br>of the AES with A Secret S-Box","x":-24.0694961548,"y":40.3991661072,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0694961548,"tsne_y":40.3991661072,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"01laioaz","source_x":"PMC","title":"Cryptanalysis of FlexAEAD","doi":"10.1007\/978-3-030-51938-4_8","abstract":"This paper analyzes the internal keyed permutation of FlexAEAD which is a round-1 candidate of the NIST LightWeight Cryptography Competition. In our analysis, we report an iterated truncated differential leveraging on a particular property of the AES S-box that becomes useful due to the particular nature of the diffusion layer of the round function. The differential holds with a low probability of [Formula: see text] for one round which allows it to penetrate the same number of rounds as claimed by the designers, but with a much lower complexity. Moreover, it can be easily extended to a key-recovery attack at a little extra cost. We further report a Super-Sbox construction in the internal permutation, which is exploited using the Yoyo game to devise a 6-round deterministic distinguisher and a 7-round key recovery attack for the 128-bit internal permutation. Similar attacks can be mounted for the 64-bit and 256-bit variants. All these attacks outperform the existing results of the designers as well as other third-party results. The iterated truncated differentials can be tweaked to mount forgery attacks similar to the ones given by Eichlseder [Formula: see text] [Formula: see text] Success probabilities of all the reported distinguishing attacks are shown to be high. All practical attacks have been experimentally verified. To the best of our knowledge, this work reports the first key-recovery attack on the internal keyed permutation of FlexAEAD.","publish_time":1591401600000,"author_summary":" Rahman, Mostafizar; Saha, Dhiman; Paul,<br>Goutam","abstract_summary":" This paper analyzes the internal keyed<br>permutation of FlexAEAD which is a round-1 candidate of the<br>NIST LightWeight Cryptography Competition. In our<br>analysis, we report an iterated truncated differential<br>leveraging on a particular property of the AES S-box that<br>becomes useful due to the particular nature of the<br>diffusion layer of the round function. The differential<br>holds with a low probability of [Formula: see text]<br>for one round which allows it to penetrate the same<br>number of rounds as claimed by the designers, but with a<br>much lower complexity. Moreover, it can be easily<br>extended to a key-recovery attack at...","title_summary":" Cryptanalysis of FlexAEAD","x":-24.0911178589,"y":40.4154205322,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0911178589,"tsne_y":40.4154205322,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"9fperze2","source_x":"PMC","title":"On Adaptive Attacks Against Jao-Urbanik\u2019s Isogeny-Based Protocol","doi":"10.1007\/978-3-030-51938-4_10","abstract":"The k-SIDH protocol is a static-static isogeny-based key agreement protocol. At Mathcrypt 2018, Jao and Urbanik introduced a variant of this protocol which uses non-scalar automorphisms of special elliptic curves to improve its efficiency. In this paper, we provide a new adaptive attack on Jao-Urbanik\u2019s protocol. The attack is a non-trivial adaptation of Galbraith-Petit-Shani-Ti\u2019s attack on SIDH (Asiacrypt 2016) and its extension to k-SIDH by Dobson-Galbraith-LeGrow-Ti-Zobernig (IACR eprint 2019). Our attack provides a speedup compared to a na\u00efve application of Dobson et al.\u2019s attack to Jao-Urbanik\u2019s scheme, exploiting its inherent structure. Estimating the security of k-SIDH and Jao-Urbanik\u2019s variant with respect to these attacks, k-SIDH provides better efficiency.","publish_time":1591401600000,"author_summary":" Basso, Andrea; Kutas, P\u00e9ter; Merz,<br>Simon-Philipp; Petit, Christophe; Weitk\u00e4mper, Charlotte","abstract_summary":" The k-SIDH protocol is a static-static<br>isogeny-based key agreement protocol. At Mathcrypt 2018, Jao<br>and Urbanik introduced a variant of this protocol<br>which uses non-scalar automorphisms of special<br>elliptic curves to improve its efficiency. In this<br>paper, we provide a new adaptive attack on<br>Jao-Urbanik\u2019s protocol. The attack is a non-trivial<br>adaptation of Galbraith-Petit-Shani-Ti\u2019s attack on SIDH<br>(Asiacrypt 2016) and its extension to k-SIDH by<br>Dobson-Galbraith-LeGrow-Ti-Zobernig (IACR eprint 2019). Our attack provides a<br>speedup compared to a na\u00efve application of Dobson et<br>al.\u2019s attack to Jao-Urbanik\u2019s scheme, exploiting<br>its inherent structure. Estimating the security<br>of k-SIDH and Jao-Urbanik\u2019s variant with...","title_summary":" On Adaptive Attacks Against Jao-Urbanik\u2019s<br>Isogeny-Based Protocol","x":-24.0772304535,"y":40.2991981506,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0772304535,"tsne_y":40.2991981506,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"c5rteoc8","source_x":"PMC","title":"Impossible Differential Cryptanalysis of Reduced-Round Tweakable TWINE","doi":"10.1007\/978-3-030-51938-4_5","abstract":"Tweakable TWINE (T-TWINE) is a new lightweight tweakable block cipher family proposed by Sakamoto et al. at IWSEC 2019. T-TWINE is the first Tweakable Block Cipher (TBC) that is built on Generalized Feistel Structure (GFS). It is based on the TWINE block cipher in addition to a simple tweak scheduling based on SKINNY\u2019s tweakey schedule. Similar to TWINE, it has two versions, namely, T-TWINE-80 and T-TWINE-128, both have a block length of 64 bits and employ keys of length 80 and 128 bits, respectively. In this paper, we present impossible differential attacks against reduced-round versions of T-TWINE-80 and T-TWINE-128. First, we present an 18-round impossible differential distinguisher against T-TWINE. Then, using this distinguisher, we attack 25 and 27 rounds of T-TWINE-80 and T-TWINE-128, respectively.","publish_time":1591401600000,"author_summary":" Tolba, Mohamed; ElSheikh, Muhammad; Youssef,<br>Amr M.","abstract_summary":" Tweakable TWINE (T-TWINE) is a new lightweight<br>tweakable block cipher family proposed by Sakamoto et al.<br>at IWSEC 2019. T-TWINE is the first Tweakable<br>Block Cipher (TBC) that is built on Generalized<br>Feistel Structure (GFS). It is based on the TWINE block<br>cipher in addition to a simple tweak scheduling based<br>on SKINNY\u2019s tweakey schedule. Similar to TWINE,<br>it has two versions, namely, T-TWINE-80 and<br>T-TWINE-128, both have a block length of 64 bits and employ<br>keys of length 80 and 128 bits, respectively. In this<br>paper, we present impossible differential attacks<br>against reduced-round versions of T-TWINE-80 and<br>T-TWINE-128. First,...","title_summary":" Impossible Differential Cryptanalysis of<br>Reduced-Round Tweakable TWINE","x":-24.0932273865,"y":40.4096908569,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0932273865,"tsne_y":40.4096908569,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"lb369g4j","source_x":"PMC","title":"A New Encoding Algorithm for a Multidimensional Version of the Montgomery Ladder","doi":"10.1007\/978-3-030-51938-4_20","abstract":"We propose a new encoding algorithm for the simultaneous differential multidimensional scalar point multiplication algorithm d-MUL. Previous encoding algorithms are known to have major drawbacks in their efficient and secure implementation. Some of these drawbacks have been avoided in a recent paper in 2018 at a cost of losing the general functionality of the point multiplication algorithm. In this paper, we address these issues. Our new encoding algorithm takes the binary representations of scalars as input, and constructs a compact binary sequence and a permutation, which explicitly determines a regular sequence of group operations to be performed in d-MUL. Our algorithm simply slides windows of size two over the scalars and it is very efficient. As a result, while preserving the full generality of d-MUL, we successfully eliminate the recursive integer matrix computations in the originally proposed encoding algorithms. We also expect that our new encoding algorithm will make it easier to implement d-MUL in constant time. Our results can be seen as the efficient and full generalization of the one dimensional Montgomery ladder to arbitrary dimension.","publish_time":1591401600000,"author_summary":" Hutchinson, Aaron; Karabina, Koray","abstract_summary":" We propose a new encoding algorithm for the<br>simultaneous differential multidimensional scalar point<br>multiplication algorithm d-MUL. Previous encoding<br>algorithms are known to have major drawbacks in their<br>efficient and secure implementation. Some of these<br>drawbacks have been avoided in a recent paper in 2018 at a<br>cost of losing the general functionality of the<br>point multiplication algorithm. In this paper, we<br>address these issues. Our new encoding algorithm takes<br>the binary representations of scalars as input,<br>and constructs a compact binary sequence and a<br>permutation, which explicitly determines a regular<br>sequence of group operations to be performed in d-MUL.<br>Our...","title_summary":" A New Encoding Algorithm for a<br>Multidimensional Version of the Montgomery Ladder","x":-23.6461238861,"y":41.5509109497,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.6461238861,"tsne_y":41.5509109497,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"rekki5hb","source_x":"PMC","title":"QA-NIZK Arguments of Same Opening for Bilateral Commitments","doi":"10.1007\/978-3-030-51938-4_1","abstract":"Zero-knowledge proofs of satisfiability of linear equations over a group are often used as a building block of more complex protocols. In particular, in an asymmetric bilinear group we often have two commitments in different sides of the pairing, and we want to prove that they open to the same value. This problem was tackled by Gonz\u00e1lez, Hevia and R\u00e0fols (ASIACRYPT 2015), who presented an aggregated proof, in the QA-NIZK setting, consisting of only four group elements. In this work, we present a more efficient proof, which is based on the same assumptions and consists of three group elements. We argue that our construction is optimal in terms of proof size.","publish_time":1591401600000,"author_summary":" R\u00e0fols, Carla; Silva, Javier","abstract_summary":" Zero-knowledge proofs of satisfiability of<br>linear equations over a group are often used as a<br>building block of more complex protocols. In<br>particular, in an asymmetric bilinear group we often have<br>two commitments in different sides of the pairing,<br>and we want to prove that they open to the same value.<br>This problem was tackled by Gonz\u00e1lez, Hevia and<br>R\u00e0fols (ASIACRYPT 2015), who presented an aggregated<br>proof, in the QA-NIZK setting, consisting of only four<br>group elements. In this work, we present a more<br>efficient proof, which is based on the same assumptions<br>and consists of three group elements. We...","title_summary":" QA-NIZK Arguments of Same Opening for<br>Bilateral Commitments","x":-24.0379390717,"y":40.6823501587,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0379390717,"tsne_y":40.6823501587,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"evy8dr4z","source_x":"PMC","title":"New Ideas to Build Noise-Free Homomorphic Cryptosystems","doi":"10.1007\/978-3-030-51938-4_21","abstract":"We design a very simple private-key encryption scheme whose decryption function is a rational function. This scheme is not born naturally homomorphic. To get homomorphic properties, a nonlinear additive homomorphic operator is specifically developed. The security analysis is based on symmetry considerations and we prove some formal results under the factoring assumption. In particular, we prove IND-CPA security in the generic ring model. Even if our security proof is not complete, we think that it is convincing and that the technical tools considered in this paper are interesting by themselves. Moreover, the factoring assumption is just needed to ensure that solving nonlinear equations or finding non-null polynomials with many roots is difficult. Consequently, the ideas behind our construction could be re-used in rings satisfying these properties. As motivating perspectives, we then propose to develop a simple multiplicative operator. To achieve this, randomness is added in our construction giving hope to remove the factoring assumption in order to get a pure multivariate encryption scheme.","publish_time":1591401600000,"author_summary":" Gavin, Gerald; Tainturier, Sandrine","abstract_summary":" We design a very simple private-key encryption<br>scheme whose decryption function is a rational<br>function. This scheme is not born naturally homomorphic.<br>To get homomorphic properties, a nonlinear<br>additive homomorphic operator is specifically<br>developed. The security analysis is based on symmetry<br>considerations and we prove some formal results under the<br>factoring assumption. In particular, we prove IND-CPA<br>security in the generic ring model. Even if our security<br>proof is not complete, we think that it is convincing<br>and that the technical tools considered in this<br>paper are interesting by themselves. Moreover, the<br>factoring assumption is just needed to ensure that...","title_summary":" New Ideas to Build Noise-Free Homomorphic<br>Cryptosystems","x":-24.0337371826,"y":40.5154457092,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0337371826,"tsne_y":40.5154457092,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"ebcsga6l","source_x":"PMC","title":"UC Updatable Databases and Applications","doi":"10.1007\/978-3-030-51938-4_4","abstract":"We define an ideal functionality [Formula: see text] and a construction [Formula: see text] for an updatable database ([Formula: see text]). [Formula: see text] is a two-party protocol between an updater and a reader. The updater sets the database and updates it at any time throughout the protocol execution. The reader computes zero-knowledge (ZK) proofs of knowledge of database entries. These proofs prove that a value is stored at a certain position in the database, without revealing the position or the value. (Non-)updatable databases are implicitly used as building block in priced oblivious transfer, privacy-preserving billing and other privacy-preserving protocols. Typically, in those protocols the updater signs each database entry, and the reader proves knowledge of a signature on a database entry. Updating the database requires a revocation mechanism to revoke signatures on outdated database entries. Our construction [Formula: see text] uses a non-hiding vector commitment (NHVC) scheme. The updater maps the database to a vector and commits to the database. This commitment can be updated efficiently at any time without needing a revocation mechanism. ZK proofs for reading a database entry have communication and amortized computation cost independent of the database size. Therefore, [Formula: see text] is suitable for large databases. We implement [Formula: see text] and our timings show that it is practical. In existing privacy-preserving protocols, a ZK proof of a database entry is intertwined with other tasks, e.g., proving further statements about the value read from the database or the position where it is stored. [Formula: see text] allows us to improve modularity in protocol design by separating those tasks. We show how to use [Formula: see text] as building block of a hybrid protocol along with other functionalities.","publish_time":1591401600000,"author_summary":" Damodaran, Aditya; Rial, Alfredo","abstract_summary":" We define an ideal functionality [Formula: see<br>text] and a construction [Formula: see text] for an<br>updatable database ([Formula: see text]). [Formula: see<br>text] is a two-party protocol between an updater and a<br>reader. The updater sets the database and updates it at<br>any time throughout the protocol execution. The<br>reader computes zero-knowledge (ZK) proofs of<br>knowledge of database entries. These proofs prove that a<br>value is stored at a certain position in the database,<br>without revealing the position or the value.<br>(Non-)updatable databases are implicitly used as building<br>block in priced oblivious transfer,<br>privacy-preserving billing and other privacy-preserving<br>protocols....","title_summary":" UC Updatable Databases and Applications","x":-23.4979743958,"y":43.5012397766,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.4979743958,"tsne_y":43.5012397766,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"4ly3iyys","source_x":"PMC","title":"Signatures of Knowledge for Boolean Circuits Under Standard Assumptions","doi":"10.1007\/978-3-030-51938-4_2","abstract":"This paper constructs unbounded simulation sound proofs for boolean circuit satisfiability under standard assumptions with proof size [Formula: see text] bilinear group elements, where d is the depth and n is the input size of the circuit. Our technical contribution is to add unbounded simulation soundness to a recent NIZK of Gonz\u00e1lez and R\u00e0fols (ASIACRYPT\u201919) with very small overhead. Our new scheme can be used to construct the most efficient Signature-of-Knowledge based on standard assumptions that also can be composed universally with other cryptographic protocols\/primitives.","publish_time":1591401600000,"author_summary":" Baghery, Karim; Gonz\u00e1lez, Alonso; Pindado,<br>Zaira; R\u00e0fols, Carla","abstract_summary":" This paper constructs unbounded simulation<br>sound proofs for boolean circuit satisfiability<br>under standard assumptions with proof size<br>[Formula: see text] bilinear group elements, where d is<br>the depth and n is the input size of the circuit. Our<br>technical contribution is to add unbounded simulation<br>soundness to a recent NIZK of Gonz\u00e1lez and R\u00e0fols<br>(ASIACRYPT\u201919) with very small overhead. Our new scheme can be<br>used to construct the most efficient<br>Signature-of-Knowledge based on standard assumptions that also can be<br>composed universally with other cryptographic<br>protocols\/primitives.","title_summary":" Signatures of Knowledge for Boolean Circuits<br>Under Standard Assumptions","x":-24.0923614502,"y":41.1505317688,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0923614502,"tsne_y":41.1505317688,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"xxt7nc2w","source_x":"PMC","title":"Round Optimal Secure Multisignature Schemes from Lattice with Public Key Aggregation and Signature Compression","doi":"10.1007\/978-3-030-51938-4_14","abstract":"This paper presents the first construction for an efficient multisignature (MS) in the lattice setting, achieving signature compression and public key aggregation simultaneously with single round signature generation. The multisignature size in our construction is the same as that of a single signature. The verification of a multisignature can be performed with the aggregated public key and the verifier gets convinced that the message has been signed by all the signers. More positively, our aggregated public key size is also the same as that of a single signer. Additionally, we extend our multisignature to an accountable subgroup multisignature (ASM) that permits any subset of potential signers to sign a common message with the property that the signature reveals the identities of the signers to any verifier. Our ASM scheme enjoys the same efficiency as that of our MS scheme without incurring any loss in the security reduction. We design our schemes in the plain public key model where there is no need to verify individual public keys. Our constructions are built in the standard lattice and are proven to be secure under the hardness of the short integer solution (SIS) problem in the random oracle model.","publish_time":1591401600000,"author_summary":" Kansal, Meenakshi; Dutta, Ratna","abstract_summary":" This paper presents the first construction for<br>an efficient multisignature (MS) in the lattice<br>setting, achieving signature compression and public<br>key aggregation simultaneously with single round<br>signature generation. The multisignature size in our<br>construction is the same as that of a single signature. The<br>verification of a multisignature can be performed with the<br>aggregated public key and the verifier gets convinced that<br>the message has been signed by all the signers. More<br>positively, our aggregated public key size is also the same<br>as that of a single signer. Additionally, we<br>extend our multisignature to an accountable subgroup<br>multisignature (ASM) that...","title_summary":" Round Optimal Secure Multisignature Schemes<br>from Lattice with Public Key Aggregation and<br>Signature Compression","x":-24.0687599182,"y":40.4168243408,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0687599182,"tsne_y":40.4168243408,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"pwcqac65","source_x":"PMC","title":"Sieve, Enumerate, Slice, and Lift:: Hybrid Lattice Algorithms for SVP via CVPP","doi":"10.1007\/978-3-030-51938-4_15","abstract":"Motivated by recent results on solving large batches of closest vector problem (CVP) instances, we study how these techniques can be combined with lattice enumeration to obtain faster methods for solving the shortest vector problem (SVP) on high-dimensional lattices. Theoretically, under common heuristic assumptions we show how to solve SVP in dimension d with a cost proportional to running a sieve in dimension [Formula: see text], resulting in a [Formula: see text] speedup and memory reduction compared to running a full sieve. Combined with techniques from [Ducas, Eurocrypt 2018] we can asymptotically get a total of [Formula: see text] dimensions for free for solving SVP. Practically, the main obstacles for observing a speedup in moderate dimensions appear to be that the leading constant in the [Formula: see text] term is rather small; that the overhead of the (batched) slicer may be large; and that competitive enumeration algorithms heavily rely on aggressive pruning techniques, which appear to be incompatible with our algorithms. These obstacles prevented this asymptotic speedup (compared to full sieving) from being observed in our experiments. However, it could be expected to become visible once optimized CVPP techniques are used in higher dimensional experiments.","publish_time":1591401600000,"author_summary":" Doulgerakis, Emmanouil; Laarhoven, Thijs; de<br>Weger, Benne","abstract_summary":" Motivated by recent results on solving large<br>batches of closest vector problem (CVP) instances, we<br>study how these techniques can be combined with<br>lattice enumeration to obtain faster methods for<br>solving the shortest vector problem (SVP) on<br>high-dimensional lattices. Theoretically, under common<br>heuristic assumptions we show how to solve SVP in<br>dimension d with a cost proportional to running a sieve in<br>dimension [Formula: see text], resulting in a [Formula:<br>see text] speedup and memory reduction compared to<br>running a full sieve. Combined with techniques from<br>[Ducas, Eurocrypt 2018] we can asymptotically get a<br>total of [Formula: see text] dimensions...","title_summary":" Sieve, Enumerate, Slice, and Lift:: Hybrid<br>Lattice Algorithms for SVP via CVPP","x":-22.7841281891,"y":42.5607299805,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7841281891,"tsne_y":42.5607299805,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"lv2jw8k3","source_x":"PMC","title":"BBB Secure Nonce Based MAC Using Public Permutations","doi":"10.1007\/978-3-030-51938-4_9","abstract":"In the recent trend of CAESAR competition and NIST light-weight competition, cryptographic community have witnessed the submissions of several cryptographic schemes that are build on public random permutations. Recently, in CRYPTO 2019, Chen et al. have initiated an interesting research direction in designing beyond birthday bound PRFs from public random permutations and they proposed two instances of such PRFs. In this work, we extend this research direction by proposing a nonce-based MAC build from public random permutations. We show that our proposed MAC achieves 2n\/3 bit security (with respect to the state size of the permutation) and the bound is essentially tight. Moreover, the security of the MAC degrades gracefully with the repetition of the nonce.","publish_time":1591401600000,"author_summary":" Dutta, Avijit; Nandi, Mridul","abstract_summary":" In the recent trend of CAESAR competition and<br>NIST light-weight competition, cryptographic<br>community have witnessed the submissions of several<br>cryptographic schemes that are build on public random<br>permutations. Recently, in CRYPTO 2019, Chen et al. have<br>initiated an interesting research direction in<br>designing beyond birthday bound PRFs from public random<br>permutations and they proposed two instances of such PRFs. In<br>this work, we extend this research direction by<br>proposing a nonce-based MAC build from public random<br>permutations. We show that our proposed MAC achieves 2n\/3 bit<br>security (with respect to the state size of the<br>permutation) and the bound is...","title_summary":" BBB Secure Nonce Based MAC Using Public<br>Permutations","x":-24.0561332703,"y":40.4738121033,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0561332703,"tsne_y":40.4738121033,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"v606c3g2","source_x":"PMC","title":"New Results on the SymSum Distinguisher on Round-Reduced SHA3","doi":"10.1007\/978-3-030-51938-4_7","abstract":"In ToSC 2017 Saha et al. demonstrated an interesting property of SHA3 based on higher-order vectorial derivatives which led to self-symmetry based distinguishers referred to as SymSum and bettered the complexity w.r.t the well-studied ZeroSum distinguisher by a factor of 4. This work attempts to take a fresh look at this distinguisher in the light of the linearization technique developed by Guo et al. in Asiacrypt 2016. It is observed that the efficiency of SymSum against ZeroSum drops from 4 to 2 for any number of rounds linearized. This is supported by theoretical proofs. SymSum augmented with linearization can penetrate up to two more rounds as against the classical version. In addition to that, one more round is extended by inversion technique on the final hash values. The combined approach leads to distinguishers up to 9 rounds of SHA3 variants with a complexity of only [Formula: see text] which is better than the equivalent ZeroSum distinguisher by the factor of 2. To the best of our knowledge this is the best distinguisher available on this many rounds of SHA3.","publish_time":1591401600000,"author_summary":" Suryawanshi, Sahiba; Saha, Dhiman; Sachan,<br>Satyam","abstract_summary":" In ToSC 2017 Saha et al. demonstrated an<br>interesting property of SHA3 based on higher-order<br>vectorial derivatives which led to self-symmetry based<br>distinguishers referred to as SymSum and bettered the<br>complexity w.r.t the well-studied ZeroSum distinguisher<br>by a factor of 4. This work attempts to take a fresh<br>look at this distinguisher in the light of the<br>linearization technique developed by Guo et al. in Asiacrypt<br>2016. It is observed that the efficiency of SymSum<br>against ZeroSum drops from 4 to 2 for any number of rounds<br>linearized. This is supported by theoretical proofs.<br>SymSum augmented with linearization can penetrate...","title_summary":" New Results on the SymSum Distinguisher on<br>Round-Reduced SHA3","x":-23.988319397,"y":40.6549034119,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.988319397,"tsne_y":40.6549034119,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"e90xvimb","source_x":"PMC","title":"On the Hierarchy of Equivalence Classes Provided by Local Congruences","doi":"10.1007\/978-3-030-52705-1_22","abstract":"In this work, we consider a special kind of equivalence relations, which are called local congruences. Specifically, local congruences are equivalence relations defined on lattices, whose equivalence classes are convex sublattices of the original lattices. In the present paper, we introduce an initial study about how the set of equivalence classes provided by a local congruence can be ordered.","publish_time":1591747200000,"author_summary":" Arag\u00f3n, Roberto G.; Medina, Jes\u00fas;<br>Ram\u00edrez-Poussa, Elo\u00edsa","abstract_summary":" In this work, we consider a special kind of<br>equivalence relations, which are called local<br>congruences. Specifically, local congruences are<br>equivalence relations defined on lattices, whose<br>equivalence classes are convex sublattices of the original<br>lattices. In the present paper, we introduce an initial<br>study about how the set of equivalence classes<br>provided by a local congruence can be ordered.","title_summary":" On the Hierarchy of Equivalence Classes<br>Provided by Local Congruences","x":-22.4854125977,"y":46.0340156555,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4854125977,"tsne_y":46.0340156555,"subcluster":32,"subcluster_description":"Efficient Normalizers","shape":"p"},{"cord_uid":"q51u3oh6","source_x":"PMC","title":"Fast and Furious: Outrunning Windows Kernel Notification Routines from User-Mode","doi":"10.1007\/978-3-030-52683-2_4","abstract":"Modern Operating Systems (OSs) enable user processes to obtain full access control over other processes initiated by the same user. In scenarios of sensitive security processes (e.g., antivirus software), protection schemes are enforced at the kernel level such as to confront arbitrary user processes overtaking with malicious intent. Within the Windows family of OSs, the kernel driver is notified via dedicated routines for user-mode processes that require protection. In such cases the kernel driver establishes a callback mechanism triggered whenever a handle request for the original user-mode process is initiated by a different user process. Subsequently, the kernel driver performs a selective permission removal process (e.g., read access to the process memory) prior to passing a handle to the requesting process. In this paper we are the first to demonstrate a fundamental user-mode process access control vulnerability, existing in Windows 7 up to the most recent Windows 10 OSs. We show that a user-mode process can indeed obtain a fully privileged access handle before the kernel driver is notified, thus prior to the callback mechanism establishment. Our study shows that this flaw can be exploited by a method to (i) disable the anti-malware suite Symantec Endpoint Protection; (ii) overtake VirtualBox protected processes; (iii) circumvent two major video game anti-cheat protection solutions, BattlEye and EasyAntiCheat. Finally we provide recommendations on how to address the discovered vulnerability.","publish_time":1591833600000,"author_summary":" Ciholas, Pierre; Such, Jose Miguel;<br>Marnerides, Angelos K.; Green, Benjamin; Zhang, Jiajie;<br>Roedig, Utz","abstract_summary":" Modern Operating Systems (OSs) enable user<br>processes to obtain full access control over other<br>processes initiated by the same user. In scenarios of<br>sensitive security processes (e.g., antivirus<br>software), protection schemes are enforced at the kernel<br>level such as to confront arbitrary user processes<br>overtaking with malicious intent. Within the Windows<br>family of OSs, the kernel driver is notified via<br>dedicated routines for user-mode processes that require<br>protection. In such cases the kernel driver establishes a<br>callback mechanism triggered whenever a handle request<br>for the original user-mode process is initiated by<br>a different user process. Subsequently, the<br>kernel driver performs...","title_summary":" Fast and Furious: Outrunning Windows Kernel<br>Notification Routines from User-Mode","x":-27.4596614838,"y":41.1396827698,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.4596614838,"tsne_y":41.1396827698,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"gaaequ1d","source_x":"PMC","title":"Efficient Context-Sensitive CFI Enforcement Through a Hardware Monitor","doi":"10.1007\/978-3-030-52683-2_13","abstract":"Recent works on Control-Flow Integrity (CFI) have mainly focused on Context-Sensitive CFI policies to provide higher security guarantees. They utilize a debugging hardware feature in modern Intel CPUs, Processor Trace (PT), to efficiently collect runtime contextual information. These PT-based CFI mechanisms offload the processing of the collected PT trace and CFI enforcement onto idle cores. However, a processor does not always have idle cores due to the commonly-used multi-threaded applications such as web browsers. In fact, dedicating one or more cores for CFI enforcement reduces the number of available cores for running user programs. Our evaluation with a state-of-the-art CFI mechanism ([Formula: see text]CFI) shows that the performance overhead of a CFI mechanism can substantially increase (up to 652% on a single-core processor) when there is no idle core for CFI enforcement. To improve the performance of [Formula: see text]CFI, we propose to leverage a hardware monitor that unlike PT does not incur trace processing overhead. We show that the hardware monitor can be used to efficiently collect program traces (<1% overhead) in their original forms and apply [Formula: see text]CFI. We prototype the hardware-monitor based [Formula: see text]CFI on a single-core RISC-V processor. Our analysis show that hardware-monitor based [Formula: see text]CFI incurs, on average, 43% (up to 277%) performance overhead.","publish_time":1591833600000,"author_summary":" Canakci, Sadullah; Delshadtehrani, Leila;<br>Zhou, Boyou; Joshi, Ajay; Egele, Manuel","abstract_summary":" Recent works on Control-Flow Integrity (CFI)<br>have mainly focused on Context-Sensitive CFI<br>policies to provide higher security guarantees. They<br>utilize a debugging hardware feature in modern Intel<br>CPUs, Processor Trace (PT), to efficiently collect<br>runtime contextual information. These PT-based CFI<br>mechanisms offload the processing of the collected PT<br>trace and CFI enforcement onto idle cores. However, a<br>processor does not always have idle cores due to the<br>commonly-used multi-threaded applications such as web<br>browsers. In fact, dedicating one or more cores for CFI<br>enforcement reduces the number of available cores for<br>running user programs. Our evaluation with a<br>state-of-the-art CFI...","title_summary":" Efficient Context-Sensitive CFI Enforcement<br>Through a Hardware Monitor","x":-27.192281723,"y":41.3616867065,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.192281723,"tsne_y":41.3616867065,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"2kgepmv9","source_x":"PMC","title":"Object Oriented Protoconcepts and Logics for Double and Pure Double Boolean Algebras","doi":"10.1007\/978-3-030-52705-1_23","abstract":"The notion of a protoconcept in the framework of Yao\u2019s object oriented concepts is proposed. Approximations by object oriented concepts are defined and these \u2018object oriented protoconcepts\u2019 are characterized using them. It is shown that the object oriented protoconcepts form a double Boolean algebra, and any double Boolean algebra is quasi-embedded in an algebra of protoconcepts. A logic DBL for the class of double Boolean algebras is proposed along with an extension PDBL for the class of pure double Boolean algebras. Utilizing the representation result for (pure) double Boolean algebras, it is established that DBL (PDBL) is sound and complete with respect to a semantics based on object oriented protoconcepts (semiconcepts).","publish_time":1591747200000,"author_summary":" Howlader, Prosenjit; Banerjee, Mohua","abstract_summary":" The notion of a protoconcept in the framework of<br>Yao\u2019s object oriented concepts is proposed.<br>Approximations by object oriented concepts are defined and<br>these \u2018object oriented protoconcepts\u2019 are<br>characterized using them. It is shown that the object oriented<br>protoconcepts form a double Boolean algebra, and any double<br>Boolean algebra is quasi-embedded in an algebra of<br>protoconcepts. A logic DBL for the class of double Boolean<br>algebras is proposed along with an extension PDBL for the<br>class of pure double Boolean algebras. Utilizing the<br>representation result for (pure) double Boolean algebras, it<br>is established that DBL (PDBL) is sound and<br>complete...","title_summary":" Object Oriented Protoconcepts and Logics for<br>Double and Pure Double Boolean Algebras","x":-24.8218193054,"y":45.2293167114,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.8218193054,"tsne_y":45.2293167114,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"fcd48bab","source_x":"PMC","title":"Distributed Heterogeneous N-Variant Execution","doi":"10.1007\/978-3-030-52683-2_11","abstract":"N-Variant Execution (NVX) systems utilize artificial diversity techniques to enhance software security. The general idea is to run multiple different variants of the same program alongside each other while monitoring their diverging behavior on a malicious input. Existing NVX systems execute diversified program variants on a single host. This means the level of inter-variant diversity will be limited to what a single platform can offer, without costly emulation. This paper presents DMON , a novel distributed NVX design that executes native program variants across multiple heterogeneous hosts. Our approach greatly increases the level of diversity between the simultaneously running variants that can be supported, encompassing different ISAs and ABIs. Our evaluation shows that DMON can provide comparable performance to traditional, non-distributed NVX systems, while enhancing security.","publish_time":1591833600000,"author_summary":" Voulimeneas, Alexios; Song, Dokyung;<br>Parzefall, Fabian; Na, Yeoul; Larsen, Per; Franz,<br>Michael; Volckaert, Stijn","abstract_summary":" N-Variant Execution (NVX) systems utilize<br>artificial diversity techniques to enhance software<br>security. The general idea is to run multiple different<br>variants of the same program alongside each other while<br>monitoring their diverging behavior on a malicious input.<br>Existing NVX systems execute diversified program<br>variants on a single host. This means the level of<br>inter-variant diversity will be limited to what a single<br>platform can offer, without costly emulation. This<br>paper presents DMON , a novel distributed NVX design<br>that executes native program variants across<br>multiple heterogeneous hosts. Our approach greatly<br>increases the level of diversity between the<br>simultaneously running variants...","title_summary":" Distributed Heterogeneous N-Variant<br>Execution","x":-27.1518936157,"y":41.0364685059,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.1518936157,"tsne_y":41.0364685059,"subcluster":3,"subcluster_description":"Polyglot Data Access Layer","shape":"p"},{"cord_uid":"42tdrqe7","source_x":"PMC","title":"Rough Forgetting","doi":"10.1007\/978-3-030-52705-1_1","abstract":"Recent work in the area of Knowledge Representation and Reasoning has focused on modification and optimization of knowledge bases (KB) through the use of forgetting operators of the form [Formula: see text], where [Formula: see text] is a set of relations in the language signature used to specify the KB. The result of this operation is a new KB where the relations in [Formula: see text] are removed from the KB in a principled manner resulting in a more efficient representation of the KB for different purposes. The forgetting operator is also reflected semantically in terms of the relation between the original models of the KB and the models for the revised KB after forgetting. In this paper, we first develop a rough reasoning framework where our KB\u2019s consist of rough formulas with a semantics based on a generalization of Kleene algebras. Using intuitions from the classical case, we then define a forgetting operator that can be applied to rough KBs removing rough relations. A constructive basis for generating a new KB as the result of applying the forgetting operator to a rough KB is specified using second-order quantifier elimination techniques. We show the application of this technique with some practical examples.","publish_time":1591747200000,"author_summary":" Doherty, Patrick; Sza\u0142as, Andrzej","abstract_summary":" Recent work in the area of Knowledge<br>Representation and Reasoning has focused on modification and<br>optimization of knowledge bases (KB) through the use of<br>forgetting operators of the form [Formula: see text],<br>where [Formula: see text] is a set of relations in the<br>language signature used to specify the KB. The result of<br>this operation is a new KB where the relations in<br>[Formula: see text] are removed from the KB in a principled<br>manner resulting in a more efficient representation<br>of the KB for different purposes. The forgetting<br>operator is also reflected semantically in terms of the<br>relation between...","title_summary":" Rough Forgetting","x":-25.6695346832,"y":45.2806587219,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.6695346832,"tsne_y":45.2806587219,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"qyj1z0lw","source_x":"PMC","title":"HAEPG: An Automatic Multi-hop Exploitation Generation Framework","doi":"10.1007\/978-3-030-52683-2_5","abstract":"Automatic exploit generation for heap vulnerabilities is an open challenge. Current studies require a sensitive pointer on the heap to hijack the control flow and pay little attention to vulnerabilities with limited capabilities. In this paper, we propose HAEPG, an automatic exploit framework that can utilize known exploitation techniques to guide exploit generation. We implemented a prototype of HAEPG based on the symbolic execution engine S2E [15] and provided four exploitation techniques for it as prior knowledge. HAEPG takes crashing inputs, programs, and prior knowledge as input, and generates exploits for vulnerabilities with limited capabilities by abusing heap allocator\u2019s internal functionalities. We evaluated HAEPG with 24 CTF programs, and the results show that HAEPG is able to accurately reason about the type of vulnerability for 21 (87.5%) of them, and generate exploits that spawn a shell for 16 (66.7%) of them. All the exploits could bypass NX [25] and Full RELRO [28] security mechanisms.","publish_time":1591833600000,"author_summary":" Zhao, Zixuan; Wang, Yan; Gong, Xiaorui","abstract_summary":" Automatic exploit generation for heap<br>vulnerabilities is an open challenge. Current studies require a<br>sensitive pointer on the heap to hijack the control flow<br>and pay little attention to vulnerabilities with<br>limited capabilities. In this paper, we propose HAEPG,<br>an automatic exploit framework that can utilize<br>known exploitation techniques to guide exploit<br>generation. We implemented a prototype of HAEPG based on the<br>symbolic execution engine S2E [15] and provided four<br>exploitation techniques for it as prior knowledge. HAEPG<br>takes crashing inputs, programs, and prior<br>knowledge as input, and generates exploits for<br>vulnerabilities with limited capabilities by abusing heap<br>allocator\u2019s internal...","title_summary":" HAEPG: An Automatic Multi-hop Exploitation<br>Generation Framework","x":-26.9412002563,"y":41.7711906433,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.9412002563,"tsne_y":41.7711906433,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"7mg11iln","source_x":"PMC","title":"Algebraic Structure of Adjoint Triples Generating a Weak Negation on the Unit Interval","doi":"10.1007\/978-3-030-52705-1_25","abstract":"This paper presents a theoretical research about the relationship between weak negations and adjoint negations. Adjoint negations are a generalization of residuated negations built from the implications of an adjoint triple. Specifically, this work shows how to build adjoint triples on the unit interval such that their adjoint negations coincide with a given weak negation. Moreover, the algebraic structure formed by these adjoint triples is also investigated.","publish_time":1591747200000,"author_summary":" Cornejo, M. Eugenia; Medina, Jes\u00fas;<br>Ram\u00edrez-Poussa, Elo\u00edsa","abstract_summary":" This paper presents a theoretical research<br>about the relationship between weak negations and<br>adjoint negations. Adjoint negations are a<br>generalization of residuated negations built from the<br>implications of an adjoint triple. Specifically, this work<br>shows how to build adjoint triples on the unit<br>interval such that their adjoint negations coincide<br>with a given weak negation. Moreover, the algebraic<br>structure formed by these adjoint triples is also<br>investigated.","title_summary":" Algebraic Structure of Adjoint Triples<br>Generating a Weak Negation on the Unit Interval","x":-23.590259552,"y":46.0481948853,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.590259552,"tsne_y":46.0481948853,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"cmexddcz","source_x":"PMC","title":"Classification Results for Hyperovals of Generalized Quadrangles","doi":"10.1007\/978-3-030-52200-1_15","abstract":"A hyperoval of a point-line geometry is a nonempty set of points meeting each line in either 0 or 2 points. We discuss a combination of theoretical and practical techniques that are helpful for classifying hyperovals of generalized quadrangles. These techniques are based on the connection between hyperovals, even sets and pseudo-embeddings of point-line geometries.","publish_time":1591401600000,"author_summary":" De Bruyn, Bart","abstract_summary":" A hyperoval of a point-line geometry is a<br>nonempty set of points meeting each line in either 0 or 2<br>points. We discuss a combination of theoretical and<br>practical techniques that are helpful for classifying<br>hyperovals of generalized quadrangles. These techniques<br>are based on the connection between hyperovals,<br>even sets and pseudo-embeddings of point-line<br>geometries.","title_summary":" Classification Results for Hyperovals of<br>Generalized Quadrangles","x":-21.6711578369,"y":46.4138526917,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.6711578369,"tsne_y":46.4138526917,"subcluster":31,"subcluster_description":"Algebraic Surfacesa Convex Programming","shape":"p"},{"cord_uid":"a22km6my","source_x":"PMC","title":"The Program Generation in the Software Package QextNewEdition","doi":"10.1007\/978-3-030-52200-1_18","abstract":"This paper is devoted to the program Generation which is a self-containing console application for classification of linear codes. It can be used for codes over fields with [Formula: see text] elements and with wide-range parameters. The base of the implemented algorithm is the concept of canonical augmentation.","publish_time":1591401600000,"author_summary":" Bouyukliev, Iliya","abstract_summary":" This paper is devoted to the program Generation<br>which is a self-containing console application for<br>classification of linear codes. It can be used for codes over<br>fields with [Formula: see text] elements and with<br>wide-range parameters. The base of the implemented<br>algorithm is the concept of canonical augmentation.","title_summary":" The Program Generation in the Software Package<br>QextNewEdition","x":-23.4761447906,"y":46.7824707031,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.4761447906,"tsne_y":46.7824707031,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"4kkihzlb","source_x":"PMC","title":"Evaluating Fractional Derivatives of the Riemann Zeta Function","doi":"10.1007\/978-3-030-52200-1_9","abstract":"We present a method for evaluating the reverse Gr\u00fcnwald-Letnikov fractional derivatives of the Riemann Zeta function [Formula: see text] and use it to explore the location of zeros of integral and fractional derivatives on the left half plane.","publish_time":1591401600000,"author_summary":" Farr, Ricky E.; Pauli, Sebastian; Saidak,<br>Filip","abstract_summary":" We present a method for evaluating the reverse<br>Gr\u00fcnwald-Letnikov fractional derivatives of the Riemann Zeta<br>function [Formula: see text] and use it to explore the<br>location of zeros of integral and fractional<br>derivatives on the left half plane.","title_summary":" Evaluating Fractional Derivatives of the<br>Riemann Zeta Function","x":-21.2108516693,"y":46.4649429321,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.2108516693,"tsne_y":46.4649429321,"subcluster":19,"subcluster_description":"Interval 3-Dimensional Linear Differential","shape":"p"},{"cord_uid":"71bf4w44","source_x":"PMC","title":"Classifying Simplicial Dissections of Convex Polyhedra with Symmetry","doi":"10.1007\/978-3-030-52200-1_14","abstract":"A convex polyhedron is the convex hull of a finite set of points in [Formula: see text] A triangulation of a convex polyhedron is a decomposition into a finite number of 3-simplices such that any two intersect in a common face or are disjoint. A simplicial dissection is a decomposition into a finite number of 3-simplices such that no two share an interior point. We present an algorithm to classify the simplicial dissections of a regular polyhedron under the symmetry group of the prolyhedron.","publish_time":1591401600000,"author_summary":" Betten, Anton; Mukthineni, Tarun","abstract_summary":" A convex polyhedron is the convex hull of a<br>finite set of points in [Formula: see text] A<br>triangulation of a convex polyhedron is a decomposition into a<br>finite number of 3-simplices such that any two<br>intersect in a common face or are disjoint. A simplicial<br>dissection is a decomposition into a finite number of<br>3-simplices such that no two share an interior point. We<br>present an algorithm to classify the simplicial<br>dissections of a regular polyhedron under the symmetry<br>group of the prolyhedron.","title_summary":" Classifying Simplicial Dissections of Convex<br>Polyhedra with Symmetry","x":-21.6457901001,"y":46.18592453,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.6457901001,"tsne_y":46.18592453,"subcluster":26,"subcluster_description":"Symmetrykauffman Bracket Skein Module","shape":"p"},{"cord_uid":"1ff2a0kh","source_x":"PMC","title":"Classification of Linear Codes by Extending Their Residuals","doi":"10.1007\/978-3-030-52200-1_17","abstract":"An approach for classification of linear codes with given parameters starting from their proper residual codes or subcodes is presented. The base of the algorithm is the concept of canonical augmentation which is important for parallel implementations. The algorithms are implemented in the programs LengthExtension and DimExtension of the package QextNewEdition. As an application, the nonexistence of binary [41, 14, 14] codes is proved.","publish_time":1591401600000,"author_summary":" Bouyuklieva, Stefka; Bouyukliev, Iliya","abstract_summary":" An approach for classification of linear codes<br>with given parameters starting from their proper<br>residual codes or subcodes is presented. The base of the<br>algorithm is the concept of canonical augmentation which<br>is important for parallel implementations. The<br>algorithms are implemented in the programs<br>LengthExtension and DimExtension of the package<br>QextNewEdition. As an application, the nonexistence of binary<br>[41, 14, 14] codes is proved.","title_summary":" Classification of Linear Codes by Extending<br>Their Residuals","x":-22.8923397064,"y":46.7541465759,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.8923397064,"tsne_y":46.7541465759,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"8ex6p1nz","source_x":"PMC","title":"Chordality Preserving Incremental Triangular Decomposition and Its Implementation","doi":"10.1007\/978-3-030-52200-1_3","abstract":"In this paper, we first prove that the incremental algorithm for computing triangular decompositions proposed by Chen and Moreno Maza in ISSAC\u2019 2011 in its original form preserves chordality, which is an important property on sparsity of variables. On the other hand, we find that the current implementation in Triangularize command of the RegularChains library in Maple may not always respect chordality due to the use of some simplification operations. Experimentation show that modifying these operations, together with some other optimizations, brings significant speedups for some super sparse polynomial systems.","publish_time":1591401600000,"author_summary":" Chen, Changbo","abstract_summary":" In this paper, we first prove that the<br>incremental algorithm for computing triangular<br>decompositions proposed by Chen and Moreno Maza in ISSAC\u2019 2011<br>in its original form preserves chordality, which<br>is an important property on sparsity of<br>variables. On the other hand, we find that the current<br>implementation in Triangularize command of the RegularChains<br>library in Maple may not always respect chordality due<br>to the use of some simplification operations.<br>Experimentation show that modifying these operations,<br>together with some other optimizations, brings<br>significant speedups for some super sparse polynomial<br>systems.","title_summary":" Chordality Preserving Incremental<br>Triangular Decomposition and Its Implementation","x":-22.4333972931,"y":46.1173858643,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4333972931,"tsne_y":46.1173858643,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"wmyvcgim","source_x":"PMC","title":"A Numerical Approach for Computing Euler Characteristics of Affine Varieties","doi":"10.1007\/978-3-030-52200-1_5","abstract":"We develop a numerical nonlinear algebra approach for computing the Euler characteristic of an affine variety. Our approach is to relate Euler characteristics of a smooth affine variety with the number of critical points using Morse theory. In general, we stratify a variety into the union of smooth affine varieties to obtain results on singular varieties.","publish_time":1591401600000,"author_summary":" Li, Xiaxin; Rodriguez, Jose Israel; Wang,<br>Botong","abstract_summary":" We develop a numerical nonlinear algebra<br>approach for computing the Euler characteristic of an<br>affine variety. Our approach is to relate Euler<br>characteristics of a smooth affine variety with the number of<br>critical points using Morse theory. In general, we<br>stratify a variety into the union of smooth affine<br>varieties to obtain results on singular varieties.","title_summary":" A Numerical Approach for Computing Euler<br>Characteristics of Affine Varieties","x":-21.2502536774,"y":46.4272537231,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.2502536774,"tsne_y":46.4272537231,"subcluster":19,"subcluster_description":"Interval 3-Dimensional Linear Differential","shape":"p"},{"cord_uid":"ahd0p9j1","source_x":"PMC","title":"Phase Portraits of Bi-dimensional Zeta Values","doi":"10.1007\/978-3-030-52200-1_39","abstract":"In this extended abstract, we present how to compute and visualize phase portraits of bi-dimensional Zeta Values. Such technology is useful to explore bi-dimensional Zeta Values and in long-term quest to discover a 2D-Riemann hypothesis. To reach this goal, we need two preliminary steps: [Formula: see text] the notion of phase portraits and a general tool to visualize phase portrait based on interactive Jupyter widgets. [Formula: see text] the ability to compute numerical approximations of bi-dimensional Zeta values, using mpmath, a Python library for arbitrary-precision floating-point arithmetic. To this end, we develop a theory to numerically compute double sums and produce the first algorithm to compute bi-dimensional Zeta Values with complex parameters.","publish_time":1591401600000,"author_summary":" Bouillot, Olivier","abstract_summary":" In this extended abstract, we present how to<br>compute and visualize phase portraits of<br>bi-dimensional Zeta Values. Such technology is useful to<br>explore bi-dimensional Zeta Values and in long-term<br>quest to discover a 2D-Riemann hypothesis. To reach<br>this goal, we need two preliminary steps: [Formula:<br>see text] the notion of phase portraits and a<br>general tool to visualize phase portrait based on<br>interactive Jupyter widgets. [Formula: see text] the<br>ability to compute numerical approximations of<br>bi-dimensional Zeta values, using mpmath, a Python library for<br>arbitrary-precision floating-point arithmetic. To this end, we<br>develop a theory to numerically compute double sums and...","title_summary":" Phase Portraits of Bi-dimensional Zeta Values","x":-20.5951080322,"y":45.8942260742,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-20.5951080322,"tsne_y":45.8942260742,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"lrsqyeqw","source_x":"PMC","title":"The GAP Package LiePRing","doi":"10.1007\/978-3-030-52200-1_13","abstract":"A symbolic Lie p-ring defines a family of Lie rings with [Formula: see text] elements for infinitely many different primes p and a fixed positive integer n. Symbolic Lie p-rings are used to describe the classification of isomorphism types of nilpotent Lie rings of order [Formula: see text] for all primes p and all [Formula: see text]. This classification is available as the LiePRing package of the computer algebra system GAP. We give a brief description of this package, including an approach towards computing the automorphism group of a symbolic Lie p-ring.","publish_time":1591401600000,"author_summary":" Eick, Bettina; Vaughan-Lee, Michael","abstract_summary":" A symbolic Lie p-ring defines a family of Lie<br>rings with [Formula: see text] elements for<br>infinitely many different primes p and a fixed positive<br>integer n. Symbolic Lie p-rings are used to describe the<br>classification of isomorphism types of nilpotent Lie rings of<br>order [Formula: see text] for all primes p and all<br>[Formula: see text]. This classification is available as<br>the LiePRing package of the computer algebra<br>system GAP. We give a brief description of this<br>package, including an approach towards computing the<br>automorphism group of a symbolic Lie p-ring.","title_summary":" The GAP Package LiePRing","x":-22.0075969696,"y":45.6411361694,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.0075969696,"tsne_y":45.6411361694,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"b165dvns","source_x":"PMC","title":"Real Tropical Hyperfaces by Patchworking in polymake","doi":"10.1007\/978-3-030-52200-1_20","abstract":"An implementation of Viro\u2019s patchworking in polymake is presented, and a census of Betti numbers of real tropical surfaces serves as a showcase. The latter is relevant in the context of Hilbert\u2019s 16th Problem.","publish_time":1591401600000,"author_summary":" Joswig, Michael; Vater, Paul","abstract_summary":" An implementation of Viro\u2019s patchworking in<br>polymake is presented, and a census of Betti numbers of<br>real tropical surfaces serves as a showcase. The<br>latter is relevant in the context of Hilbert\u2019s 16th<br>Problem.","title_summary":" Real Tropical Hyperfaces by Patchworking in<br>polymake","x":-21.5531520844,"y":46.7703933716,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.5531520844,"tsne_y":46.7703933716,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"dvtlxtcq","source_x":"PMC","title":"Isomorphism and Invariants of Parallelisms of Projective Spaces","doi":"10.1007\/978-3-030-52200-1_16","abstract":"We consider the computer-aided constructive classification of parallelisms with predefined automorphism groups in small finite projective spaces. The usage of a backtrack search algorithm makes it very important to filter away equivalent partial solutions as soon as possible and to use a fast method for checking for isomorphism of any two parallelisms. The rejection of most of the equivalent solutions can be done by a test which uses the normalizer of the predefined automorphism group. We consider the applicability and effectiveness of such a test, and present sensitive invariants of resolutions of Steiner 2-designs. They can be used to facilitate any type of test for isomorphism of parallelisms.","publish_time":1591401600000,"author_summary":" Topalova, Svetlana; Zhelezova, Stela","abstract_summary":" We consider the computer-aided constructive<br>classification of parallelisms with predefined automorphism<br>groups in small finite projective spaces. The usage of<br>a backtrack search algorithm makes it very<br>important to filter away equivalent partial solutions as<br>soon as possible and to use a fast method for checking<br>for isomorphism of any two parallelisms. The<br>rejection of most of the equivalent solutions can be done<br>by a test which uses the normalizer of the<br>predefined automorphism group. We consider the<br>applicability and effectiveness of such a test, and present<br>sensitive invariants of resolutions of Steiner<br>2-designs. They can be used to facilitate...","title_summary":" Isomorphism and Invariants of Parallelisms of<br>Projective Spaces","x":-22.2924594879,"y":45.716835022,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.2924594879,"tsne_y":45.716835022,"subcluster":32,"subcluster_description":"Efficient Normalizers","shape":"p"},{"cord_uid":"xi8npk57","source_x":"PMC","title":"Algorithms for Pfaffian Systems and Cohomology Intersection Numbers of Hypergeometric Integrals","doi":"10.1007\/978-3-030-52200-1_7","abstract":"In the theory of special functions, a particular kind of multidimensional integral appears frequently. It is called the Euler integral. In order to understand the topological nature of the integral, twisted de Rham cohomology theory plays an important role. We propose an algorithm of computing an invariant cohomology intersection number of a given basis of the twisted cohomology group. We also develop an algorithm of computing the Paffian system that a given basis satisfies. These algorithms are based on the fact that the Euler integral satisfies GKZ system and utilizes algorithms to find rational function solutions of differential equations. We provide software to perform this algorithm.","publish_time":1591401600000,"author_summary":" Matsubara-Heo, Saiei-Jaeyeong; Takayama,<br>Nobuki","abstract_summary":" In the theory of special functions, a<br>particular kind of multidimensional integral appears<br>frequently. It is called the Euler integral. In order to<br>understand the topological nature of the integral,<br>twisted de Rham cohomology theory plays an important<br>role. We propose an algorithm of computing an<br>invariant cohomology intersection number of a given<br>basis of the twisted cohomology group. We also<br>develop an algorithm of computing the Paffian system<br>that a given basis satisfies. These algorithms are<br>based on the fact that the Euler integral satisfies<br>GKZ system and utilizes algorithms to find<br>rational function solutions of differential<br>equations. We...","title_summary":" Algorithms for Pfaffian Systems and<br>Cohomology Intersection Numbers of Hypergeometric<br>Integrals","x":-21.2702846527,"y":45.9903831482,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.2702846527,"tsne_y":45.9903831482,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"or62fitm","source_x":"PMC","title":"Employing C++ Templates in the Design of a Computer Algebra Library","doi":"10.1007\/978-3-030-52200-1_34","abstract":"We discuss design aspects of the open-source Basic Polynomial Algebra Subprograms (BPAS) library. We build on standard C++11 template mechanisms to improve ease of use and accessibility. The BPAS computer algebra library looks to enable end-users to do work more easily and efficiently through optimized C code wrapped in an object-oriented and user-friendly C++ interface. Two key aspects of this interface to be discussed are the encoding of the algebraic hierarchy as a class hierarchy and a mechanism to support the combination of algebraic types as a new type. Existing libraries, if encoding the algebraic hierarchy at all, use runtime value checks to determine if two elements belong to the same ring for an incorrect false sense of type safety in an otherwise statically-typed language. On the contrary, our template metaprogramming mechanism provides true compile-time type safety and compile-time code generation. The details of this mechanism are transparent to end-users, providing a very natural interface for an end-user mathematician.","publish_time":1591401600000,"author_summary":" Brandt, Alexander; Moir, Robert H. C.; Moreno<br>Maza, Marc","abstract_summary":" We discuss design aspects of the open-source<br>Basic Polynomial Algebra Subprograms (BPAS)<br>library. We build on standard C++11 template mechanisms<br>to improve ease of use and accessibility. The BPAS<br>computer algebra library looks to enable end-users to do<br>work more easily and efficiently through optimized<br>C code wrapped in an object-oriented and<br>user-friendly C++ interface. Two key aspects of this<br>interface to be discussed are the encoding of the<br>algebraic hierarchy as a class hierarchy and a mechanism<br>to support the combination of algebraic types as a<br>new type. Existing libraries, if encoding the<br>algebraic hierarchy at all, use runtime...","title_summary":" Employing C++ Templates in the Design of a<br>Computer Algebra Library","x":-26.3352851868,"y":43.3354797363,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.3352851868,"tsne_y":43.3354797363,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"9j85jjtc","source_x":"PMC","title":"Image Watermarking Based on Fourier-Mellin Transform","doi":"10.1007\/978-3-030-51935-3_37","abstract":"Geometric attacks are still challenging issues in image watermarking. In this paper, the robustness of different insertion position and shape of the watermark are evaluated in watermarking scheme based on Fourier-Mellin transform. We propose diagonal, rectangular, and circular insertion of the mark. The robustness of these techniques against geometric deformations such as rotation, scaling and translation (RST) is evaluated. Results show that the circular insertion performs better for translation and scaling attacks, while the diagonal insertion is better for rotations and RST attacks. The last point makes the diagonal insertion to be preferred in industrial applications since the combination of RST attacks often occurs in many applications such as printing the image on a physical support, and scanning it (print-scan attack).","publish_time":1591315200000,"author_summary":" Gourrame, Khadija; Douzi, Hassan; Harba,<br>Rachid; Rabia, Riad; Ros, Frederic; ElHajji, Mehamed","abstract_summary":" Geometric attacks are still challenging<br>issues in image watermarking. In this paper, the<br>robustness of different insertion position and shape of<br>the watermark are evaluated in watermarking<br>scheme based on Fourier-Mellin transform. We propose<br>diagonal, rectangular, and circular insertion of the<br>mark. The robustness of these techniques against<br>geometric deformations such as rotation, scaling and<br>translation (RST) is evaluated. Results show that the<br>circular insertion performs better for translation and<br>scaling attacks, while the diagonal insertion is<br>better for rotations and RST attacks. The last point<br>makes the diagonal insertion to be preferred in<br>industrial applications since the combination of...","title_summary":" Image Watermarking Based on Fourier-Mellin<br>Transform","x":-23.8772830963,"y":40.2931365967,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.8772830963,"tsne_y":40.2931365967,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"derb6tx4","source_x":"PMC","title":"FunGrim: A Symbolic Library for Special Functions","doi":"10.1007\/978-3-030-52200-1_31","abstract":"We present the Mathematical Functions Grimoire (FunGrim), a website and database of formulas and theorems for special functions. We also discuss the symbolic computation library used as the backend and main development tool for FunGrim, and the Grim formula language used in these projects to represent mathematical content semantically.","publish_time":1591401600000,"author_summary":" Johansson, Fredrik","abstract_summary":" We present the Mathematical Functions<br>Grimoire (FunGrim), a website and database of formulas<br>and theorems for special functions. We also<br>discuss the symbolic computation library used as the<br>backend and main development tool for FunGrim, and the<br>Grim formula language used in these projects to<br>represent mathematical content semantically.","title_summary":" FunGrim: A Symbolic Library for Special<br>Functions","x":-23.7046947479,"y":46.5280151367,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.7046947479,"tsne_y":46.5280151367,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"tpbfyo7a","source_x":"PMC","title":"Implementing the Tangent Graeffe Root Finding Method","doi":"10.1007\/978-3-030-52200-1_48","abstract":"The tangent Graeffe method has been developed for the efficient computation of single roots of polynomials over finite fields with multiplicative groups of smooth order. It is a key ingredient of sparse interpolation using geometric progressions, in the case when blackbox evaluations are comparatively cheap. In this paper, we improve the complexity of the method by a constant factor and we report on a new implementation of the method and a first parallel implementation.","publish_time":1591401600000,"author_summary":" van der Hoeven, Joris; Monagan, Michael","abstract_summary":" The tangent Graeffe method has been developed<br>for the efficient computation of single roots of<br>polynomials over finite fields with multiplicative groups<br>of smooth order. It is a key ingredient of sparse<br>interpolation using geometric progressions, in the case when<br>blackbox evaluations are comparatively cheap. In this<br>paper, we improve the complexity of the method by a<br>constant factor and we report on a new implementation of<br>the method and a first parallel implementation.","title_summary":" Implementing the Tangent Graeffe Root Finding<br>Method","x":-21.3544826508,"y":46.3501930237,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.3544826508,"tsne_y":46.3501930237,"subcluster":19,"subcluster_description":"Interval 3-Dimensional Linear Differential","shape":"p"},{"cord_uid":"8gnu44r5","source_x":"PMC","title":"Equality Checking for General Type Theories in Andromeda 2","doi":"10.1007\/978-3-030-52200-1_25","abstract":"We designed a user-extensible judgemental equality checking algorithm for general type theories that supports computation rules and extensionality rules. The user needs only provide the equality rules they wish to use, after which the algorithm devises an appropriate notion of normal form. The algorithm is a generalization of type-directed equality checking for Martin-L\u00f6f type theory, and we implemented it in the Andromeda 2 prover.","publish_time":1591401600000,"author_summary":" Bauer, Andrej; Haselwarter, Philipp G.;<br>Petkovi\u0107, Anja","abstract_summary":" We designed a user-extensible judgemental<br>equality checking algorithm for general type theories<br>that supports computation rules and<br>extensionality rules. The user needs only provide the equality<br>rules they wish to use, after which the algorithm<br>devises an appropriate notion of normal form. The<br>algorithm is a generalization of type-directed equality<br>checking for Martin-L\u00f6f type theory, and we implemented<br>it in the Andromeda 2 prover.","title_summary":" Equality Checking for General Type Theories in<br>Andromeda 2","x":-25.5615692139,"y":44.979183197,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.5615692139,"tsne_y":44.979183197,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"4dcqkykz","source_x":"PMC","title":"Nilpotent Quotients of Associative [Formula: see text]-Algebras and Augmentation Quotients of Baumslag-Solitar Groups","doi":"10.1007\/978-3-030-52200-1_12","abstract":"We describe the functionality of the package zalgs for the computer algebra system GAP. The package contains an implementation of the nilpotent quotient algorithm for finitely presented associative [Formula: see text]-algebras described in [3]. As an application of this algorithm we calculate augmentation quotients, i.e. successive quotients of powers of the augmentation ideal I(G) of the integral group ring [Formula: see text], where G is a finitely presented group. We apply these methods to obtain conjectures for augmentation quotients of the Baumslag-Solitar groups BS(m, n) with [Formula: see text] equal to 0, 1 or a prime p.","publish_time":1591401600000,"author_summary":" Moede, Tobias","abstract_summary":" We describe the functionality of the package<br>zalgs for the computer algebra system GAP. The<br>package contains an implementation of the nilpotent<br>quotient algorithm for finitely presented associative<br>[Formula: see text]-algebras described in [3]. As an<br>application of this algorithm we calculate augmentation<br>quotients, i.e. successive quotients of powers of the<br>augmentation ideal I(G) of the integral group ring [Formula:<br>see text], where G is a finitely presented group. We<br>apply these methods to obtain conjectures for<br>augmentation quotients of the Baumslag-Solitar groups<br>BS(m, n) with [Formula: see text] equal to 0, 1 or a<br>prime p.","title_summary":" Nilpotent Quotients of Associative [Formula:<br>see text]-Algebras and Augmentation Quotients of<br>Baumslag-Solitar Groups","x":-22.3673610687,"y":45.2058982849,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.3673610687,"tsne_y":45.2058982849,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"sj631oc3","source_x":"PMC","title":"Homomorphic Encryption and Some Black Box Attacks","doi":"10.1007\/978-3-030-52200-1_11","abstract":"This paper is a compressed summary of some principal definitions and concepts in the approach to the black box algebra being developed by the authors [6\u20138]. We suggest that black box algebra could be useful in cryptanalysis of homomorphic encryption schemes [11], and that homomorphic encryption is an area of research where cryptography and black box algebra may benefit from exchange of ideas.","publish_time":1591401600000,"author_summary":" Borovik, Alexandre; Yal\u00e7\u0131nkaya, \u015e\u00fckr\u00fc","abstract_summary":" This paper is a compressed summary of some<br>principal definitions and concepts in the approach to the<br>black box algebra being developed by the authors<br>[6\u20138]. We suggest that black box algebra could be<br>useful in cryptanalysis of homomorphic encryption<br>schemes [11], and that homomorphic encryption is an<br>area of research where cryptography and black box<br>algebra may benefit from exchange of ideas.","title_summary":" Homomorphic Encryption and Some Black Box<br>Attacks","x":-24.0409870148,"y":40.4486618042,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0409870148,"tsne_y":40.4486618042,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"uvpc245s","source_x":"PMC","title":"Practical Volume Estimation of Zonotopes by a New Annealing Schedule for Cooling Convex Bodies","doi":"10.1007\/978-3-030-52200-1_21","abstract":"We study the problem of estimating the volume of convex polytopes, focusing on zonotopes. Although a lot of effort is devoted to practical algorithms for polytopes given as an intersection of halfspaces, there is no such method for zonotopes. Our algorithm is based on Multiphase Monte Carlo (MMC) methods, and our main contributions include: (i) a new uniform sampler employing Billiard Walk for the first time in volume computation, (ii) a new simulated annealing generalizing existing MMC by making use of adaptive convex bodies which fit to the input, thus drastically reducing the number of phases. Extensive experiments on zonotopes show our algorithm requires sub-linear number of oracle calls in the dimension, while the best theoretical bound is cubic. Moreover, our algorithm can be easily generalized to any convex body. We offer an open-source, optimized C++ implementation, and analyze its performance. Our code tackles problems intractable so far, offering the first efficient algorithm for zonotopes which scales to high dimensions (e.g. one hundred dimensions in less than 1 h).","publish_time":1591401600000,"author_summary":" Chalkis, Apostolos; Emiris, Ioannis Z.;<br>Fisikopoulos, Vissarion","abstract_summary":" We study the problem of estimating the volume of<br>convex polytopes, focusing on zonotopes. Although a<br>lot of effort is devoted to practical algorithms<br>for polytopes given as an intersection of<br>halfspaces, there is no such method for zonotopes. Our<br>algorithm is based on Multiphase Monte Carlo (MMC)<br>methods, and our main contributions include: (i) a new<br>uniform sampler employing Billiard Walk for the first<br>time in volume computation, (ii) a new simulated<br>annealing generalizing existing MMC by making use of<br>adaptive convex bodies which fit to the input, thus<br>drastically reducing the number of phases. Extensive<br>experiments on zonotopes...","title_summary":" Practical Volume Estimation of Zonotopes by a<br>New Annealing Schedule for Cooling Convex Bodies","x":-21.852186203,"y":41.7015151978,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.852186203,"tsne_y":41.7015151978,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"5ngorenl","source_x":"PMC","title":"Hyperplane Arrangements in polymake","doi":"10.1007\/978-3-030-52200-1_23","abstract":"Hyperplane arrangements form the latest addition to the zoo of combinatorial objects dealt with by polymake. We report on their implementation and on a algorithm to compute the associated cell decomposition. The implemented algorithm performs significantly better than brute force alternatives, as it requires fewer convex hulls computations. The implementation is included in polymake since release 4.0.","publish_time":1591401600000,"author_summary":" Kastner, Lars; Panizzut, Marta","abstract_summary":" Hyperplane arrangements form the latest<br>addition to the zoo of combinatorial objects dealt with<br>by polymake. We report on their implementation<br>and on a algorithm to compute the associated cell<br>decomposition. The implemented algorithm performs<br>significantly better than brute force alternatives, as it<br>requires fewer convex hulls computations. The<br>implementation is included in polymake since release 4.0.","title_summary":" Hyperplane Arrangements in polymake","x":-21.8231086731,"y":46.6107292175,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.8231086731,"tsne_y":46.6107292175,"subcluster":31,"subcluster_description":"Algebraic Surfacesa Convex Programming","shape":"p"},{"cord_uid":"gjkwfkox","source_x":"PMC","title":"Discrete p-bilaplacian Operators on Graphs","doi":"10.1007\/978-3-030-51935-3_36","abstract":"In this paper, we first introduce a new family of operators on weighted graphs called p-bilaplacian operators, which are the analogue on graphs of the continuous p-bilaplacian operators. We then turn to study regularized variational and boundary value problems associated to these operators. For instance, we study their well-posedness (existence and uniqueness). We also develop proximal splitting algorithms to solve these problems. We finally report numerical experiments to support our findings.","publish_time":1591315200000,"author_summary":" El Bouchairi, Imad; El Moataz, Abderrahim;<br>Fadili, Jalal","abstract_summary":" In this paper, we first introduce a new family of<br>operators on weighted graphs called p-bilaplacian<br>operators, which are the analogue on graphs of the<br>continuous p-bilaplacian operators. We then turn to study<br>regularized variational and boundary value problems<br>associated to these operators. For instance, we study<br>their well-posedness (existence and uniqueness).<br>We also develop proximal splitting algorithms to<br>solve these problems. We finally report numerical<br>experiments to support our findings.","title_summary":" Discrete p-bilaplacian Operators on Graphs","x":-21.3674907684,"y":46.0697402954,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.3674907684,"tsne_y":46.0697402954,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"resa6iqv","source_x":"PMC","title":"A Formalization of Properties of Continuous Functions on Closed Intervals","doi":"10.1007\/978-3-030-52200-1_27","abstract":"Formal mathematics is getting increasing attention in mathematics and computer science. In particular, the formalization of calculus has important applications in engineering design and analysis. In this paper, we present a formal proof of some fundamental theorems of continuous functions on closed intervals based on the Coq proof assistant. In this formalization, we build a real number system referring to Landau\u2019s Foundations of Analysis. Then we complete the formalization of the basic definitions of interval, function, and limit and formally prove the theorems including completeness theorem, intermediate value theorem, uniform continuity theorem and others in Coq. The proof process is normalized, rigorous and reliable.","publish_time":1591401600000,"author_summary":" Fu, Yaoshun; Yu, Wensheng","abstract_summary":" Formal mathematics is getting increasing<br>attention in mathematics and computer science. In<br>particular, the formalization of calculus has important<br>applications in engineering design and analysis. In this<br>paper, we present a formal proof of some fundamental<br>theorems of continuous functions on closed intervals<br>based on the Coq proof assistant. In this<br>formalization, we build a real number system referring to<br>Landau\u2019s Foundations of Analysis. Then we complete the<br>formalization of the basic definitions of interval,<br>function, and limit and formally prove the theorems<br>including completeness theorem, intermediate value<br>theorem, uniform continuity theorem and others in Coq.<br>The proof process is...","title_summary":" A Formalization of Properties of Continuous<br>Functions on Closed Intervals","x":-21.4228439331,"y":45.5329856873,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.4228439331,"tsne_y":45.5329856873,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"7zii8l7z","source_x":"PMC","title":"Evaluating and Differentiating a Polynomial Using a Pseudo-witness Set","doi":"10.1007\/978-3-030-52200-1_6","abstract":"Polynomials which arise via elimination can be difficult to compute explicitly. By using a pseudo-witness set, we develop an algorithm to explicitly compute the restriction of a polynomial to a given line. The resulting polynomial can then be used to evaluate the original polynomial and directional derivatives along the line at any point on the given line. Several examples are used to demonstrate this new algorithm including examples of computing the critical points of the discriminant locus for parameterized polynomial systems.","publish_time":1591401600000,"author_summary":" Hauenstein, Jonathan D.; Regan, Margaret H.","abstract_summary":" Polynomials which arise via elimination can be<br>difficult to compute explicitly. By using a<br>pseudo-witness set, we develop an algorithm to explicitly<br>compute the restriction of a polynomial to a given line.<br>The resulting polynomial can then be used to<br>evaluate the original polynomial and directional<br>derivatives along the line at any point on the given line.<br>Several examples are used to demonstrate this new<br>algorithm including examples of computing the critical<br>points of the discriminant locus for parameterized<br>polynomial systems.","title_summary":" Evaluating and Differentiating a Polynomial<br>Using a Pseudo-witness Set","x":-22.193775177,"y":46.1011886597,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.193775177,"tsne_y":46.1011886597,"subcluster":32,"subcluster_description":"Efficient Normalizers","shape":"p"},{"cord_uid":"xqheq8jp","source_x":"PMC","title":"Algebraic Polytopes in Normaliz","doi":"10.1007\/978-3-030-52200-1_19","abstract":"We describe the implementation of algebraic polyhedra in Normaliz. In addition to convex hull computation\/vertex enumeration, Normaliz computes triangulations, volumes, lattice points, face lattices and automorphism groups. The arithmetic is based on the package e-antic by V. Delecroix.","publish_time":1591401600000,"author_summary":" Bruns, Winfried","abstract_summary":" We describe the implementation of algebraic<br>polyhedra in Normaliz. In addition to convex hull<br>computation\/vertex enumeration, Normaliz computes<br>triangulations, volumes, lattice points, face lattices and<br>automorphism groups. The arithmetic is based on the package<br>e-antic by V. Delecroix.","title_summary":" Algebraic Polytopes in Normaliz","x":-21.874956131,"y":46.4199333191,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.874956131,"tsne_y":46.4199333191,"subcluster":31,"subcluster_description":"Algebraic Surfacesa Convex Programming","shape":"p"},{"cord_uid":"3e192rpw","source_x":"PMC","title":"Curtains in CAD: Why Are They a Problem and How Do We Fix Them?","doi":"10.1007\/978-3-030-52200-1_2","abstract":"This paper is part of our ongoing research on the adaptation of Lazard\u2019s CAD to benefit from equational constraints in formulae. In earlier work we combined the CAD methods of McCallum and Lazard so as to produce an efficient algorithm for decomposing a hypersurface rather than the whole of [Formula: see text] (exploiting an equational constraint [Formula: see text]). That method, however, fails if f is nullified (in McCallum\u2019s terminology): we call the set where this happens a curtain. Here we provide a further modification which, at the cost of a trade off in terms of complexity, is valid for any hypersurface, including one containing curtains.","publish_time":1591401600000,"author_summary":" Nair, Akshar; Davenport, James; Sankaran,<br>Gregory","abstract_summary":" This paper is part of our ongoing research on the<br>adaptation of Lazard\u2019s CAD to benefit from equational<br>constraints in formulae. In earlier work we combined the CAD<br>methods of McCallum and Lazard so as to produce an<br>efficient algorithm for decomposing a hypersurface<br>rather than the whole of [Formula: see text]<br>(exploiting an equational constraint [Formula: see<br>text]). That method, however, fails if f is nullified<br>(in McCallum\u2019s terminology): we call the set where<br>this happens a curtain. Here we provide a further<br>modification which, at the cost of a trade off in terms of<br>complexity, is valid for...","title_summary":" Curtains in CAD: Why Are They a Problem and How Do<br>We Fix Them?","x":-20.5848197937,"y":45.3798980713,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-20.5848197937,"tsne_y":45.3798980713,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"r6s6es18","source_x":"PMC","title":"Computations with Algebraic Surfaces","doi":"10.1007\/978-3-030-52200-1_8","abstract":"Computations with algebraic number fields and algebraic curves have been carried out for a long time. They resulted in many interesting examples and the formation of various conjectures. The aim of this talk is to report on some computations with algebraic surfaces that are currently possible.","publish_time":1591401600000,"author_summary":" Elsenhans, Andreas-Stephan; Jahnel, J\u00f6rg","abstract_summary":" Computations with algebraic number fields and<br>algebraic curves have been carried out for a long time.<br>They resulted in many interesting examples and the<br>formation of various conjectures. The aim of this talk is<br>to report on some computations with algebraic<br>surfaces that are currently possible.","title_summary":" Computations with Algebraic Surfaces","x":-21.795841217,"y":46.5380363464,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.795841217,"tsne_y":46.5380363464,"subcluster":31,"subcluster_description":"Algebraic Surfacesa Convex Programming","shape":"p"},{"cord_uid":"fqjbdzq1","source_x":"PMC","title":"FlexRiLoG\u2014A SageMath Package for Motions of Graphs","doi":"10.1007\/978-3-030-52200-1_44","abstract":"In this paper we present the SageMath package FlexRiLoG (short for flexible and rigid labelings of graphs). Based on recent results the software generates motions of graphs using special edge colorings. The package computes and illustrates the colorings and the motions. We present the structure and usage of the package.","publish_time":1591401600000,"author_summary":" Grasegger, Georg; Legersk\u00fd, Jan","abstract_summary":" In this paper we present the SageMath package<br>FlexRiLoG (short for flexible and rigid labelings of<br>graphs). Based on recent results the software generates<br>motions of graphs using special edge colorings. The<br>package computes and illustrates the colorings and the<br>motions. We present the structure and usage of the<br>package.","title_summary":" FlexRiLoG\u2014A SageMath Package for Motions of<br>Graphs","x":-22.2099475861,"y":46.316570282,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.2099475861,"tsne_y":46.316570282,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"wtjz00bq","source_x":"PMC","title":"Certifying Irreducibility in [Formula: see text]","doi":"10.1007\/978-3-030-52200-1_46","abstract":"We consider the question of certifying that a polynomial in [Formula: see text] or [Formula: see text] is irreducible. Knowing that a polynomial is irreducible lets us recognise that a quotient ring is actually a field extension (equiv. that a polynomial ideal is maximal). Checking that a polynomial is irreducible by factorizing it is unsatisfactory because it requires trusting a relatively large and complicated program (whose correctness cannot easily be verified). We present a practical method for generating certificates of irreducibility which can be verified by relatively simple computations; we assume that primes and irreducibles in [Formula: see text] are self-certifying.","publish_time":1591401600000,"author_summary":" Abbott, John","abstract_summary":" We consider the question of certifying that a<br>polynomial in [Formula: see text] or [Formula: see text] is<br>irreducible. Knowing that a polynomial is irreducible lets<br>us recognise that a quotient ring is actually a<br>field extension (equiv. that a polynomial ideal is<br>maximal). Checking that a polynomial is irreducible by<br>factorizing it is unsatisfactory because it requires<br>trusting a relatively large and complicated program<br>(whose correctness cannot easily be verified). We<br>present a practical method for generating<br>certificates of irreducibility which can be verified by<br>relatively simple computations; we assume that primes and<br>irreducibles in [Formula: see text] are...","title_summary":" Certifying Irreducibility in [Formula: see<br>text]","x":-23.5455760956,"y":44.6902275085,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.5455760956,"tsne_y":44.6902275085,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"qmxecx07","source_x":"PMC","title":"Making Presentation Math Computable: Proposing a Context Sensitive Approach for Translating LaTeX to Computer Algebra Systems","doi":"10.1007\/978-3-030-52200-1_33","abstract":"Scientists increasingly rely on computer algebra systems and digital mathematical libraries to compute, validate, or experiment with mathematical formulae. However, the focus in digital mathematical libraries and scientific documents often lies more on an accurate presentation of the formulae rather than providing uniform access to the semantic information. But, presentational math formats do not provide exclusive access to the underlying semantic meanings. One has to derive the semantic information from the context. As a consequence, the workflow of experimenting and publishing in the Sciences often includes time-consuming, error-prone manual conversions between presentational and computational math formats. As a contribution to improve this workflow, we propose a context-sensitive approach that extracts semantic information from a given context, embeds the information into the given input, and converts the semantically enhanced expressions to computer algebra systems.","publish_time":1591401600000,"author_summary":" Greiner-Petter, Andr\u00e9; Schubotz, Moritz;<br>Aizawa, Akiko; Gipp, Bela","abstract_summary":" Scientists increasingly rely on computer<br>algebra systems and digital mathematical libraries to<br>compute, validate, or experiment with mathematical<br>formulae. However, the focus in digital mathematical<br>libraries and scientific documents often lies more on an<br>accurate presentation of the formulae rather than<br>providing uniform access to the semantic information.<br>But, presentational math formats do not provide<br>exclusive access to the underlying semantic meanings.<br>One has to derive the semantic information from the<br>context. As a consequence, the workflow of<br>experimenting and publishing in the Sciences often includes<br>time-consuming, error-prone manual conversions between<br>presentational and computational math formats. As a<br>contribution to...","title_summary":" Making Presentation Math Computable:<br>Proposing a Context Sensitive Approach for Translating<br>LaTeX to Computer Algebra Systems","x":-26.6317462921,"y":45.0457191467,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.6317462921,"tsne_y":45.0457191467,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"am34v2il","source_x":"PMC","title":"Prototyping Controlled Mathematical Languages in Jupyter Notebooks","doi":"10.1007\/978-3-030-52200-1_40","abstract":"The Grammatical Logical Framework (GLF) is a framework for prototyping the translation of natural language sentences into logic. The motivation behind GLF was to apply it to mathematical language, as the classical compositional approach to semantics construction seemed most suitable for a domain where high precision was mandatory\u2014even at the price of limited coverage. In particular, software for formal mathematics (such as proof checkers) require formal input languages. These are typically difficult to understand and learn, raising the entry barrier for potential users. A solution is to design input languages that closely resemble natural language. Early results indicate that GLF can be a useful tool for quickly prototyping such languages. In this paper, we will explore how GLF can be used to prototype such languages and present a new Jupyter kernel that4 adds visual support for the development of GLF-based syntax\/semantics interfaces.","publish_time":1591401600000,"author_summary":" Schaefer, Jan Frederik; Amann, Kai; Kohlhase,<br>Michael","abstract_summary":" The Grammatical Logical Framework (GLF) is a<br>framework for prototyping the translation of natural<br>language sentences into logic. The motivation behind<br>GLF was to apply it to mathematical language, as the<br>classical compositional approach to semantics<br>construction seemed most suitable for a domain where high<br>precision was mandatory\u2014even at the price of limited<br>coverage. In particular, software for formal<br>mathematics (such as proof checkers) require formal input<br>languages. These are typically difficult to understand<br>and learn, raising the entry barrier for potential<br>users. A solution is to design input languages that<br>closely resemble natural language. Early results<br>indicate that GLF...","title_summary":" Prototyping Controlled Mathematical<br>Languages in Jupyter Notebooks","x":-26.0783405304,"y":44.3014144897,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.0783405304,"tsne_y":44.3014144897,"subcluster":40,"subcluster_description":"Nested Attributed Graph Conditionsteaching","shape":"p"},{"cord_uid":"4g8qhrh6","source_x":"PMC","title":"A Convex Programming Approach to Solve Posynomial Systems","doi":"10.1007\/978-3-030-52200-1_24","abstract":"We exhibit a class of classical or tropical posynomial systems which can be solved by reduction to linear or convex programming problems. This relies on a notion of colorful vectors with respect to a collection of Newton polytopes. This extends the convex programming approach of one player stochastic games.","publish_time":1591401600000,"author_summary":" Akian, Marianne; Allamigeon, Xavier; Boyet,<br>Marin; Gaubert, St\u00e9phane","abstract_summary":" We exhibit a class of classical or tropical<br>posynomial systems which can be solved by reduction to<br>linear or convex programming problems. This relies on<br>a notion of colorful vectors with respect to a<br>collection of Newton polytopes. This extends the convex<br>programming approach of one player stochastic games.","title_summary":" A Convex Programming Approach to Solve<br>Posynomial Systems","x":-22.2107563019,"y":46.5359725952,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.2107563019,"tsne_y":46.5359725952,"subcluster":31,"subcluster_description":"Algebraic Surfacesa Convex Programming","shape":"p"},{"cord_uid":"l28lo6qh","source_x":"PMC","title":"[Image: see text]-Integral Points on a Mordell Curve","doi":"10.1007\/978-3-030-52200-1_4","abstract":"We use an extension of quadratic Chabauty to number fields, recently developed by the author with Balakrishnan, Besser and M\u00fcller, combined with a sieving technique, to determine the integral points over [Image: see text] on the Mordell curve [Formula: see text].","publish_time":1591401600000,"author_summary":" Bianchi, Francesca","abstract_summary":" We use an extension of quadratic Chabauty to<br>number fields, recently developed by the author with<br>Balakrishnan, Besser and M\u00fcller, combined with a sieving<br>technique, to determine the integral points over [Image:<br>see text] on the Mordell curve [Formula: see text].","title_summary":" [Image: see text]-Integral Points on a Mordell<br>Curve","x":-21.6586933136,"y":46.4086456299,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.6586933136,"tsne_y":46.4086456299,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"bs4l4fc5","source_x":"PMC","title":"Towards Efficient Normalizers of Primitive Groups","doi":"10.1007\/978-3-030-52200-1_10","abstract":"We present the ideas behind an algorithm to compute normalizers of primitive groups with non-regular socle in polynomial time. We highlight a concept we developed called permutation morphisms and present timings for a partial implementation of our algorithm. This article is a collection of results from the author\u2019s PhD thesis.","publish_time":1591401600000,"author_summary":" Siccha, Sergio","abstract_summary":" We present the ideas behind an algorithm to<br>compute normalizers of primitive groups with<br>non-regular socle in polynomial time. We highlight a<br>concept we developed called permutation morphisms and<br>present timings for a partial implementation of our<br>algorithm. This article is a collection of results from the<br>author\u2019s PhD thesis.","title_summary":" Towards Efficient Normalizers of Primitive<br>Groups","x":-22.3558292389,"y":46.3800315857,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.3558292389,"tsne_y":46.3800315857,"subcluster":32,"subcluster_description":"Efficient Normalizers","shape":"p"},{"cord_uid":"7n77vko9","source_x":"PMC","title":"Toward a Curry-Howard Equivalence for Linear, Reversible Computation: Work-in-Progress","doi":"10.1007\/978-3-030-52482-1_8","abstract":"In this paper, we present a linear and reversible language with inductive and coinductive types, together with a Curry-Howard correspondence with the logic [Image: see text] : linear logic extended with least and greatest fixed points allowing inductive and coinductive statements. Linear, reversible computation makes an important sub-class of quantum computation without measurement. In the latter, the notion of purely quantum recursive type is not yet well understood. Moreover, models for reasoning about quantum algorithms only provide complex types for classical datatypes: there are usually no types for purely quantum objects beside tensors of quantum bits. This work is a first step towards understanding purely quantum recursive types.","publish_time":1592352000000,"author_summary":" Chardonnet, Kostia; Saurin, Alexis; Valiron,<br>Beno\u00eet","abstract_summary":" In this paper, we present a linear and<br>reversible language with inductive and coinductive<br>types, together with a Curry-Howard correspondence<br>with the logic [Image: see text] : linear logic<br>extended with least and greatest fixed points allowing<br>inductive and coinductive statements. Linear,<br>reversible computation makes an important sub-class of<br>quantum computation without measurement. In the<br>latter, the notion of purely quantum recursive type is<br>not yet well understood. Moreover, models for<br>reasoning about quantum algorithms only provide complex<br>types for classical datatypes: there are usually no<br>types for purely quantum objects beside tensors of<br>quantum bits. This work is a...","title_summary":" Toward a Curry-Howard Equivalence for Linear,<br>Reversible Computation: Work-in-Progress","x":-23.989315033,"y":45.0103378296,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.989315033,"tsne_y":45.0103378296,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"69k1xazu","source_x":"PMC","title":"Encoding Reversing Petri Nets in Answer Set Programming","doi":"10.1007\/978-3-030-52482-1_17","abstract":"Reversing Petri nets (RPNs) have been proposed as a reversible approach to Petri nets, which allows the transitions of a net to be reversed. This work presents an approach towards an implementation of RPNs to support their simulation and analysis. Specifically, we define how to model RPNs in Answer Set Programming (ASP), a declarative programming framework with competitive solvers. We highlight how the methodology can be used to reason about the behavior of RPN models.","publish_time":1592352000000,"author_summary":" Dimopoulos, Yannis; Kouppari, Eleftheria;<br>Philippou, Anna; Psara, Kyriaki","abstract_summary":" Reversing Petri nets (RPNs) have been proposed<br>as a reversible approach to Petri nets, which<br>allows the transitions of a net to be reversed. This<br>work presents an approach towards an<br>implementation of RPNs to support their simulation and<br>analysis. Specifically, we define how to model RPNs in<br>Answer Set Programming (ASP), a declarative<br>programming framework with competitive solvers. We<br>highlight how the methodology can be used to reason about<br>the behavior of RPN models.","title_summary":" Encoding Reversing Petri Nets in Answer Set<br>Programming","x":-26.7784690857,"y":44.6079101562,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7784690857,"tsne_y":44.6079101562,"subcluster":37,"subcluster_description":"Coloured Petri Nets","shape":"p"},{"cord_uid":"qqml3y0k","source_x":"PMC","title":"ReverCSP: Time-Travelling in CSP Computations","doi":"10.1007\/978-3-030-52482-1_14","abstract":"This paper presents reverCSP, a tool to animate both forward and backward CSP computations. This ability to reverse computations can be done step by step or backtracking to a given desired state of interest. reverCSP allows us to reverse computations exactly in the same order in which they happened, or also in a causally-consistent way. Therefore, reverCSP is a tool that can be especially useful to comprehend, analyze, and debug computations. reverCSP is an open-source project publicly available for the community. We describe the tool and its functionality, and we provide implementation details so that it can be reimplemented for other languages.","publish_time":1592352000000,"author_summary":" Galindo, Carlos; Nishida, Naoki; Silva,<br>Josep; Tamarit, Salvador","abstract_summary":" This paper presents reverCSP, a tool to animate<br>both forward and backward CSP computations. This<br>ability to reverse computations can be done step by step<br>or backtracking to a given desired state of<br>interest. reverCSP allows us to reverse computations<br>exactly in the same order in which they happened, or also<br>in a causally-consistent way. Therefore,<br>reverCSP is a tool that can be especially useful to<br>comprehend, analyze, and debug computations. reverCSP is<br>an open-source project publicly available for<br>the community. We describe the tool and its<br>functionality, and we provide implementation details so that<br>it can be reimplemented for...","title_summary":" ReverCSP: Time-Travelling in CSP<br>Computations","x":-27.0588226318,"y":43.8924331665,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.0588226318,"tsne_y":43.8924331665,"subcluster":15,"subcluster_description":"Unfolding Colored Petri Nets","shape":"p"},{"cord_uid":"tyx69npn","source_x":"PMC","title":"Reversible Computations in Logic Programming","doi":"10.1007\/978-3-030-52482-1_15","abstract":"In this work, we say that a computation is reversible if one can find a procedure to undo the steps of a standard (or forward) computation in a deterministic way. While logic programs are often invertible (e.g., one can use the same predicate for adding and for subtracting natural numbers), computations are not reversible in the above sense. In this paper, we present a so-called Landauer embedding for SLD resolution, the operational principle of logic programs, so that it becomes reversible. A proof-of-concept implementation of a reversible debugger for Prolog that follows the ideas in this paper has been developed and is publicly available.","publish_time":1592352000000,"author_summary":" Vidal, Germ\u00e1n","abstract_summary":" In this work, we say that a computation is<br>reversible if one can find a procedure to undo the steps of a<br>standard (or forward) computation in a deterministic<br>way. While logic programs are often invertible<br>(e.g., one can use the same predicate for adding and for<br>subtracting natural numbers), computations are not<br>reversible in the above sense. In this paper, we present a<br>so-called Landauer embedding for SLD resolution, the<br>operational principle of logic programs, so that it becomes<br>reversible. A proof-of-concept implementation of a<br>reversible debugger for Prolog that follows the ideas in<br>this paper has been developed...","title_summary":" Reversible Computations in Logic Programming","x":-24.9472885132,"y":44.5198364258,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.9472885132,"tsne_y":44.5198364258,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"po98mw6n","source_x":"PMC","title":"Involutory Turing Machines","doi":"10.1007\/978-3-030-52482-1_3","abstract":"An involutory function, also called involution, is a function [Formula: see text] that is its own inverse, i.e., [Formula: see text] holds whenever [Formula: see text] is defined. This paper presents a computational model of involution as a variant of Turing machines, called an involutory Turing machine. The computational model is shown to be complete in the sense that not only does an involutory Turing machine always compute an involution but also every involutory computable function can be computed by an involutory Turing machine. As any involution is injective (hence reversible), any involutory Turing machine forms a standard reversible Turing machine that is backward deterministic. Furthermore, the existence of a universal involutory Turing machine is shown under an appropriate redefinition of universality given by Axelsen and Gl\u00fcck for reversible Turing machines. This work is motivated by characterizing bidirectional transformation languages.","publish_time":1592352000000,"author_summary":" Nakano, Keisuke","abstract_summary":" An involutory function, also called<br>involution, is a function [Formula: see text] that is its own<br>inverse, i.e., [Formula: see text] holds whenever<br>[Formula: see text] is defined. This paper presents a<br>computational model of involution as a variant of Turing<br>machines, called an involutory Turing machine. The<br>computational model is shown to be complete in the sense that<br>not only does an involutory Turing machine always<br>compute an involution but also every involutory<br>computable function can be computed by an involutory<br>Turing machine. As any involution is injective (hence<br>reversible), any involutory Turing machine forms a standard<br>reversible Turing...","title_summary":" Involutory Turing Machines","x":-23.8016204834,"y":44.5986862183,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.8016204834,"tsne_y":44.5986862183,"subcluster":21,"subcluster_description":"Stack Automata Modelsinvolutory Turing","shape":"p"},{"cord_uid":"51orl5u0","source_x":"PMC","title":"Fractional Types: Expressive and Safe Space Management for Ancilla Bits","doi":"10.1007\/978-3-030-52482-1_10","abstract":"In reversible computing, the management of space is subject to two broad classes of constraints. First, as with general-purpose computation, every allocation must be paired with a matching de-allocation. Second, space can only be safely de-allocated if its contents are restored to their initial value from allocation time. Generally speaking, the state of the art provides limited partial solutions, either leaving both constraints to programmers\u2019 assertions or imposing a stack discipline to address the first constraint and leaving the second constraint to programmers\u2019 assertions. We propose a novel approach based on the idea of fractional types. As a simple intuitive example, allocation of a new boolean value initialized to [Image: see text] also creates a value [Image: see text] that can be thought of as a garbage collection (GC) process specialized to reclaim, and only reclaim, storage containing the value [Image: see text]. This GC process is a first-class entity that can be manipulated, decomposed into smaller processes and combined with other GC processes. We formalize this idea in the context of a reversible language founded on type isomorphisms, prove its fundamental correctness properties, and illustrate its expressiveness using a wide variety of examples. The development is backed by a fully-formalized Agda implementation (https:\/\/github.com\/DreamLinuxer\/FracAncilla).","publish_time":1592352000000,"author_summary":" Chen, Chao-Hong; Choudhury, Vikraman;<br>Carette, Jacques; Sabry, Amr","abstract_summary":" In reversible computing, the management of<br>space is subject to two broad classes of constraints.<br>First, as with general-purpose computation, every<br>allocation must be paired with a matching de-allocation.<br>Second, space can only be safely de-allocated if its<br>contents are restored to their initial value from<br>allocation time. Generally speaking, the state of the art<br>provides limited partial solutions, either leaving<br>both constraints to programmers\u2019 assertions or<br>imposing a stack discipline to address the first<br>constraint and leaving the second constraint to<br>programmers\u2019 assertions. We propose a novel approach based<br>on the idea of fractional types. As a simple<br>intuitive...","title_summary":" Fractional Types: Expressive and Safe Space<br>Management for Ancilla Bits","x":-25.1151390076,"y":42.9841651917,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.1151390076,"tsne_y":42.9841651917,"subcluster":11,"subcluster_description":"Sat Solverssat-Based Encodings","shape":"p"},{"cord_uid":"ec125p9o","source_x":"PMC","title":"Scaling Logic Locking Schemes to Multi-module Hardware Designs","doi":"10.1007\/978-3-030-52794-5_11","abstract":"The involvement of third parties in the integrated circuit design and fabrication flow has introduced severe security concerns, including intellectual property piracy, reverse engineering and the insertion of malicious circuits known as hardware Trojans. Logic locking has emerged as a prominent technique to counter these security threats by protecting the integrity of integrated circuits through functional and structural obfuscation. In recent years, a great number of locking schemes has been introduced, thereby focusing on a variety of security objectives and the resiliency against different attacks. However, several major pitfalls can be identified in the existing proposals: (i) the focus on isolated and often small circuit components, (ii) the assumption of unrealistic attack models that enable powerful attacks on logic locking and (iii) the design of very specific locking schemes targeted towards achieving resilience against specific attacks. These observations strongly impair the practicality of logic locking. Therefore, in this paper we present a holistic framework for scaling logic locking schemes to common multi-module hardware designs, thereby showcasing an industry-ready pathway of applying logic locking in a realistic design flow. The framework represents an enhancement of the previously published Inter-Lock methodology, offering several algorithmic improvements as well as toolflow implementation details to facilitate the applicability of the framework to large multi-module designs. The framework is tested and evaluated on a real-life 64-bit RISC-V core.","publish_time":1591920000000,"author_summary":" \u0160i\u0161ejkovi\u0107, Dominik; Merchant, Farhad;<br>Reimann, Lennart M.; Leupers, Rainer; Kegrei\u00df, Sascha","abstract_summary":" The involvement of third parties in the<br>integrated circuit design and fabrication flow has<br>introduced severe security concerns, including<br>intellectual property piracy, reverse engineering and the<br>insertion of malicious circuits known as hardware<br>Trojans. Logic locking has emerged as a prominent<br>technique to counter these security threats by<br>protecting the integrity of integrated circuits through<br>functional and structural obfuscation. In recent years, a<br>great number of locking schemes has been introduced,<br>thereby focusing on a variety of security objectives<br>and the resiliency against different attacks.<br>However, several major pitfalls can be identified in the<br>existing proposals: (i) the focus on...","title_summary":" Scaling Logic Locking Schemes to Multi-module<br>Hardware Designs","x":-24.8249282837,"y":40.2146453857,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.8249282837,"tsne_y":40.2146453857,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"63u4fj09","source_x":"PMC","title":"On the Evaluation of SEU Effects on AXI Interconnect Within AP-SoCs","doi":"10.1007\/978-3-030-52794-5_16","abstract":"G-Programmable System-on-Chips offering the union of a processor system with a programmable hardware gave rise to applications that choose hardware acceleration to offload and parallelize computationally demanding tasks. Due to flexibility and performance they provide at low cost, these devices are also appealing for several applications in avionics, aerospace and automotive sectors, where reliability is the main concern. In particular, the interconnection architecture, and especially the AXI Interconnection for FPGA-accelerated applications, plays a critical role in these systems. This paper presents a reliability analysis of the AXI Interconnect IP Core implemented on Zynq-7000 AP-SoC against SEUs in the configuration memory of the programmable logic. The analysis has been conducted performing a fault injection campaign on the specific section of the configuration memory implementing the IP Core under test, which has been implemented within a benchmark design. The results are analyzed and classified, highlighting the criticality of the AXI Interconnect IP Core as a point of failure, especially for SEU-hardened hardware accelerator relying on mitigation techniques based on fine-grained and coarse-grained replication.","publish_time":1591920000000,"author_summary":" De Sio, Corrado; Azimi, Sarah; Sterpone, Luca","abstract_summary":" G-Programmable System-on-Chips offering the<br>union of a processor system with a programmable<br>hardware gave rise to applications that choose hardware<br>acceleration to offload and parallelize computationally<br>demanding tasks. Due to flexibility and performance they<br>provide at low cost, these devices are also appealing<br>for several applications in avionics, aerospace<br>and automotive sectors, where reliability is the<br>main concern. In particular, the interconnection<br>architecture, and especially the AXI Interconnection for<br>FPGA-accelerated applications, plays a critical role in these<br>systems. This paper presents a reliability analysis of<br>the AXI Interconnect IP Core implemented on<br>Zynq-7000 AP-SoC against SEUs in the configuration<br>memory...","title_summary":" On the Evaluation of SEU Effects on AXI<br>Interconnect Within AP-SoCs","x":-26.8103408813,"y":40.3954429626,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.8103408813,"tsne_y":40.3954429626,"subcluster":7,"subcluster_description":"Ap-Socsaccelerating Real-Time Applications","shape":"p"},{"cord_uid":"6vweg7lf","source_x":"PMC","title":"3D Optimisation of Software Application Mappings on Heterogeneous MPSoCs","doi":"10.1007\/978-3-030-52794-5_5","abstract":"Increasing the efficiency of parallel software development is one of the key obstacles in taking advantage of heterogeneous multi-core architectures. Efficient and reliable compiler technology is required to identify the trade-off between multiple design goals at once. The most crucial objectives are application performance and processor power consumption. Including memory power into this multi-objective optimisation problem is of utmost importance. Therefore, this paper proposes the heuristic MORAM solving this three-dimensional Pareto front calculation. Furthermore, it is integrated into a commercially available framework to conduct a detailed evaluation and applicability study. MORAM is assessed with representative benchmarks on two different platforms and contrasted with a state-of-the-art evolutionary multi-objective algorithm. On average, MORAM produces 6% better Pareto fronts, while it is at least [Formula: see text] faster.","publish_time":1591920000000,"author_summary":" F\u00fchr, Gereon; Hallawa, Ahmed; Leupers,<br>Rainer; Ascheid, Gerd; Eusse, Juan Fernando","abstract_summary":" Increasing the efficiency of parallel<br>software development is one of the key obstacles in<br>taking advantage of heterogeneous multi-core<br>architectures. Efficient and reliable compiler technology is<br>required to identify the trade-off between multiple<br>design goals at once. The most crucial objectives are<br>application performance and processor power consumption.<br>Including memory power into this multi-objective<br>optimisation problem is of utmost importance. Therefore,<br>this paper proposes the heuristic MORAM solving<br>this three-dimensional Pareto front calculation.<br>Furthermore, it is integrated into a commercially available<br>framework to conduct a detailed evaluation and<br>applicability study. MORAM is assessed with representative<br>benchmarks on two different platforms...","title_summary":" 3D Optimisation of Software Application<br>Mappings on Heterogeneous MPSoCs","x":-27.1832523346,"y":40.1532440186,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.1832523346,"tsne_y":40.1532440186,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"19k0riny","source_x":"PMC","title":"Evaluating Dynamic Task Scheduling with Priorities and Adaptive Aging in a Task-Based Runtime System","doi":"10.1007\/978-3-030-52794-5_2","abstract":"The high degree of parallelism of today\u2019s computing systems often requires executing applications and their tasks in parallel due to a limited scaling capability of individual applications. In such scenarios, considering the differing importance of applications while scheduling tasks is done by assigning priorities to the tasks. However, priorities may lead to starvation in highly utilized systems. A solution is offered by aging mechanisms that raise the priority of long waiting tasks. As modern systems are often dynamic in nature, we developed a two-level aging mechanism and analyzed its effect in the context of 6 dynamic scheduling algorithms for heterogeneous systems. In the context of task scheduling, aging refers to a method that increases the priority of a task over its lifetime. We used a task-based runtime system to evaluate the mechanism on a real system in two scenarios. The results show a speed up of the average total makespan in 9 out of 12 conducted experiments when aging is used with the cost of additional waiting time for the applications\/jobs with higher priority. However, the job\/application with the highest priority is still finished first in all cases. Considering the scheduling algorithms, Minimum Completion Time, Sufferage, and Relative Cost benefit in both experiments by the aging mechanism. Additionally, no algorithm significantly dominates all other algorithms when total makespans are compared.","publish_time":1591920000000,"author_summary":" Becker, Thomas; Sch\u00fcle, Tobias","abstract_summary":" The high degree of parallelism of today\u2019s<br>computing systems often requires executing<br>applications and their tasks in parallel due to a limited<br>scaling capability of individual applications. In<br>such scenarios, considering the differing<br>importance of applications while scheduling tasks is done<br>by assigning priorities to the tasks. However,<br>priorities may lead to starvation in highly utilized<br>systems. A solution is offered by aging mechanisms that<br>raise the priority of long waiting tasks. As modern<br>systems are often dynamic in nature, we developed a<br>two-level aging mechanism and analyzed its effect in the<br>context of 6 dynamic scheduling algorithms for<br>heterogeneous...","title_summary":" Evaluating Dynamic Task Scheduling with<br>Priorities and Adaptive Aging in a Task-Based Runtime<br>System","x":-26.555847168,"y":39.5565032959,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.555847168,"tsne_y":39.5565032959,"subcluster":6,"subcluster_description":"Genomics Data Processing","shape":"p"},{"cord_uid":"eacnmw1p","source_x":"PMC","title":"Investigating Transactional Memory for High Performance Embedded Systems","doi":"10.1007\/978-3-030-52794-5_8","abstract":"We present a Transaction Management Unit (TMU) for Hardware Transactional Memories (HTMs). Our TMU enables three different contention management strategies, which can be applied according to the workload. Additionally, the TMU enables unbounded transactions in terms of size. Our approach tackles two challenges of traditional HTMs: (1) potentially high abort rates, (2) missing support for unbounded transactions. By enhancing a simulator with a transactional memory and our TMU, we demonstrate that our TMU achieves speedups of up to 4.2 and reduces abort rates by a factor of up to 11.6 for some of the STAMP benchmarks.","publish_time":1591920000000,"author_summary":" Piatka, Christian; Amslinger, Rico; Haas,<br>Florian; Weis, Sebastian; Altmeyer, Sebastian;<br>Ungerer, Theo","abstract_summary":" We present a Transaction Management Unit (TMU)<br>for Hardware Transactional Memories (HTMs). Our<br>TMU enables three different contention<br>management strategies, which can be applied according to<br>the workload. Additionally, the TMU enables<br>unbounded transactions in terms of size. Our approach<br>tackles two challenges of traditional HTMs: (1)<br>potentially high abort rates, (2) missing support for<br>unbounded transactions. By enhancing a simulator with a<br>transactional memory and our TMU, we demonstrate that our TMU<br>achieves speedups of up to 4.2 and reduces abort rates by a<br>factor of up to 11.6 for some of the STAMP benchmarks.","title_summary":" Investigating Transactional Memory for High<br>Performance Embedded Systems","x":-27.1782035828,"y":41.2818031311,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.1782035828,"tsne_y":41.2818031311,"subcluster":3,"subcluster_description":"Polyglot Data Access Layer","shape":"p"},{"cord_uid":"ii3shws6","source_x":"PMC","title":"Exploration of Power Domain Partitioning with Concurrent Task Mapping and Scheduling for Application-Specific Multi-core SoCs","doi":"10.1007\/978-3-030-52794-5_12","abstract":"This paper proposes a novel approach to explore the design space of Power Domain (PD) partitioning in the architecture definition phase of heterogeneous SoCs. By formulating an Integer Linear Program (ILP), task mapping and scheduling is determined concurrently while considering power-off dependencies among cores in the same PD and the power-gating break-even time. Compared to state-of-the-art approaches aiming at design phases where task mapping and scheduling has been frozen, our proposed approach shifts joint exploration into earlier design phases, creates more power-gating opportunities for PD partitions, and thus identifies better trade-offs in terms of energy consumption and design costs.","publish_time":1591920000000,"author_summary":" Wang, Bo; Imtiaz, Aneek; Falk, Joachim; Gla\u00df,<br>Michael; Teich, J\u00fcrgen","abstract_summary":" This paper proposes a novel approach to explore<br>the design space of Power Domain (PD) partitioning<br>in the architecture definition phase of<br>heterogeneous SoCs. By formulating an Integer Linear Program<br>(ILP), task mapping and scheduling is determined<br>concurrently while considering power-off dependencies<br>among cores in the same PD and the power-gating<br>break-even time. Compared to state-of-the-art<br>approaches aiming at design phases where task mapping and<br>scheduling has been frozen, our proposed approach shifts<br>joint exploration into earlier design phases,<br>creates more power-gating opportunities for PD<br>partitions, and thus identifies better trade-offs in terms<br>of energy consumption and design costs.","title_summary":" Exploration of Power Domain Partitioning with<br>Concurrent Task Mapping and Scheduling for<br>Application-Specific Multi-core SoCs","x":-27.3228969574,"y":40.0843009949,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.3228969574,"tsne_y":40.0843009949,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"aprjijvu","source_x":"PMC","title":"He..ro DB: A Concept for Parallel Data Processing on Heterogeneous Hardware","doi":"10.1007\/978-3-030-52794-5_7","abstract":"Due to the growing demand on processing power and energy efficiency by today\u2019s data-intensive applications developers have to deal with heterogeneous hardware platforms composed of specialized computing resources. These are highly efficient for certain workloads but difficult to handle from the software engineering perspective. Even state-of-the-art database management systems do not exploit all heterogeneous hardware components, as their characteristics differ significantly. They are thus hard to integrate within a coherent database architecture. To address this problem, we propose a design concept that is based on a layered system software architecture: He..ro DB transforms a data-flow graph that describes the data-processing application to a task-based execution plan. Task implementations for the different computing resources and a reasonable degree of parallelism are chosen automatically based on available resources. The concept can cover any hardware configuration and application scenario. It is versatile and offers opportunities for independent optimization on each layer.","publish_time":1591920000000,"author_summary":" M\u00fcller, Michael; Leich, Thomas; Pionteck,<br>Thilo; Saake, Gunter; Teubner, Jens; Spinczyk, Olaf","abstract_summary":" Due to the growing demand on processing power<br>and energy efficiency by today\u2019s data-intensive<br>applications developers have to deal with heterogeneous<br>hardware platforms composed of specialized computing<br>resources. These are highly efficient for certain<br>workloads but difficult to handle from the software<br>engineering perspective. Even state-of-the-art database<br>management systems do not exploit all heterogeneous<br>hardware components, as their characteristics differ<br>significantly. They are thus hard to integrate within a<br>coherent database architecture. To address this<br>problem, we propose a design concept that is based on a<br>layered system software architecture: He..ro DB<br>transforms a data-flow graph that describes the<br>data-processing...","title_summary":" He..ro DB: A Concept for Parallel Data<br>Processing on Heterogeneous Hardware","x":-26.7312259674,"y":40.1377868652,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7312259674,"tsne_y":40.1377868652,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"jhe58xuo","source_x":"PMC","title":"Accelerating Real-Time Applications with Predictable Work-Stealing","doi":"10.1007\/978-3-030-52794-5_18","abstract":"Modern compute architectures often consist of multiple CPU cores to achieve their performance, as physical properties put a limit on the execution speed of a single processor. This trend is also visible in the embedded and real-time domain, where programmers are forced to parallelize their software to keep deadlines. Additionally, embedded systems rely increasingly on modular applications, that can easily be adapted to different system loads and hardware configurations. To parallelize applications under these dynamic conditions, often dispatching frameworks like Threading Building Blocks (TBB) are used in the desktop and server segment. More recently, Embedded Multicore Building Blocks (EMB[Formula: see text]) was developed as a task-based programming solution designed with the constraints of embedded systems in mind. In this paper, we discuss how task-based programming fits such systems by analyzing scheduler implementation variants, with a focus on classic work-stealing and the libraries TBB and EMB[Formula: see text]. Based on the state of the art we introduce a novel resource-trading concept that allows static memory allocation in a work-stealing runtime holding strict space and time bounds. We conduct benchmarks between an early prototype of the concept, TBB and EMB[Formula: see text], showing that resource-trading does not introduce additional runtime overheads, while unfortunately also not improving on execution time variances.","publish_time":1591920000000,"author_summary":" Fritz, Florian; Schmid, Michael; Mottok,<br>J\u00fcrgen","abstract_summary":" Modern compute architectures often consist of<br>multiple CPU cores to achieve their performance, as<br>physical properties put a limit on the execution speed of<br>a single processor. This trend is also visible in<br>the embedded and real-time domain, where<br>programmers are forced to parallelize their software to<br>keep deadlines. Additionally, embedded systems<br>rely increasingly on modular applications, that<br>can easily be adapted to different system loads and<br>hardware configurations. To parallelize applications<br>under these dynamic conditions, often dispatching<br>frameworks like Threading Building Blocks (TBB) are used<br>in the desktop and server segment. More recently,<br>Embedded Multicore Building Blocks (EMB[Formula: see...","title_summary":" Accelerating Real-Time Applications with<br>Predictable Work-Stealing","x":-26.7704391479,"y":40.4377479553,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7704391479,"tsne_y":40.4377479553,"subcluster":7,"subcluster_description":"Ap-Socsaccelerating Real-Time Applications","shape":"p"},{"cord_uid":"erpi3qdo","source_x":"PMC","title":"X-CEL: A Method to Estimate Near-Memory Acceleration Potential in Tile-Based MPSoCs","doi":"10.1007\/978-3-030-52794-5_9","abstract":"Near-memory acceleration strives to tackle the data-to-task locality issue in MPSoCs in order to obtain higher performance and lower power consumption. However, it is not easy to determine whether the advantages arise from the near-memory integration or the hardware acceleration (versus software execution). We propose X-CEL, a method to accurately estimate the potential of near-memory acceleration using an easy-to-integrate near-memory core. We showcase X-CEL\u2019s benefits with three variants of graph copy mechanisms in a tile-based MPSoC. Evaluations reveal that the estimated speedup is in good accordance with the actual speedup achieved by the near-memory accelerator.","publish_time":1591920000000,"author_summary":" Rheindt, Sven; Fried, Andreas; Lenke, Oliver;<br>Nolte, Lars; Sabirov, Temur; Twardzik, Tim; Wild,<br>Thomas; Herkersdorf, Andreas","abstract_summary":" Near-memory acceleration strives to tackle<br>the data-to-task locality issue in MPSoCs in order<br>to obtain higher performance and lower power<br>consumption. However, it is not easy to determine whether the<br>advantages arise from the near-memory integration or the<br>hardware acceleration (versus software execution). We<br>propose X-CEL, a method to accurately estimate the<br>potential of near-memory acceleration using an<br>easy-to-integrate near-memory core. We showcase X-CEL\u2019s<br>benefits with three variants of graph copy mechanisms in<br>a tile-based MPSoC. Evaluations reveal that the<br>estimated speedup is in good accordance with the actual<br>speedup achieved by the near-memory accelerator.","title_summary":" X-CEL: A Method to Estimate Near-Memory<br>Acceleration Potential in Tile-Based MPSoCs","x":-26.68034935,"y":40.2774009705,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.68034935,"tsne_y":40.2774009705,"subcluster":8,"subcluster_description":"Hardware-Assisted Mpi Overlap Enginesimplifying","shape":"p"},{"cord_uid":"4sti5rhc","source_x":"PMC","title":"Engineering an Optimized Instruction Set Architecture for AMIDAR Processors","doi":"10.1007\/978-3-030-52794-5_10","abstract":"Newly developed instruction set architectures are nowadays typically based on the RISC principle. Yet, more abstract instruction sets also have their advantages. In the AMIDAR project Java Bytecode was used as the instruction set. Instructions are realized as compositions of micro instructions that are distributed to specialized functional units. An explicit timing of these micro instructions is not necessary in AMIDAR processors. This simplifies the conversion of compute intense instruction sequences into hardware structures while the system is running. The relatively high abstraction level of the Bytecode facilitates the analysis and synthesis remarkably. Yet, the native execution of the Bytecode comes with a number of drawbacks. In this contribution, we show a new instruction set architecture that preserves the high abstraction level of Bytecode while at the same time avoiding inefficient data transports. We show that on average the new instruction set reduces the number of clock cycles for our benchmark set by a factor of 3.","publish_time":1591920000000,"author_summary":" Schwarz, Alexander; Hochberger, Christian","abstract_summary":" Newly developed instruction set<br>architectures are nowadays typically based on the RISC<br>principle. Yet, more abstract instruction sets also have<br>their advantages. In the AMIDAR project Java<br>Bytecode was used as the instruction set. Instructions<br>are realized as compositions of micro<br>instructions that are distributed to specialized<br>functional units. An explicit timing of these micro<br>instructions is not necessary in AMIDAR processors. This<br>simplifies the conversion of compute intense instruction<br>sequences into hardware structures while the system is<br>running. The relatively high abstraction level of the<br>Bytecode facilitates the analysis and synthesis<br>remarkably. Yet, the native execution of the Bytecode...","title_summary":" Engineering an Optimized Instruction Set<br>Architecture for AMIDAR Processors","x":-26.7771167755,"y":40.955368042,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7771167755,"tsne_y":40.955368042,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"8zccrure","source_x":"PMC","title":"Approximate Data Dependence Profiling Based on Abstract Interval and Congruent Domains","doi":"10.1007\/978-3-030-52794-5_1","abstract":"Although parallel processing is mainstream, existing programs are often serial, and usually re-engineering cost is high. Data dependence profiling allows for automatically assessing parallelisation potential; Yet, data dependence profiling is notoriously slow and requires large memory, as it generally requires keeping track of each memory access. This paper considers employing a simple abstract single-trace analysis method using simple interval and congruent modulo domains to track dependencies at lower time and memory costs. The method gathers and abstracts the set of all memory reference addresses for each static memory access instruction. This method removes the need for keeping a large shadow memory and only requires a single pair-wise analysis pass to detect dependencies among memory instructions through simple intersection operations. Moreover, the combination of interval and congruent domains improves precision when compared with only using an interval domain representation, mainly when the data is not accessed in a dense access pattern. We further improve precision through partitioning memory space into blocks, where references in each block abstracted independently. An initial performance study is conducted on SPEC CPU-2006 benchmark programs and polyhedral benchmark suite. Results show that the method reduces execution time overhead by 1.4[Formula: see text] for polyhedral and 10.7[Formula: see text] for SPEC2006 on average; and significantly reduces memory by 109780[Formula: see text] and 6981[Formula: see text] for polyhedral and SPEC2006 respectively; the method has an average precision of 99.05% and 61.37% for polyhedral and SPEC respectively. Using memory partitioning resulted in improving mean precision to be 82.25% and decreasing memory reduction to be 47[Formula: see text] for SPEC2006 suite.","publish_time":1591920000000,"author_summary":" Abbas, Mostafa; Omar, Rasha; El-Mahdy, Ahmed;<br>Rohou, Erven","abstract_summary":" Although parallel processing is mainstream,<br>existing programs are often serial, and usually<br>re-engineering cost is high. Data dependence profiling allows<br>for automatically assessing parallelisation<br>potential; Yet, data dependence profiling is notoriously<br>slow and requires large memory, as it generally<br>requires keeping track of each memory access. This paper<br>considers employing a simple abstract single-trace<br>analysis method using simple interval and congruent<br>modulo domains to track dependencies at lower time and<br>memory costs. The method gathers and abstracts the set<br>of all memory reference addresses for each static<br>memory access instruction. This method removes the<br>need for keeping a large shadow...","title_summary":" Approximate Data Dependence Profiling Based<br>on Abstract Interval and Congruent Domains","x":-26.7930812836,"y":40.6675605774,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7930812836,"tsne_y":40.6675605774,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"4bb1qoo4","source_x":"PMC","title":"ECC Memory for Fault Tolerant RISC-V Processors","doi":"10.1007\/978-3-030-52794-5_4","abstract":"Numerous processor cores based on the popular RISC-V Instruction Set Architecture have been developed in the past few years and are freely available. The same applies for RISC-V ecosystems that allow to implement System-on-Chips with RISC-V processors on ASICs or FPGAs. However, so far only very little concepts and implementations for fault tolerant RISC-V processors are existing. This inhibits the use of RISC-V for safety-critical applications (as in the automotive domain) or within radiation environments (as in the aerospace domain). This work enhances the existing implementations Rocket and BOOM with a generic Error Correction Code (ECC) protected memory as a first step towards fault tolerance. The impact of the ECC additions on performance and resource utilization are discussed.","publish_time":1591920000000,"author_summary":" D\u00f6rflinger, Alexander; Guan, Yejun;<br>Michalik, S\u00f6ren; Michalik, S\u00f6nke; Naghmouchi, Jamin;<br>Michalik, Harald","abstract_summary":" Numerous processor cores based on the popular<br>RISC-V Instruction Set Architecture have been<br>developed in the past few years and are freely available.<br>The same applies for RISC-V ecosystems that allow<br>to implement System-on-Chips with RISC-V<br>processors on ASICs or FPGAs. However, so far only very<br>little concepts and implementations for fault<br>tolerant RISC-V processors are existing. This inhibits<br>the use of RISC-V for safety-critical<br>applications (as in the automotive domain) or within<br>radiation environments (as in the aerospace domain).<br>This work enhances the existing implementations<br>Rocket and BOOM with a generic Error Correction Code<br>(ECC) protected memory as a...","title_summary":" ECC Memory for Fault Tolerant RISC-V<br>Processors","x":-26.781829834,"y":40.5403060913,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.781829834,"tsne_y":40.5403060913,"subcluster":7,"subcluster_description":"Ap-Socsaccelerating Real-Time Applications","shape":"p"},{"cord_uid":"cobt1p3j","source_x":"PMC","title":"Search-Based Transformation Synthesis for 3-Valued Reversible Circuits","doi":"10.1007\/978-3-030-52482-1_13","abstract":"A novel bounded search transformation-based synthesis approach is presented that finds a reversible circuit implementation for a given reversible function. Methods for simplifying the circuit post-synthesis are presented. Quantum implementation constraints are also considered. Experimental results for all 2-input 3-valued functions show the effectiveness of the new approaches compared to earlier transformation-based synthesis approaches. Other examples are given to show both the effectiveness and limitations of the new approach which point to a number of key areas for further research.","publish_time":1592352000000,"author_summary":" Miller, D. Michael; Dueck, Gerhard W.","abstract_summary":" A novel bounded search transformation-based<br>synthesis approach is presented that finds a reversible<br>circuit implementation for a given reversible<br>function. Methods for simplifying the circuit<br>post-synthesis are presented. Quantum implementation<br>constraints are also considered. Experimental results for<br>all 2-input 3-valued functions show the<br>effectiveness of the new approaches compared to earlier<br>transformation-based synthesis approaches. Other examples are<br>given to show both the effectiveness and limitations<br>of the new approach which point to a number of key<br>areas for further research.","title_summary":" Search-Based Transformation Synthesis for<br>3-Valued Reversible Circuits","x":-23.9714984894,"y":41.8334846497,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.9714984894,"tsne_y":41.8334846497,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"kqepagyd","source_x":"PMC","title":"Reversible Programming Languages Capturing Complexity Classes","doi":"10.1007\/978-3-030-52482-1_6","abstract":"We argue that there is a link between implicit computational complexity theory and the theory of reversible computation. We show that the complexity classes [Formula: see text] and [Formula: see text] can be captured by inherently reversible programming languages.","publish_time":1592352000000,"author_summary":" Kristiansen, Lars","abstract_summary":" We argue that there is a link between implicit<br>computational complexity theory and the theory of reversible<br>computation. We show that the complexity classes [Formula:<br>see text] and [Formula: see text] can be captured by<br>inherently reversible programming languages.","title_summary":" Reversible Programming Languages Capturing<br>Complexity Classes","x":-23.7270374298,"y":46.3337593079,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.7270374298,"tsne_y":46.3337593079,"subcluster":18,"subcluster_description":"Capturing Complexity Classes","shape":"p"},{"cord_uid":"udzs6dlp","source_x":"PMC","title":"On the Expressivity of Total Reversible Programming Languages","doi":"10.1007\/978-3-030-52482-1_7","abstract":"SRL is a reversible programming language conceived as a restriction of imperative programming languages. Each SRL program that mentions n registers defines a bijection on n-tuples of integers. Despite its simplicity, SRL is strong enough to grasp a wide class of computable bijections and to rise non-trivial programming issues. We advance in the study of its expressivity. We show how to choose among alternative program-branches by checking if a given value is positive or negative. So, we answer some longstanding questions that the literature poses. In particular, we prove that SRL is primitive recursive complete and that its program equivalence is undecidable.","publish_time":1592352000000,"author_summary":" Matos, Armando B.; Paolini, Luca; Roversi,<br>Luca","abstract_summary":" SRL is a reversible programming language<br>conceived as a restriction of imperative programming<br>languages. Each SRL program that mentions n registers<br>defines a bijection on n-tuples of integers. Despite<br>its simplicity, SRL is strong enough to grasp a wide<br>class of computable bijections and to rise<br>non-trivial programming issues. We advance in the study of<br>its expressivity. We show how to choose among<br>alternative program-branches by checking if a given value<br>is positive or negative. So, we answer some<br>longstanding questions that the literature poses. In<br>particular, we prove that SRL is primitive recursive<br>complete and that its program equivalence...","title_summary":" On the Expressivity of Total Reversible<br>Programming Languages","x":-24.8906116486,"y":44.610118866,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.8906116486,"tsne_y":44.610118866,"subcluster":25,"subcluster_description":"\u0141ukasiewicz Logicrewriting Theory","shape":"p"},{"cord_uid":"0l8qv2mm","source_x":"PMC","title":"Inverse Problems, Constraint Satisfaction, Reversible Logic, Invertible Logic and Grover Quantum Oracles for Practical Problems","doi":"10.1007\/978-3-030-52482-1_1","abstract":"It is well-known that the \u201cUnsorted Database\u201d quantum algorithm by Grover gives quadratic speedup to several important combinatorial and enumerative problems, such as: SAT, Graph Coloring, Maximum Cliques, Travelling Salesman and many others. Recently, quantum programming languages such as Quipper start to be used to design, verify and simulate practical quantum algorithms for important problems in Quantum Machine Learning. So far, however, no methodologies have been created to program Grover Oracles for particular classes of problems. In contrast, such methodologies have been already created for classical Constraint Satisfaction Problems. The goal of this invited talk is to show results of some initial research towards creating systematic methodologies to program quantum computers that solve search problems in Artificial Intelligence, Logic Design and Machine Learning. Our methods are based on unified oracle blocks for such problem representations as set partition algebra, cube calculus and optimal mappings. For instance, several important problems in CAD and Machine Learning can be solved using only two basic operations on set partitions; \u03a0(1) \u2264 \u03a0(2) and \u03a0(1) \u00b7 \u03a0(2). Moreover, building oracles is the fundamental concept in the new approach to solve CSP proposed here and based on Invertible Logic introduced recently by Supriyo Datta and his team.","publish_time":1592352000000,"author_summary":" Perkowski, Marek","abstract_summary":" It is well-known that the \u201cUnsorted Database\u201d<br>quantum algorithm by Grover gives quadratic speedup to<br>several important combinatorial and enumerative<br>problems, such as: SAT, Graph Coloring, Maximum Cliques,<br>Travelling Salesman and many others. Recently, quantum<br>programming languages such as Quipper start to be used to<br>design, verify and simulate practical quantum<br>algorithms for important problems in Quantum Machine<br>Learning. So far, however, no methodologies have been<br>created to program Grover Oracles for particular<br>classes of problems. In contrast, such methodologies<br>have been already created for classical Constraint<br>Satisfaction Problems. The goal of this invited talk is to<br>show results of...","title_summary":" Inverse Problems, Constraint Satisfaction,<br>Reversible Logic, Invertible Logic and Grover Quantum<br>Oracles for Practical Problems","x":-23.6993560791,"y":42.416721344,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.6993560791,"tsne_y":42.416721344,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"pa7j7x0g","source_x":"PMC","title":"Maximality of Reversible Gate Sets","doi":"10.1007\/978-3-030-52482-1_12","abstract":"We investigate collections of reversible gates closed under parallel and serial composition. In order to better understand the structure of these collections of reversible gates, we investigate the lattice of closed sets and the maximal members of this lattice, that is, collections that are not all gates, but the addition of a single new gate will allow us to construct all gates. We find the maximal closed sets over a finite alphabet. We then extend to ancilla and borrow closure for reversible gates. Here we find some structural results, including some examples.","publish_time":1592352000000,"author_summary":" Boykett, Tim","abstract_summary":" We investigate collections of reversible<br>gates closed under parallel and serial composition.<br>In order to better understand the structure of<br>these collections of reversible gates, we<br>investigate the lattice of closed sets and the maximal<br>members of this lattice, that is, collections that are<br>not all gates, but the addition of a single new gate<br>will allow us to construct all gates. We find the<br>maximal closed sets over a finite alphabet. We then<br>extend to ancilla and borrow closure for reversible<br>gates. Here we find some structural results,<br>including some examples.","title_summary":" Maximality of Reversible Gate Sets","x":-23.8535633087,"y":45.3982620239,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.8535633087,"tsne_y":45.3982620239,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"8nvithto","source_x":"PMC","title":"Towards a Formal Account for Software Transactional Memory","doi":"10.1007\/978-3-030-52482-1_16","abstract":"Software transactional memory (STM) is a concurrency control mechanism for shared memory systems. It is opposite to the lock based mechanism, as it allows multiple processes to access the same set of variables in a concurrent way. Then according to the used policy, the effect of accessing to shared variables can be committed (hence, made permanent) or undone. In this paper, we define a formal framework for describing STMs and show how with a minor variation of the rules it is possible to model two common policies for STM: reader preference and writer preference.","publish_time":1592352000000,"author_summary":" Medi\u0107, Doriana; Mezzina, Claudio Antares;<br>Phillips, Iain; Yoshida, Nobuko","abstract_summary":" Software transactional memory (STM) is a<br>concurrency control mechanism for shared memory systems.<br>It is opposite to the lock based mechanism, as it<br>allows multiple processes to access the same set of<br>variables in a concurrent way. Then according to the used<br>policy, the effect of accessing to shared variables can<br>be committed (hence, made permanent) or undone.<br>In this paper, we define a formal framework for<br>describing STMs and show how with a minor variation of the<br>rules it is possible to model two common policies for<br>STM: reader preference and writer preference.","title_summary":" Towards a Formal Account for Software<br>Transactional Memory","x":-27.1999397278,"y":42.2121315002,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-27.1999397278,"tsne_y":42.2121315002,"subcluster":4,"subcluster_description":"Persistent Software Transactional","shape":"p"},{"cord_uid":"vntna1y0","source_x":"PMC","title":"Quantum CNOT Circuits Synthesis for NISQ Architectures Using the Syndrome Decoding Problem","doi":"10.1007\/978-3-030-52482-1_11","abstract":"Current proposals for quantum compilers involve the synthesis and optimization of linear reversible circuits and among them CNOT circuits. This class of circuits represents a significant part of the cost of running an entire quantum circuit and therefore we aim at reducing the size of CNOT circuits. In this paper we present a new algorithm for the synthesis of CNOT circuits based on the solution of the syndrome decoding problem. Our method addresses the case of ideal hardware with an all-to-all qubit connectivity and the case of near-term quantum devices with restricted connectivity. Benchmarks show that our algorithm outperforms existing algorithms in both cases of partial and full connectivity.","publish_time":1592352000000,"author_summary":" de Brugi\u00e8re, Timoth\u00e9e Goubault; Baboulin,<br>Marc; Valiron, Beno\u00eet; Martiel, Simon; Allouche,<br>Cyril","abstract_summary":" Current proposals for quantum compilers<br>involve the synthesis and optimization of linear<br>reversible circuits and among them CNOT circuits. This<br>class of circuits represents a significant part of<br>the cost of running an entire quantum circuit and<br>therefore we aim at reducing the size of CNOT circuits. In<br>this paper we present a new algorithm for the<br>synthesis of CNOT circuits based on the solution of the<br>syndrome decoding problem. Our method addresses the<br>case of ideal hardware with an all-to-all qubit<br>connectivity and the case of near-term quantum devices with<br>restricted connectivity. Benchmarks show that our<br>algorithm outperforms existing...","title_summary":" Quantum CNOT Circuits Synthesis for NISQ<br>Architectures Using the Syndrome Decoding Problem","x":-23.2207260132,"y":41.746673584,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.2207260132,"tsne_y":41.746673584,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"g1p8nhev","source_x":"PMC","title":"A Reversible Runtime Environment for Parallel Programs","doi":"10.1007\/978-3-030-52482-1_18","abstract":"We present a reversible runtime environment for simple parallel programs and its experimental implementation. We aim at a light-weight implementation of the backtrack reversibility by the state-saving mechanism using stacks. We translate a program to a sequence of simple commands of an executable intermediate representation for reversible stack machines. The parallel composition is implemented using the multiprocessing feature of Python. While executing the commands, the stack machines collect the information for the backward execution in the auxiliary stacks for the update history of the variables and the history of jumps. The commands for the backward execution is obtained by reversing the commands for the forward execution by replacing each command with the corresponding reversed command. In the purpose of behaviour analysis with reversibility such as debugging, our runtime is more portable than the source-to-source translation of a high-level programming language.","publish_time":1592352000000,"author_summary":" Ikeda, Takashi; Yuen, Shoji","abstract_summary":" We present a reversible runtime environment<br>for simple parallel programs and its experimental<br>implementation. We aim at a light-weight implementation of the<br>backtrack reversibility by the state-saving mechanism<br>using stacks. We translate a program to a sequence of<br>simple commands of an executable intermediate<br>representation for reversible stack machines. The parallel<br>composition is implemented using the multiprocessing<br>feature of Python. While executing the commands, the<br>stack machines collect the information for the<br>backward execution in the auxiliary stacks for the<br>update history of the variables and the history of<br>jumps. The commands for the backward execution is<br>obtained by reversing...","title_summary":" A Reversible Runtime Environment for Parallel<br>Programs","x":-26.5675125122,"y":42.7728691101,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.5675125122,"tsne_y":42.7728691101,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"72qu2hnq","source_x":"PMC","title":"Event Structures for the Reversible Early Internal [Formula: see text]-Calculus","doi":"10.1007\/978-3-030-52482-1_4","abstract":"The [Formula: see text]-calculus is a widely used process calculus, which models communications between processes and allows the passing of communication links. Various operational semantics of the [Formula: see text]-calculus have been proposed, which can be classified according to whether transitions are unlabelled (so-called reductions) or labelled. With labelled transitions, we can distinguish early and late semantics. The early version allows a process to receive names it already knows from the environment, while the late semantics and reduction semantics do not. All existing reversible versions of the [Formula: see text]-calculus use reduction or late semantics, despite the early semantics of the (forward-only) [Formula: see text]-calculus being more widely used than the late. We define [Formula: see text]IH, the first reversible early [Formula: see text]-calculus, and give it a denotational semantics in terms of reversible bundle event structures. The new calculus is a reversible form of the internal [Formula: see text]-calculus, which is a subset of the [Formula: see text]-calculus where every link sent by an output is private, yielding greater symmetry between inputs and outputs.","publish_time":1592352000000,"author_summary":" Graversen, Eva; Phillips, Iain; Yoshida,<br>Nobuko","abstract_summary":" The [Formula: see text]-calculus is a widely<br>used process calculus, which models<br>communications between processes and allows the passing of<br>communication links. Various operational semantics of the<br>[Formula: see text]-calculus have been proposed, which<br>can be classified according to whether<br>transitions are unlabelled (so-called reductions) or<br>labelled. With labelled transitions, we can distinguish<br>early and late semantics. The early version allows a<br>process to receive names it already knows from the<br>environment, while the late semantics and reduction<br>semantics do not. All existing reversible versions of the<br>[Formula: see text]-calculus use reduction or late<br>semantics, despite the early semantics of...","title_summary":" Event Structures for the Reversible Early<br>Internal [Formula: see text]-Calculus","x":-23.9891452789,"y":44.5637969971,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.9891452789,"tsne_y":44.5637969971,"subcluster":21,"subcluster_description":"Stack Automata Modelsinvolutory Turing","shape":"p"},{"cord_uid":"yjh6cb89","source_x":"PMC","title":"Hermes: A Language for Light-Weight Encryption","doi":"10.1007\/978-3-030-52482-1_5","abstract":"Hermes is a domain-specific language for writing light-weight encryption algorithms: It is reversible, so it is not necessary to write separate encryption and decryption procedures, and it avoids several types of side-channel attacks, both by ensuring no secret values are left in memory and by ensuring that operations on secret data spend time independent of the value of this data, thus preventing timing-based attacks. We show a complete formal specification of Hermes, argue absence of timing-based attacks (under reasonable assumptions), and compare implementations of well-known light-weight encryption algorithms in Hermes and C.","publish_time":1592352000000,"author_summary":" Mogensen, Torben \u00c6gidius","abstract_summary":" Hermes is a domain-specific language for<br>writing light-weight encryption algorithms: It is<br>reversible, so it is not necessary to write separate<br>encryption and decryption procedures, and it avoids<br>several types of side-channel attacks, both by<br>ensuring no secret values are left in memory and by<br>ensuring that operations on secret data spend time<br>independent of the value of this data, thus preventing<br>timing-based attacks. We show a complete formal<br>specification of Hermes, argue absence of timing-based<br>attacks (under reasonable assumptions), and compare<br>implementations of well-known light-weight encryption<br>algorithms in Hermes and C.","title_summary":" Hermes: A Language for Light-Weight<br>Encryption","x":-24.140291214,"y":40.3874702454,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.140291214,"tsne_y":40.3874702454,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"kor9k88f","source_x":"PMC","title":"A Tutorial Introduction to Quantum Circuit Programming in Dependently Typed Proto-Quipper","doi":"10.1007\/978-3-030-52482-1_9","abstract":"We introduce dependently typed Proto-Quipper, or Proto-Quipper-D for short, an experimental quantum circuit programming language with linear dependent types. We give several examples to illustrate how linear dependent types can help in the construction of correct quantum circuits. Specifically, we show how dependent types enable programming families of circuits, and how dependent types solve the problem of type-safe uncomputation of garbage qubits. We also discuss other language features along the way.","publish_time":1592352000000,"author_summary":" Fu, Peng; Kishida, Kohei; Ross, Neil J.;<br>Selinger, Peter","abstract_summary":" We introduce dependently typed<br>Proto-Quipper, or Proto-Quipper-D for short, an experimental<br>quantum circuit programming language with linear<br>dependent types. We give several examples to illustrate<br>how linear dependent types can help in the<br>construction of correct quantum circuits. Specifically, we<br>show how dependent types enable programming<br>families of circuits, and how dependent types solve the<br>problem of type-safe uncomputation of garbage qubits.<br>We also discuss other language features along the<br>way.","title_summary":" A Tutorial Introduction to Quantum Circuit<br>Programming in Dependently Typed Proto-Quipper","x":-23.2710018158,"y":42.0371551514,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.2710018158,"tsne_y":42.0371551514,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"bnxq0zi8","source_x":"PMC","title":"Canine Algorithm for Node Disjoint Paths","doi":"10.1007\/978-3-030-53956-6_13","abstract":"Node Disjoint Paths (NDP) is one of the extensively studied Graph Theory problem. In this problem, the input is a directed n vertex graph and the set of source destination pair of vertices. The goal is to find the maximum number of paths connecting each such pair, so that such discovered paths are node-disjoint. In this paper, a novel Canine Inspired Algorithm is proposed which is a bio-inspired one, based on the olfactory capabilities of canines in tracing and reaching a destination. Currently many of the existing algorithms try to identify disjoint paths in a linear manner, whereas the Canine algorithm can be executed in a concurrent manner, depending on the number of canines deployed to find the disjoint paths. The time complexity of the algorithm is estimated to be [Formula: see text] . We hope that this algorithm finds many applications in problems related to various fields such as communication networks, scheduling and transportation and provides better results.","publish_time":1592784000000,"author_summary":" Ananthalakshmi Ammal, R.; Sajimon, P. C.; S S,<br>Vinod Chandra","abstract_summary":" Node Disjoint Paths (NDP) is one of the<br>extensively studied Graph Theory problem. In this problem,<br>the input is a directed n vertex graph and the set of<br>source destination pair of vertices. The goal is to<br>find the maximum number of paths connecting each<br>such pair, so that such discovered paths are<br>node-disjoint. In this paper, a novel Canine Inspired<br>Algorithm is proposed which is a bio-inspired one, based<br>on the olfactory capabilities of canines in<br>tracing and reaching a destination. Currently many of<br>the existing algorithms try to identify disjoint<br>paths in a linear manner, whereas the Canine...","title_summary":" Canine Algorithm for Node Disjoint Paths","x":-22.3904647827,"y":43.0191268921,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.3904647827,"tsne_y":43.0191268921,"subcluster":30,"subcluster_description":"Singly Connected Vertex Deletionoptimal","shape":"p"},{"cord_uid":"o7wcdpn8","source_x":"ArXiv","title":"Proceedings Eighth Workshop on Mathematically Structured Functional Programming","doi":"10.4204\/eptcs.317","abstract":"This volume contains the proceedings of the Eighth Workshop on Mathematically Structured Functional Programming (MSFP 2020). The meeting was originally scheduled to take place in Dublin, Ireland on the 25th of April as a satellite event of the European Joint Conferences on Theory&Practice of Software (ETAPS 2020). Due to the COVID-19 pandemic, ETAPS 2020, and consequently MSFP 2020, has been postponed to a date yet to be determined. The MSFP workshop highlights applications of mathematical structures to programming applications. We promote the use of category theory, type theory, and formal language semantics to the development of simple and reasonable programs. This year's papers cover a variety of topics ranging from array programming to dependent types to effects.","publish_time":1588204800000,"author_summary":" New, Max S.; Lindley, Sam","abstract_summary":" This volume contains the proceedings of the<br>Eighth Workshop on Mathematically Structured<br>Functional Programming (MSFP 2020). The meeting was<br>originally scheduled to take place in Dublin, Ireland on<br>the 25th of April as a satellite event of the<br>European Joint Conferences on Theory&Practice of<br>Software (ETAPS 2020). Due to the COVID-19 pandemic,<br>ETAPS 2020, and consequently MSFP 2020, has been<br>postponed to a date yet to be determined. The MSFP workshop<br>highlights applications of mathematical structures to<br>programming applications. We promote the use of category<br>theory, type theory, and formal language semantics to<br>the development of simple and reasonable<br>programs....","title_summary":" Proceedings Eighth Workshop on<br>Mathematically Structured Functional Programming","x":-26.7355060577,"y":44.4149513245,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-26.7355060577,"tsne_y":44.4149513245,"subcluster":36,"subcluster_description":"Parametric Component-Based Systemsproceedings Eighth","shape":"p"},{"cord_uid":"l16yqe0g","source_x":"ArXiv","title":"Transportation inequalities for Markov kernels and their applications","doi":null,"abstract":"We study the relationship between functional inequalities for a Markov kernel on a metric space $X$ and inequalities of transportation distances on the space of probability measures $\\mathcal{P}(X)$. Extending results of Luise and Savar\\'e on Hellinger--Kantorovich contraction inequalities for the particular case of the heat semigroup on an $RCD(K,\\infty)$ metric space, we show that more generally, such contraction inequalities are equivalent to reverse Poincar\\'e inequalities. We also adapt the\"dynamic dual\"formulation of the Hellinger--Kantorovich distance to define a new family of divergences on $\\mathcal{P}(X)$ which generalize the R\\'enyi divergence, and we show that contraction inequalities for these divergences are equivalent to the reverse logarithmic Sobolev and Wang Harnack inequalities. We discuss applications including results on the convergence of Markov processes to equilibrium, and on quasi-invariance of heat kernel measures in finite and infinite-dimensional groups.","publish_time":1585958400000,"author_summary":" Baudoin, Fabrice; Eldredge, Nathaniel","abstract_summary":" We study the relationship between functional<br>inequalities for a Markov kernel on a metric space $X$ and<br>inequalities of transportation distances on the space of<br>probability measures $\\mathcal{P}(X)$. Extending<br>results of Luise and Savar\\'e on<br>Hellinger--Kantorovich contraction inequalities for the particular<br>case of the heat semigroup on an $RCD(K,\\infty)$<br>metric space, we show that more generally, such<br>contraction inequalities are equivalent to reverse<br>Poincar\\'e inequalities. We also adapt the\"dynamic<br>dual\"formulation of the Hellinger--Kantorovich distance to<br>define a new family of divergences on<br>$\\mathcal{P}(X)$ which generalize the R\\'enyi divergence, and<br>we show that contraction inequalities for these<br>divergences are equivalent to...","title_summary":" Transportation inequalities for Markov<br>kernels and their applications","x":-19.7797603607,"y":46.0739555359,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.7797603607,"tsne_y":46.0739555359,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"7zqfm125","source_x":"ArXiv","title":"Linear Time Construction of Indexable Founder Block Graphs","doi":null,"abstract":"We introduce a compact pangenome representation based on an optimal segmentation concept that aims to reconstruct founder sequences from a multiple sequence alignment (MSA). Such founder sequences have the feature that each row of the MSA is a recombination of the founders. Several linear time dynamic programming algorithms have been previously devised to optimize segmentations that induce founder blocks that then can be concatenated into a set of founder sequences. All possible concatenation orders can be expressed as a founder block graph. We observe a key property of such graphs: if the node labels (founder segments) do not repeat in the paths of the graph, such graphs can be indexed for efficient string matching. We call such graphs segment repeat-free founder block graphs. We give a linear time algorithm to construct a segment repeat-free founder block graph given an MSA. The algorithm combines techniques from the founder segmentation algorithms (Cazaux et al. SPIRE 2019) and fully-functional bidirectional Burrows-Wheeler index (Belazzougui and Cunial, CPM 2019). We derive a succinct index structure to support queries of arbitrary length in the paths of the graph. Experiments on an MSA of SAR-CoV-2 strains are reported. An MSA of size $410\\times 29811$ is compacted in one minute into a segment repeat-free founder block graph of 3900 nodes and 4440 edges. The maximum length and total length of node labels is 12 and 34968, respectively. The index on the graph takes only $3\\%$ of the size of the MSA.","publish_time":1589846400000,"author_summary":" Makinen, Veli; Cazaux, Bastien; Equi,<br>Massimo; Norri, Tuukka; Tomescu, Alexandru I.","abstract_summary":" We introduce a compact pangenome<br>representation based on an optimal segmentation concept that<br>aims to reconstruct founder sequences from a<br>multiple sequence alignment (MSA). Such founder<br>sequences have the feature that each row of the MSA is a<br>recombination of the founders. Several linear time dynamic<br>programming algorithms have been previously devised to<br>optimize segmentations that induce founder blocks that<br>then can be concatenated into a set of founder<br>sequences. All possible concatenation orders can be<br>expressed as a founder block graph. We observe a key<br>property of such graphs: if the node labels (founder<br>segments) do not repeat in...","title_summary":" Linear Time Construction of Indexable Founder<br>Block Graphs","x":-22.7341918945,"y":42.9458351135,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7341918945,"tsne_y":42.9458351135,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"vyug0yry","source_x":"ArXiv","title":"A direct construction of the Standard Brownian Motion","doi":null,"abstract":"In this note, we combine the two approaches of Billingsley (1998) and Cs\\H{o}rg\\H{o} and R\\'ev\\'esz (1980), to provide a detailed sequential and descriptive for creating s standard Brownian motion, from a Brownian motion whose time space is the class of non-negative dyadic numbers. By adding the proof of Etemadi's inequality to text, it becomes self-readable and serves as an independent source for researches and professors.","publish_time":1590969600000,"author_summary":" Samb, Lo Gane; Babacar, Niang Aladji; Harouna,<br>Sangare","abstract_summary":" In this note, we combine the two approaches of<br>Billingsley (1998) and Cs\\H{o}rg\\H{o} and R\\'ev\\'esz<br>(1980), to provide a detailed sequential and<br>descriptive for creating s standard Brownian motion, from a<br>Brownian motion whose time space is the class of<br>non-negative dyadic numbers. By adding the proof of<br>Etemadi's inequality to text, it becomes self-readable<br>and serves as an independent source for researches<br>and professors.","title_summary":" A direct construction of the Standard Brownian<br>Motion","x":-19.9783115387,"y":45.8142127991,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.9783115387,"tsne_y":45.8142127991,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"sbkjo51g","source_x":"ArXiv","title":"On Construction of weighted orthogonal matrices over finite field and its application in cryptography","doi":null,"abstract":"In this article, we propose a method to construct self orthogonal matrix, orthogonal matrix and anti orthogonal matrix over the finite field. Orthogonal matrices has numerous applications in cryptography, so here we demonstrate the application of weighted orthogonal matrix into cryptography. Using the proposed method of construction we see that it is very easy to transmit the private key and can easily convert the encrypted message into original message and at the same time it will be difficult to get the key matrix for intruder.","publish_time":1590710400000,"author_summary":" Kumari, Shipra; Mahato, Hrishikesh; Pushp,<br>Sumant","abstract_summary":" In this article, we propose a method to<br>construct self orthogonal matrix, orthogonal matrix and<br>anti orthogonal matrix over the finite field.<br>Orthogonal matrices has numerous applications in<br>cryptography, so here we demonstrate the application of<br>weighted orthogonal matrix into cryptography. Using<br>the proposed method of construction we see that it<br>is very easy to transmit the private key and can<br>easily convert the encrypted message into original<br>message and at the same time it will be difficult to get<br>the key matrix for intruder.","title_summary":" On Construction of weighted orthogonal<br>matrices over finite field and its application in<br>cryptography","x":-23.9248733521,"y":40.5485420227,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.9248733521,"tsne_y":40.5485420227,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"fbdiumbj","source_x":"ArXiv","title":"On the Brown-Peterson cohomology of $BPU_n$ in lower dimensions and the Thom map","doi":null,"abstract":"For an odd prime $p$, we determined the Brown-Peterson cohomology of $BPU_n$ in dimensions $-(2p-2)\\leq i\\leq 2p+2$, where $BPU_n$ is the classifying space of the projective unitary group $PU_n$. We construct a family of $p$-torsion classes $\\eta_{p,k}\\in BP^{2p^{k+1}+2}(BPU_n)$ for $p|n$ and $k\\geq 0$ and identify their images under the Thom map with well understood cohomology classes in $H^*(BPU_n;\\mathbb{Z}_{(p)})$.","publish_time":1588723200000,"author_summary":" Gu, Xing","abstract_summary":" For an odd prime $p$, we determined the<br>Brown-Peterson cohomology of $BPU_n$ in dimensions<br>$-(2p-2)\\leq i\\leq 2p+2$, where $BPU_n$ is the classifying<br>space of the projective unitary group $PU_n$. We<br>construct a family of $p$-torsion classes<br>$\\eta_{p,k}\\in BP^{2p^{k+1}+2}(BPU_n)$ for $p|n$ and $k\\geq<br>0$ and identify their images under the Thom map<br>with well understood cohomology classes in<br>$H^*(BPU_n;\\mathbb{Z}_{(p)})$.","title_summary":" On the Brown-Peterson cohomology of $BPU_n$ in<br>lower dimensions and the Thom map","x":-19.8956356049,"y":46.2637443542,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.8956356049,"tsne_y":46.2637443542,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"tsjsultc","source_x":"ArXiv","title":"Kauffman Bracket Skein Module of the Connected Sum of Handlebodies: A Counterexample","doi":null,"abstract":"In this paper we disprove a twenty-two year old theorem about the structure of the Kauffman bracket skein module of the connected sum of two handlebodies. We achieve this by analysing handle slidings on compressing discs in a handlebody. We find more relations than previously predicted for the Kauffman bracket skein module of the connected sum of handlebodies, when one of them is not a solid torus. Additionally, we speculate on the structure of the Kauffman bracket skein module of the connected sum of two solid tori.","publish_time":1589500800000,"author_summary":" Bakshi, Rhea Palak; Przytycki, J'ozef H.","abstract_summary":" In this paper we disprove a twenty-two year old<br>theorem about the structure of the Kauffman bracket<br>skein module of the connected sum of two<br>handlebodies. We achieve this by analysing handle slidings on<br>compressing discs in a handlebody. We find more relations<br>than previously predicted for the Kauffman bracket<br>skein module of the connected sum of handlebodies,<br>when one of them is not a solid torus. Additionally,<br>we speculate on the structure of the Kauffman<br>bracket skein module of the connected sum of two solid<br>tori.","title_summary":" Kauffman Bracket Skein Module of the Connected<br>Sum of Handlebodies: A Counterexample","x":-21.6714229584,"y":46.0715255737,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.6714229584,"tsne_y":46.0715255737,"subcluster":26,"subcluster_description":"Symmetrykauffman Bracket Skein Module","shape":"p"},{"cord_uid":"n40j6bnh","source_x":"ArXiv","title":"A Fast Binary Splitting Approach to Non-Adaptive Group Testing","doi":null,"abstract":"In this paper, we consider the problem of noiseless non-adaptive group testing under the for-each recovery guarantee, also known as probabilistic group testing. In the case of $n$ items and $k$ defectives, we provide an algorithm attaining high-probability recovery with $O(k \\log n)$ scaling in both the number of tests and runtime, improving on the best known $O(k^2 \\log k \\cdot \\log n)$ runtime previously available for any algorithm that only uses $O(k \\log n)$ tests. Our algorithm bears resemblance to Hwang's adaptive generalized binary splitting algorithm (Hwang, 1972); we recursively work with groups of items of geometrically vanishing sizes, while maintaining a list of\"possibly defective\"groups and circumventing the need for adaptivity. While the most basic form of our algorithm requires $\\Omega(n)$ storage, we also provide a low-storage variant based on hashing, with similar recovery guarantees.","publish_time":1592438400000,"author_summary":" Price, Eric; Scarlett, Jonathan","abstract_summary":" In this paper, we consider the problem of<br>noiseless non-adaptive group testing under the for-each<br>recovery guarantee, also known as probabilistic group<br>testing. In the case of $n$ items and $k$ defectives, we<br>provide an algorithm attaining high-probability<br>recovery with $O(k \\log n)$ scaling in both the number of<br>tests and runtime, improving on the best known $O(k^2<br>\\log k \\cdot \\log n)$ runtime previously available<br>for any algorithm that only uses $O(k \\log n)$<br>tests. Our algorithm bears resemblance to Hwang's<br>adaptive generalized binary splitting algorithm<br>(Hwang, 1972); we recursively work with groups of items<br>of geometrically vanishing sizes,...","title_summary":" A Fast Binary Splitting Approach to<br>Non-Adaptive Group Testing","x":-22.0234718323,"y":42.1189231873,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.0234718323,"tsne_y":42.1189231873,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"uwntrf3y","source_x":"ArXiv","title":"Controlled Mather-Thurston theorems","doi":null,"abstract":"Classical results of Milnor, Wood, Mather, and Thurston produce flat connections in surprising places. The Milnor-Wood inequality is for circle bundles over surfaces, whereas the Mather-Thurston Theorem is about cobording general manifold bundles to ones admitting a flat connection. The surprise comes from the close encounter with obstructions from Chern-Weyl theory and other smooth obstructions such as the Bott classes and the Godbillion-Vey invariant. Contradiction is avoided because the structure groups for the positive results are larger than required by the obstructions, e.g.\\ $\\operatorname{PSL}(2,\\R)$ versus $\\operatorname{U}(1)$ in the former case and $C^1$ versus $C^2$ in the latter. This paper adds two types of control strengthening the positive results: In many cases we are able to (1) refine the Mather-Thurston cobordism to a semi-$s$-cobordism (ssc) and (2) provide detail about how, and to what extent, transition functions must wander from an initial, small, structure group into a larger one. The motivation is to lay mathematical foundations for a physical program. The philosophy is that living in the IR we cannot expect to know, for a given bundle, if it has curvature or is flat, because we can't resolve the fine scale topology which may be present in the base, introduced by a ssc, nor minute symmetry violating distortions of the fiber. Small scale, UV,\"distortions\"of the base topology and structure group allow flat connections to simulate curvature at larger scales. The goal is to find a duality under which curvature terms, such as Maxwell's $F \\wedge F^\\ast$ and Hilbert's $\\int R\\ dvol$ are replaced by an action which measures these\"distortions.\"In this view, curvature results from renormalizing a discrete, group theoretic, structure.","publish_time":1590796800000,"author_summary":" Freedman, Michael","abstract_summary":" Classical results of Milnor, Wood, Mather, and<br>Thurston produce flat connections in surprising<br>places. The Milnor-Wood inequality is for circle<br>bundles over surfaces, whereas the Mather-Thurston<br>Theorem is about cobording general manifold bundles to<br>ones admitting a flat connection. The surprise<br>comes from the close encounter with obstructions<br>from Chern-Weyl theory and other smooth<br>obstructions such as the Bott classes and the Godbillion-Vey<br>invariant. Contradiction is avoided because the<br>structure groups for the positive results are larger than<br>required by the obstructions, e.g.\\<br>$\\operatorname{PSL}(2,\\R)$ versus $\\operatorname{U}(1)$ in the former<br>case and $C^1$ versus $C^2$ in the latter. This paper<br>adds...","title_summary":" Controlled Mather-Thurston theorems","x":-20.404586792,"y":45.9016685486,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-20.404586792,"tsne_y":45.9016685486,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"vtwn5mmd","source_x":"ArXiv","title":"ARIANN: Low-Interaction Privacy-Preserving Deep Learning via Function Secret Sharing","doi":null,"abstract":"We propose ARIANN, a low-interaction framework to perform private training and inference of standard deep neural networks on sensitive data. This framework implements semi-honest 2-party computation and leverages function secret sharing, a recent cryptographic protocol that only uses lightweight primitives to achieve an efficient online phase with a single message of the size of the inputs, for operations like comparison and multiplication which are building blocks of neural networks. Built on top of PyTorch, it offers a wide range of functions including ReLU, MaxPool and BatchNorm, and allows to use models like AlexNet or ResNet18. We report experimental results for inference and training over distant servers. Last, we propose an extension to support n-party private federated learning.","publish_time":1591574400000,"author_summary":" Ryffel, Th'eo; Pointcheval, David; Bach,<br>Francis","abstract_summary":" We propose ARIANN, a low-interaction<br>framework to perform private training and inference of<br>standard deep neural networks on sensitive data. This<br>framework implements semi-honest 2-party computation<br>and leverages function secret sharing, a recent<br>cryptographic protocol that only uses lightweight<br>primitives to achieve an efficient online phase with a<br>single message of the size of the inputs, for<br>operations like comparison and multiplication which are<br>building blocks of neural networks. Built on top of<br>PyTorch, it offers a wide range of functions including<br>ReLU, MaxPool and BatchNorm, and allows to use models<br>like AlexNet or ResNet18. We report experimental<br>results for...","title_summary":" ARIANN: Low-Interaction Privacy-Preserving<br>Deep Learning via Function Secret Sharing","x":-24.0668182373,"y":39.8100814819,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.0668182373,"tsne_y":39.8100814819,"subcluster":0,"subcluster_description":"Adaptive Chosen Message Securityless","shape":"p"},{"cord_uid":"kmec6wwd","source_x":"ArXiv","title":"Sharp bounds for the largest eigenvalue of the normalized hypergraph Laplace Operator","doi":null,"abstract":"We generalize the classical sharp bounds for the largest eigenvalue of the normalized Laplace operator, $\\frac{N}{N-1}\\leq \\lambda_N\\leq 2$, to the case of chemical hypergraphs.","publish_time":1586044800000,"author_summary":" Mulas, Raffaella","abstract_summary":" We generalize the classical sharp bounds for<br>the largest eigenvalue of the normalized Laplace<br>operator, $\\frac{N}{N-1}\\leq \\lambda_N\\leq 2$, to the<br>case of chemical hypergraphs.","title_summary":" Sharp bounds for the largest eigenvalue of the<br>normalized hypergraph Laplace Operator","x":-20.7683830261,"y":46.3590812683,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-20.7683830261,"tsne_y":46.3590812683,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"pg4gongz","source_x":"ArXiv","title":"A Minimal 7-Fold Rhombic Tiling","doi":null,"abstract":"A study of 7-fold tilings that use a set of three proto-rhombs in a substitution scheme to tile a large area. A set is discovered that is thought to be the most minimal or smallest one. The scheme uses 11 proto-rhombs to tile the next generation of inflated tiles. The general form of 7-fold substitutions is shown and the role of the 7-fold magic number phi is derived. The figures include a number of newly discovered 7-fold tilings.","publish_time":1591142400000,"author_summary":" Schaad, Theo P.","abstract_summary":" A study of 7-fold tilings that use a set of three<br>proto-rhombs in a substitution scheme to tile a large area. A<br>set is discovered that is thought to be the most<br>minimal or smallest one. The scheme uses 11<br>proto-rhombs to tile the next generation of inflated tiles.<br>The general form of 7-fold substitutions is shown<br>and the role of the 7-fold magic number phi is<br>derived. The figures include a number of newly<br>discovered 7-fold tilings.","title_summary":" A Minimal 7-Fold Rhombic Tiling","x":-22.7398490906,"y":45.88829422,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7398490906,"tsne_y":45.88829422,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"hqsxsbji","source_x":"ArXiv","title":"Contact surface of Cheeger sets","doi":null,"abstract":"We carry on an analysis of the size of the contact surface of a Cheeger set $E$ with the boundary of its ambient space $\\Omega$. We show that this size is strongly related to the regularity of $\\partial \\Omega$ by providing bounds on the Hausdorff dimension of $\\partial E\\cap \\partial\\Omega$. In particular we show that, if $\\partial \\Omega$ has $C^{1,\\alpha}$ regularity then $\\mathcal{H}^{d-2+\\alpha}(\\partial E\\cap \\partial\\Omega)>0$. This shows that a sufficient condition to ensure that $\\mathcal{H}^{d-1}(\\partial E\\cap \\partial \\Omega)>0$ is that $\\partial \\Omega$ has $C^{1,1}$ regularity. Since the Hausdorff bounds can be inferred in dependence of the regularity of $\\partial E$ as well, we obtain that $\\Omega$ convex, which yields $\\partial E\\in C^{1,1}$, is also a sufficient condition. Finally, we construct examples showing that such bounds are optimal in dimension $d=2$.","publish_time":1589328000000,"author_summary":" Caroccia, Marco; Ciani, Simone","abstract_summary":" We carry on an analysis of the size of the contact<br>surface of a Cheeger set $E$ with the boundary of its<br>ambient space $\\Omega$. We show that this size is<br>strongly related to the regularity of $\\partial \\Omega$<br>by providing bounds on the Hausdorff dimension of<br>$\\partial E\\cap \\partial\\Omega$. In particular we show<br>that, if $\\partial \\Omega$ has $C^{1,\\alpha}$<br>regularity then $\\mathcal{H}^{d-2+\\alpha}(\\partial<br>E\\cap \\partial\\Omega)>0$. This shows that a<br>sufficient condition to ensure that<br>$\\mathcal{H}^{d-1}(\\partial E\\cap \\partial \\Omega)>0$ is that $\\partial<br>\\Omega$ has $C^{1,1}$ regularity. Since the Hausdorff<br>bounds can be inferred in dependence of the regularity<br>of $\\partial E$...","title_summary":" Contact surface of Cheeger sets","x":-19.839548111,"y":46.2510299683,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.839548111,"tsne_y":46.2510299683,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"hbctqwsm","source_x":"ArXiv","title":"Arbitrarily sparse spectra for self-affine spectral measures","doi":null,"abstract":"Given an expansive matrix $R\\in M_d({\\mathbb Z})$ and a finite set of digit $B$ taken from $ {\\mathbb Z}^d\/R({\\mathbb Z}^d)$. It was shown previously that if we can find an $L$ such that $(R,B,L)$ forms a Hadamard triple, then the associated fractal self-affine measure generated by $(R,B)$ admits an exponential orthonormal basis of certain frequency set $\\Lambda$, and hence it is termed as a spectral measure. In this paper, we show that if #$B<|\\det (R)|$, not only it is spectral, we can also construct arbitrarily sparse spectrum $\\Lambda$ in the sense that its Beurling dimension is zero.","publish_time":1592956800000,"author_summary":" An, Li-Xiang; Lai, Chun-Kit","abstract_summary":" Given an expansive matrix $R\\in M_d({\\mathbb<br>Z})$ and a finite set of digit $B$ taken from $<br>{\\mathbb Z}^d\/R({\\mathbb Z}^d)$. It was shown<br>previously that if we can find an $L$ such that $(R,B,L)$<br>forms a Hadamard triple, then the associated fractal<br>self-affine measure generated by $(R,B)$ admits an<br>exponential orthonormal basis of certain frequency set<br>$\\Lambda$, and hence it is termed as a spectral measure. In<br>this paper, we show that if #$B<|\\det (R)|$, not only<br>it is spectral, we can also construct arbitrarily<br>sparse spectrum $\\Lambda$ in the sense that its<br>Beurling dimension is zero.","title_summary":" Arbitrarily sparse spectra for self-affine<br>spectral measures","x":-19.8295345306,"y":46.2273674011,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.8295345306,"tsne_y":46.2273674011,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"ydvbt97k","source_x":"ArXiv","title":"Lefschetz theory for exterior algebras and fermionic diagonal coinvariants","doi":null,"abstract":"Let $W$ be an irreducible complex reflection group acting on its reflection representation $V$. We consider the doubly graded action of $W$ on the exterior algebra $\\wedge (V \\oplus V^*)$ as well as its quotient $DR_W := \\wedge (V \\oplus V^*)\/ \\langle \\wedge (V \\oplus V^*)^{W}_+ \\rangle$ by the ideal generated by its homogeneous $W$-invariants with vanishing constant term. We describe the bigraded isomorphism type of $DR_W$; when $W = \\mathfrak{S}_n$ is the symmetric group, the answer is a difference of Kronecker products of hook-shaped $\\mathfrak{S}_n$-modules. We relate the Hilbert series of $DR_W$ to the (type A) Catalan and Narayana numbers and describe a standard monomial basis of $DR_W$ using a variant of Motzkin paths. Our methods are type-uniform and involve a Lefschetz-like theory which applies to the exterior algebra $\\wedge (V \\oplus V^*)$.","publish_time":1584921600000,"author_summary":" Kim, Jongwon; Rhoades, Brendon","abstract_summary":" Let $W$ be an irreducible complex reflection<br>group acting on its reflection representation $V$.<br>We consider the doubly graded action of $W$ on the<br>exterior algebra $\\wedge (V \\oplus V^*)$ as well as its<br>quotient $DR_W := \\wedge (V \\oplus V^*)\/ \\langle \\wedge<br>(V \\oplus V^*)^{W}_+ \\rangle$ by the ideal<br>generated by its homogeneous $W$-invariants with<br>vanishing constant term. We describe the bigraded<br>isomorphism type of $DR_W$; when $W = \\mathfrak{S}_n$ is the<br>symmetric group, the answer is a difference of Kronecker<br>products of hook-shaped $\\mathfrak{S}_n$-modules. We<br>relate the Hilbert series of $DR_W$ to the (type A)<br>Catalan and Narayana...","title_summary":" Lefschetz theory for exterior algebras and<br>fermionic diagonal coinvariants","x":-19.9469966888,"y":46.2261276245,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.9469966888,"tsne_y":46.2261276245,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"80ebtfwr","source_x":"ArXiv","title":"On a maximum of nearest-neighbor random walk with asymptotically zero drift on lattice of positive half line","doi":null,"abstract":"Consider a nearest-neighbor random walk with certain asymptotically zero drift on the positive half line. Let $M$ be the maximum of an excursion starting from $1$ and ending at $0.$ We study the distribution of $M$ and characterize its asymptotics, which is quite different from those of simple random walks.","publish_time":1587859200000,"author_summary":" Sun, Hongyan; Wang, Hua-Ming","abstract_summary":" Consider a nearest-neighbor random walk with<br>certain asymptotically zero drift on the positive half<br>line. Let $M$ be the maximum of an excursion starting<br>from $1$ and ending at $0.$ We study the distribution<br>of $M$ and characterize its asymptotics, which is<br>quite different from those of simple random walks.","title_summary":" On a maximum of nearest-neighbor random walk<br>with asymptotically zero drift on lattice of<br>positive half line","x":-19.9404792786,"y":45.9932785034,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.9404792786,"tsne_y":45.9932785034,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"gcj7m0yg","source_x":"ArXiv","title":"Noisy three-player dilemma game: Robustness of the quantum advantage","doi":null,"abstract":"Games involving quantum strategies often yield higher payoff. Here, we study a practical realization of the three-player dilemma game using the superconductivity-based quantum processors provided by IBM Q Experience. We analyze the persistence of the quantum advantage under corruption of the input states and how this depends on parameters of the payoff table. Specifically, experimental fidelity and error are observed not to be properly anti correlated, i.e., there are instances where a class of experiments with higher fidelity yields a greater error in the payoff. Further, we find that the classical strategy will always outperform the quantum strategy if corruption is higher than half.","publish_time":1586390400000,"author_summary":" Kairon, Pranav; Thapliyal, Kishore;<br>Srikanth, R.; Pathak, Anirban","abstract_summary":" Games involving quantum strategies often<br>yield higher payoff. Here, we study a practical<br>realization of the three-player dilemma game using the<br>superconductivity-based quantum processors provided by IBM Q<br>Experience. We analyze the persistence of the quantum<br>advantage under corruption of the input states and how<br>this depends on parameters of the payoff table.<br>Specifically, experimental fidelity and error are observed<br>not to be properly anti correlated, i.e., there are<br>instances where a class of experiments with higher<br>fidelity yields a greater error in the payoff. Further,<br>we find that the classical strategy will always<br>outperform the quantum strategy if corruption...","title_summary":" Noisy three-player dilemma game: Robustness<br>of the quantum advantage","x":-22.7019824982,"y":41.4704017639,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7019824982,"tsne_y":41.4704017639,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"nuu2l0y6","source_x":"ArXiv","title":"A Functorial Approach to Differential Calculus","doi":null,"abstract":"We show that differential calculus (in its usual form, or in the general form of topological differential calculus) can be fully imdedded into a functor category (functors from a small category of anchord tangent algebras to anchored sets). To prepare this approach, we define a new, symmetric, presentation of differential calculus, whose main feature is the central r{\\^o}le played by the anchor map, which we study in detail. Our aim for developing this theory is twofold: (1) define a setting for calculus over any commutative ring, including finite rings; (2) define a setting that can be generalized to categories of graded rings (super differential calculus).","publish_time":1591574400000,"author_summary":" Bertram, Wolfgang; Haut, J'er'emy","abstract_summary":" We show that differential calculus (in its<br>usual form, or in the general form of topological<br>differential calculus) can be fully imdedded into a functor<br>category (functors from a small category of anchord<br>tangent algebras to anchored sets). To prepare this<br>approach, we define a new, symmetric, presentation of<br>differential calculus, whose main feature is the central<br>r{\\^o}le played by the anchor map, which we study in<br>detail. Our aim for developing this theory is twofold:<br>(1) define a setting for calculus over any<br>commutative ring, including finite rings; (2) define a<br>setting that can be generalized to categories of...","title_summary":" A Functorial Approach to Differential<br>Calculus","x":-21.5520267487,"y":45.7147369385,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.5520267487,"tsne_y":45.7147369385,"subcluster":26,"subcluster_description":"Symmetrykauffman Bracket Skein Module","shape":"p"},{"cord_uid":"iudm8cge","source_x":"ArXiv","title":"Unit groups of some multiquadratic number fields and $2$-class groups","doi":null,"abstract":"Let $p\\equiv -q \\equiv 5\\pmod 8$ be two prime integers. In this paper, we investigate the unit groups of the fields $ L_1 =\\mathbb{Q}(\\sqrt 2, \\sqrt{p}, \\sqrt{q}, \\sqrt{-1} )$ and $ L_1^+=\\mathbb{Q}(\\sqrt 2, \\sqrt{p}, \\sqrt{q} )$. Furthermore , we give the second $ 2$-class groups of the subextensions of $L_1$ as well the $2$-class groups of the fields $ L_n =\\mathbb{Q}( \\sqrt{p}, \\sqrt{q}, \\zeta_{2^{n+2}} )$ and their maximal real subfelds.","publish_time":1587254400000,"author_summary":" Chems-Eddin, Mohamed Mahmoud","abstract_summary":" Let $p\\equiv -q \\equiv 5\\pmod 8$ be two prime<br>integers. In this paper, we investigate the unit groups of<br>the fields $ L_1 =\\mathbb{Q}(\\sqrt 2, \\sqrt{p},<br>\\sqrt{q}, \\sqrt{-1} )$ and $ L_1^+=\\mathbb{Q}(\\sqrt 2,<br>\\sqrt{p}, \\sqrt{q} )$. Furthermore , we give the second $<br>2$-class groups of the subextensions of $L_1$ as well the<br>$2$-class groups of the fields $ L_n =\\mathbb{Q}(<br>\\sqrt{p}, \\sqrt{q}, \\zeta_{2^{n+2}} )$ and their<br>maximal real subfelds.","title_summary":" Unit groups of some multiquadratic number<br>fields and $2$-class groups","x":-19.8680114746,"y":46.2571258545,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.8680114746,"tsne_y":46.2571258545,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"f9s1x2t3","source_x":"ArXiv","title":"Combinatorial Group Testing and Sparse Recovery Schemes with Near-Optimal Decoding Time","doi":null,"abstract":"In the long-studied problem of combinatorial group testing, one is asked to detect a set of $k$ defective items out of a population of size $n$, using $m \\ll n$ disjunctive measurements. In the non-adaptive setting, the most widely used combinatorial objects are disjunct and list-disjunct matrices, which define incidence matrices of test schemes. Disjunct matrices allow the identification of the exact set of defectives, whereas list disjunct matrices identify a small superset of the defectives. Apart from the combinatorial guarantees, it is often of key interest to equip measurement designs with efficient decoding algorithms. The most efficient decoders should run in sublinear time in $n$, and ideally near-linear in the number of measurements $m$. In this work, we give several constructions with an optimal number of measurements and near-optimal decoding time for the most fundamental group testing tasks, as well as for central tasks in the compressed sensing and heavy hitters literature. For many of those tasks, the previous measurement-optimal constructions needed time either quadratic in the number of measurements or linear in the universe size. Most of our results are obtained via a clean and novel approach which avoids list-recoverable codes or related complex techniques which were present in almost every state-of-the-art work on efficiently decodable constructions of such objects.","publish_time":1592179200000,"author_summary":" Cheraghchi, Mahdi; Nakos, Vasileios","abstract_summary":" In the long-studied problem of combinatorial<br>group testing, one is asked to detect a set of $k$<br>defective items out of a population of size $n$, using $m<br>\\ll n$ disjunctive measurements. In the<br>non-adaptive setting, the most widely used combinatorial<br>objects are disjunct and list-disjunct matrices,<br>which define incidence matrices of test schemes.<br>Disjunct matrices allow the identification of the exact<br>set of defectives, whereas list disjunct matrices<br>identify a small superset of the defectives. Apart from<br>the combinatorial guarantees, it is often of key<br>interest to equip measurement designs with efficient<br>decoding algorithms. The most efficient decoders<br>should...","title_summary":" Combinatorial Group Testing and Sparse<br>Recovery Schemes with Near-Optimal Decoding Time","x":-22.0085945129,"y":42.0935554504,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.0085945129,"tsne_y":42.0935554504,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"0xew5qm5","source_x":"ArXiv","title":"Surgeries of the Gieseking hyperbolic ideal simplex manifold","doi":null,"abstract":"In our Novi Sad conference paper (1999) we described Dehn type surgeries of the famous Gieseking (1912) hyperbolic ideal simplex manifold $\\mathcal{S}$, leading to compact fundamental domain $\\mathcal{S}(k)$, $k = 2, 3, \\dots$ with singularity geodesics of rotation order $k$, but as later turned out with cone angle $2(k-1)\/k$. We computed also the volume of $S(k)$, tending to zero if $k$ goes to infinity. That time we naively thought that we obtained orbifolds with the above surprising property. As the reviewer of Math. Rev., Kevin P. Scannell (MR1770996 (2001g:57030)) rightly remarked,\"this is in conflict with the well-known theorem of D. A. Kazhdan and G. A. Margulis (1968) and with the work of Thurston, describing the geometric convergence of orbifolds under large Dehn fillings\". In this paper we refresh our previous publication. Correctly, we obtained cone manifolds (for $k>2$), as A. D. Mednykh and V. S. Petrov (2006) kindly pointed out. We complete our discussion and derive the above cone manifold series (Gies.1 and Gies.2) in two geometrically equivalent form, by the half turn symmetry of any ideal simplex. Moreover we obtain a second orbifold series (Gies.3 and 4), tending to the regular ideal simplex as the original Gieseking manifold.","publish_time":1587772800000,"author_summary":" Moln'ar, E.; Prok, I.; Szirmai, J.","abstract_summary":" In our Novi Sad conference paper (1999) we<br>described Dehn type surgeries of the famous Gieseking<br>(1912) hyperbolic ideal simplex manifold<br>$\\mathcal{S}$, leading to compact fundamental domain<br>$\\mathcal{S}(k)$, $k = 2, 3, \\dots$ with singularity geodesics of<br>rotation order $k$, but as later turned out with cone<br>angle $2(k-1)\/k$. We computed also the volume of<br>$S(k)$, tending to zero if $k$ goes to infinity. That<br>time we naively thought that we obtained orbifolds<br>with the above surprising property. As the reviewer<br>of Math. Rev., Kevin P. Scannell (MR1770996<br>(2001g:57030)) rightly remarked,\"this is in conflict with the<br>well-known theorem of D....","title_summary":" Surgeries of the Gieseking hyperbolic ideal<br>simplex manifold","x":-20.3462257385,"y":45.9877166748,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-20.3462257385,"tsne_y":45.9877166748,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"5ghcnybg","source_x":"ArXiv","title":"On A-numerical radius inequalities for $2 \\times 2$ operator matrices","doi":null,"abstract":"Let ($\\mathcal{H}, \\langle . , .\\rangle )$ be a complex Hilbert space and $A$ be a positive bounded linear operator on it. Let $w_A(T)$ be the $A$-numerical radius and $\\|T\\|_A$ be the $A$-operator seminorm of an operator $T$ acting on the semi-Hilbertian space $(\\mathcal{H}, \\langle .,.\\rangle_A),$ where $\\langle x, y\\rangle_A:=\\langle Ax, y\\rangle$ for all $x,y\\in \\mathcal{H}$. In this article, we establish several upper and lower bounds for $B$-numerical radius of $2\\times 2$ operator matrices, where $B=\\begin{bmatrix} A&0 0&A \\end{bmatrix}$. Further, we prove some refinements of earlier $A$-numerical radius inequalities for operators.","publish_time":1586995200000,"author_summary":" Rout, Nirmal Chandra; Sahoo, Satyajit;<br>Mishra, Debasisha","abstract_summary":" Let ($\\mathcal{H}, \\langle . , .\\rangle )$ be a<br>complex Hilbert space and $A$ be a positive bounded<br>linear operator on it. Let $w_A(T)$ be the<br>$A$-numerical radius and $\\|T\\|_A$ be the $A$-operator<br>seminorm of an operator $T$ acting on the<br>semi-Hilbertian space $(\\mathcal{H}, \\langle<br>.,.\\rangle_A),$ where $\\langle x, y\\rangle_A:=\\langle Ax,<br>y\\rangle$ for all $x,y\\in \\mathcal{H}$. In this article,<br>we establish several upper and lower bounds for<br>$B$-numerical radius of $2\\times 2$ operator matrices, where<br>$B=\\begin{bmatrix} A&0 0&A \\end{bmatrix}$. Further, we prove some<br>refinements of earlier $A$-numerical radius inequalities<br>for operators.","title_summary":" On A-numerical radius inequalities for $2<br>\\times 2$ operator matrices","x":-19.7899227142,"y":46.2296409607,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.7899227142,"tsne_y":46.2296409607,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"qobbbrj2","source_x":"ArXiv","title":"Further results on $\\mathbb{A}$-numerical radius inequalities","doi":null,"abstract":"Let $\\mathcal{H}$ be a complex Hilbert space, and $A$ be a positive bounded linear operator on $\\mathcal{H}.$ Let $\\mathcal{B}_A\\mathcal{(H)}$ denotes the set of all bounded linear operators on $\\mathcal{H}$ whose $A$-adjoint exists. Let $\\mathbb{A}$ denotes a diagonal operator matrix with diagonal entries are $A.$ In this paper, we prove a few new $\\mathbb{A}$-numerical radius inequalities for $2\\times 2$ and $n\\times n$ operator matrices. We also provide some new proofs of the existing results by relaxing different sufficient conditions like\"$A$ is strictly positive\"and\"$\\mathcal{N}(A)^\\perp$ is invariant subspace for different operators\". Our proofs show the importance of the theory of the Moore-Penrose inverse of bounded operators in this field of study.","publish_time":1594166400000,"author_summary":" Rout, Nirmal Chandra; Mishra, Debasisha","abstract_summary":" Let $\\mathcal{H}$ be a complex Hilbert space,<br>and $A$ be a positive bounded linear operator on<br>$\\mathcal{H}.$ Let $\\mathcal{B}_A\\mathcal{(H)}$ denotes<br>the set of all bounded linear operators on<br>$\\mathcal{H}$ whose $A$-adjoint exists. Let $\\mathbb{A}$<br>denotes a diagonal operator matrix with diagonal<br>entries are $A.$ In this paper, we prove a few new<br>$\\mathbb{A}$-numerical radius inequalities for $2\\times 2$ and<br>$n\\times n$ operator matrices. We also provide some new<br>proofs of the existing results by relaxing different<br>sufficient conditions like\"$A$ is strictly<br>positive\"and\"$\\mathcal{N}(A)^\\perp$ is invariant subspace for different<br>operators\". Our proofs show the importance of the theory of<br>the Moore-Penrose inverse...","title_summary":" Further results on $\\mathbb{A}$-numerical<br>radius inequalities","x":-19.7806015015,"y":46.2486839294,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.7806015015,"tsne_y":46.2486839294,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"2zhf0ivt","source_x":"ArXiv","title":"Bonnet-Myers sharp graphs of diameter three","doi":null,"abstract":"Regular graphs which are Bonnet-Myers sharp (in the sense of Ollivier Ricci curvature) and self-centered have been completely classified, and it is a natural question whether the condition of self-centeredness can be removed in the classification. We prove that this condition is indeed not necessary in the special case of Bonnet-Myers sharp graphs of diameter 3.","publish_time":1589414400000,"author_summary":" Kamtue, Supanat","abstract_summary":" Regular graphs which are Bonnet-Myers sharp<br>(in the sense of Ollivier Ricci curvature) and<br>self-centered have been completely classified, and it is a<br>natural question whether the condition of<br>self-centeredness can be removed in the classification. We prove<br>that this condition is indeed not necessary in the<br>special case of Bonnet-Myers sharp graphs of diameter<br>3.","title_summary":" Bonnet-Myers sharp graphs of diameter three","x":-21.9114894867,"y":46.3008995056,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.9114894867,"tsne_y":46.3008995056,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"utfp4xk2","source_x":"ArXiv","title":"Cantor-solus and Cantor-multus Distributions","doi":null,"abstract":"The Cantor distribution is obtained from bitstrings; the Cantor-solus distribution (a new name) admits only strings without adjacent 1 bits. We review moments and order statistics associated with these. The Cantor-multus distribution is introduced -- which instead admits only strings without isolated 1 bits -- and more complicated formulas emerge.","publish_time":1584662400000,"author_summary":" Finch, Steven","abstract_summary":" The Cantor distribution is obtained from<br>bitstrings; the Cantor-solus distribution (a new name)<br>admits only strings without adjacent 1 bits. We review<br>moments and order statistics associated with these.<br>The Cantor-multus distribution is introduced --<br>which instead admits only strings without isolated 1<br>bits -- and more complicated formulas emerge.","title_summary":" Cantor-solus and Cantor-multus<br>Distributions","x":-22.4797878265,"y":46.375453949,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4797878265,"tsne_y":46.375453949,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"6puwdrsg","source_x":"ArXiv","title":"On $\\mathbb{A}$-numerical radius inequalities for $2\\times2$ operator matrices-II","doi":null,"abstract":"The main goal of this article is to establish several new upper and lower bounds for the $\\mathbb{A}$-numerical radius of $2\\times 2$ operator matrices, where $\\mathbb{A}$ be the $2\\times 2$ diagonal operator matrix whose diagonal entries are positive bounded operator $A$.","publish_time":1593993600000,"author_summary":" Sahoo, Satyajit","abstract_summary":" The main goal of this article is to establish<br>several new upper and lower bounds for the<br>$\\mathbb{A}$-numerical radius of $2\\times 2$ operator matrices, where<br>$\\mathbb{A}$ be the $2\\times 2$ diagonal operator matrix<br>whose diagonal entries are positive bounded<br>operator $A$.","title_summary":" On $\\mathbb{A}$-numerical radius<br>inequalities for $2\\times2$ operator matrices-II","x":-19.9454898834,"y":46.2181663513,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.9454898834,"tsne_y":46.2181663513,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"5robi68a","source_x":"ArXiv","title":"Iterated $S^3$ Sasaki Joins and Bott Orbifolds","doi":null,"abstract":"We present a categorical relationship between iterated $S^3$ Sasaki-joins and Bott orbifolds. Then we show how to construct smooth Sasaki-Einstein (SE) structures on the iterated joins. These become increasingly complicated as dimension grows. We give an explicit construction of (infinitely many) smooth SE structures up through dimension eleven, and conjecture the existence of smooth SE structures in all odd dimensions.","publish_time":1591833600000,"author_summary":" Boyer, Charles P; Tonnesen-Friedman,<br>Christina","abstract_summary":" We present a categorical relationship between<br>iterated $S^3$ Sasaki-joins and Bott orbifolds. Then we<br>show how to construct smooth Sasaki-Einstein (SE)<br>structures on the iterated joins. These become<br>increasingly complicated as dimension grows. We give an<br>explicit construction of (infinitely many) smooth SE<br>structures up through dimension eleven, and conjecture<br>the existence of smooth SE structures in all odd<br>dimensions.","title_summary":" Iterated $S^3$ Sasaki Joins and Bott Orbifolds","x":-21.5988616943,"y":46.095199585,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-21.5988616943,"tsne_y":46.095199585,"subcluster":26,"subcluster_description":"Symmetrykauffman Bracket Skein Module","shape":"p"},{"cord_uid":"lvqkaymz","source_x":"ArXiv","title":"Weakly $\\omega$-Categorified Models of Algebraic Theories","doi":null,"abstract":"We provide the expected constructions of weakly $\\omega$-categorified models (in the sense of Bressie) of the theory of groups and quandles which arise by replacing the homotopies used to give equivalence relations in the theory of fundamental groups, fundamental quandles, and knot quandles with homotopies of all orders used as arrows of categorical dimensions one and greater, and discuss other related constructions of weakly $\\omega$-categorifed algebras.","publish_time":1593129600000,"author_summary":" Bressie, Phillip M; Yetter, David N","abstract_summary":" We provide the expected constructions of<br>weakly $\\omega$-categorified models (in the sense of<br>Bressie) of the theory of groups and quandles which arise<br>by replacing the homotopies used to give<br>equivalence relations in the theory of fundamental groups,<br>fundamental quandles, and knot quandles with homotopies of<br>all orders used as arrows of categorical<br>dimensions one and greater, and discuss other related<br>constructions of weakly $\\omega$-categorifed algebras.","title_summary":" Weakly $\\omega$-Categorified Models of<br>Algebraic Theories","x":-22.0295066833,"y":45.976524353,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.0295066833,"tsne_y":45.976524353,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"xzjfd7g8","source_x":"ArXiv","title":"On the impact of treewidth in the computational complexity of freezing dynamics","doi":null,"abstract":"An automata network is a network of entities, each holding a state from a finite set and evolving according to a local update rule which depends only on its neighbors in the network's graph. It is freezing if there is an order on states such that the state evolution of any node is non-decreasing in any orbit. They are commonly used to model epidemic propagation, diffusion phenomena like bootstrap percolation or cristal growth. In this paper we establish how treewidth and maximum degree of the underlying graph are key parameters which influence the overall computational complexity of finite freezing automata networks. First, we define a general model checking formalism that captures many classical decision problems: prediction, nilpotency, predecessor, asynchronous reachability. Then, on one hand, we present an efficient parallel algorithm that solves the general model checking problem in NC for any graph with bounded degree and bounded treewidth. On the other hand, we show that these problems are hard in their respective classes when restricted to families of graph with polynomially growing treewidth. For prediction, predecessor and asynchronous reachability, we establish the hardness result with a fixed set-defiend update rule that is universally hard on any input graph of such families.","publish_time":1590278400000,"author_summary":" Goles, Eric; Montealegre, Pedro;<br>R'ios-Wilson, Mart'in; Theyssier, Guillaume","abstract_summary":" An automata network is a network of entities,<br>each holding a state from a finite set and evolving<br>according to a local update rule which depends only on its<br>neighbors in the network's graph. It is freezing if there<br>is an order on states such that the state evolution<br>of any node is non-decreasing in any orbit. They<br>are commonly used to model epidemic propagation,<br>diffusion phenomena like bootstrap percolation or<br>cristal growth. In this paper we establish how<br>treewidth and maximum degree of the underlying graph are<br>key parameters which influence the overall<br>computational complexity of finite freezing automata...","title_summary":" On the impact of treewidth in the computational<br>complexity of freezing dynamics","x":-23.9720077515,"y":43.5371856689,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-23.9720077515,"tsne_y":43.5371856689,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"erx84m3l","source_x":"ArXiv","title":"Lower Bounds for Semi-adaptive Data Structures via Corruption","doi":null,"abstract":"In a dynamic data structure problem we wish to maintain an encoding of some data in memory, in such a way that we may efficiently carry out a sequence of queries and updates to the data. A long-standing open problem in this area is to prove an unconditional polynomial lower bound of a trade-off between the update time and the query time of an adaptive dynamic data structure computing some explicit function. Ko and Weinstein provided such lower bound for a restricted class of {\\em semi-adaptive\\\/} data structures, which compute the Disjointness function. There, the data are subsets $x_1,\\dots,x_k$ and $y$ of $\\{1,\\dots,n\\}$, the updates can modify $y$ (by inserting and removing elements), and the queries are an index $i \\in \\{1,\\dots,k\\}$ (query $i$ should answer whether $x_i$ and $y$ are disjoint, i.e., it should compute the Disjointness function applied to $(x_i, y)$). The semi-adaptiveness places a restriction in how the data structure can be accessed in order to answer a query. We generalize the lower bound of Ko and Weinstein to work not just for the Disjointness, but for any function having high complexity under the smooth corruption bound.","publish_time":1588636800000,"author_summary":" Dvovr'ak, Pavel; Loff, Bruno","abstract_summary":" In a dynamic data structure problem we wish to<br>maintain an encoding of some data in memory, in such a way<br>that we may efficiently carry out a sequence of<br>queries and updates to the data. A long-standing open<br>problem in this area is to prove an unconditional<br>polynomial lower bound of a trade-off between the update<br>time and the query time of an adaptive dynamic data<br>structure computing some explicit function. Ko and<br>Weinstein provided such lower bound for a restricted<br>class of {\\em semi-adaptive\\\/} data structures,<br>which compute the Disjointness function. There, the<br>data are subsets $x_1,\\dots,x_k$ and...","title_summary":" Lower Bounds for Semi-adaptive Data<br>Structures via Corruption","x":-22.4310817719,"y":42.4588890076,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.4310817719,"tsne_y":42.4588890076,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"t57k291e","source_x":"ArXiv","title":"Existence and H\\\"{older} regularity of infinitely many solutions to a $p$-Kirchhoff type problem involving a singular and a superlinear nonlinearity without the Ambrosetti-Rabinowitz (AR) condition","doi":null,"abstract":"We carry out an investigation of the existence of infinitely many solutions to a fractional $p$-Kirchhoff type problem with a singularity and a superlinear nonlinearity with a homogeneous Dirichlet boundary condition. Further the solution(s) will be proved to be bounded and a weak comparison principle has also been proved. A {\\it `$C^1$ versus $W_0^{s,p}$'} analysis has also been discussed.","publish_time":1590969600000,"author_summary":" Choudhuri, Debajyoti","abstract_summary":" We carry out an investigation of the existence<br>of infinitely many solutions to a fractional<br>$p$-Kirchhoff type problem with a singularity and a<br>superlinear nonlinearity with a homogeneous Dirichlet<br>boundary condition. Further the solution(s) will be<br>proved to be bounded and a weak comparison principle<br>has also been proved. A {\\it `$C^1$ versus<br>$W_0^{s,p}$'} analysis has also been discussed.","title_summary":" Existence and H\\\"{older} regularity of<br>infinitely many solutions to a $p$-Kirchhoff type problem<br>involving a singular and a superlinear nonlinearity<br>without the Ambrosetti-Rabinowitz (AR) condition","x":-19.4479064941,"y":46.0439567566,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.4479064941,"tsne_y":46.0439567566,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"kxqt5cwx","source_x":"ArXiv","title":"Asymptotics of maxima of (2,1) and (1,2) random walks with asymptotically zero drifts and product of nonnegative 2-by-2 matrices","doi":null,"abstract":"Consider (2,1) and (1,2) random walks with asymptotically zero drifts. Let $M$ be the maximum of an excursion starting from $2$ and ending at some point below $2.$ We study the distribution of $M$ and characterize its asymptotics, which are quite different from the ones of simple random walks. Our methods are based on the asymptotics of product of 2-by-2 nonnegative matrices and continued fractions. So, we also get a limit theorem of the product of nonnegative 2-by-2 matrices which has its own interest. Let $A_kA_{k-1}\\cdots A_1$ be the product of some nonnegative 2-by-2 matrices. Under certain conditions, we show that $\\forall i,j= 1,2,$ $(A_kA_{k-1}\\cdots A_1)_{i,j}\\sim c\\varrho(A_k)\\varrho(A_{k-1})\\cdots \\varrho(A_1)$ as $k\\rightarrow\\infty,$ where $\\varrho(A_n)$ is the spectral radius of $A_n$ and $c\\in(0,\\infty)$ is some constant.","publish_time":1588032000000,"author_summary":" Sun, Hongyan; Wang, Hua-Ming","abstract_summary":" Consider (2,1) and (1,2) random walks with<br>asymptotically zero drifts. Let $M$ be the maximum of an<br>excursion starting from $2$ and ending at some point below<br>$2.$ We study the distribution of $M$ and<br>characterize its asymptotics, which are quite different<br>from the ones of simple random walks. Our methods are<br>based on the asymptotics of product of 2-by-2<br>nonnegative matrices and continued fractions. So, we also<br>get a limit theorem of the product of nonnegative<br>2-by-2 matrices which has its own interest. Let<br>$A_kA_{k-1}\\cdots A_1$ be the product of some nonnegative 2-by-2<br>matrices. Under certain conditions, we show...","title_summary":" Asymptotics of maxima of (2,1) and (1,2) random<br>walks with asymptotically zero drifts and product of<br>nonnegative 2-by-2 matrices","x":-19.8547000885,"y":45.8638000488,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.8547000885,"tsne_y":45.8638000488,"subcluster":2,"subcluster_description":"Bi-Dimensional Zeta Valuestransportation Inequalities","shape":"p"},{"cord_uid":"gesicqx6","source_x":"ArXiv","title":"How the Law of Excluded Middle Pertains to the Second Incompleteness Theorem and its Boundary-Case Exceptions","doi":null,"abstract":"Our earlier publications showed semantic tableau admits partial exceptions to the Second Incompleteness Theorem where a formalism recognizes its self consistency and views multiplication as a 3-way relation (rather than as a total function). We now show these boundary-case evasions will collapse if the Law of the Excluded Middle is treated by tableau as a schema of logical axioms (instead of as derived theorems).","publish_time":1590969600000,"author_summary":" Willard, Dan E.","abstract_summary":" Our earlier publications showed semantic<br>tableau admits partial exceptions to the Second<br>Incompleteness Theorem where a formalism recognizes its self<br>consistency and views multiplication as a 3-way relation<br>(rather than as a total function). We now show these<br>boundary-case evasions will collapse if the Law of the<br>Excluded Middle is treated by tableau as a schema of<br>logical axioms (instead of as derived theorems).","title_summary":" How the Law of Excluded Middle Pertains to the<br>Second Incompleteness Theorem and its Boundary-Case<br>Exceptions","x":-24.4242038727,"y":45.7502326965,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-24.4242038727,"tsne_y":45.7502326965,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"286xdc7y","source_x":"ArXiv","title":"Variance of Longest Run Duration in a Random Bitstring","doi":null,"abstract":"We continue an earlier study, starting with unconstrained $n$-bitstrings, focusing now less on average behavior and more on uncertainty. The interplay between $\\bullet$ longest runs of 0s and of 1s, when bitstrings are multus $\\bullet$ longest runs of 0s and bitsums (# of 1s), when bitstrings are solus $\\\\$ is examined. While negative correlations approach zero as $n \\rightarrow \\infty$ in the former (for clumped 1s), the limit is evidently nonzero in the latter (for separated 1s). Similar analysis is possible when both 0s and 1s are clumped (bimultus), and when 0s are clumped but 1s are separated (persolus). Our methods are experimentally-based.","publish_time":1590364800000,"author_summary":" Finch, Steven","abstract_summary":" We continue an earlier study, starting with<br>unconstrained $n$-bitstrings, focusing now less on average<br>behavior and more on uncertainty. The interplay between<br>$\\bullet$ longest runs of 0s and of 1s, when bitstrings are<br>multus $\\bullet$ longest runs of 0s and bitsums (# of<br>1s), when bitstrings are solus $\\\\$ is examined.<br>While negative correlations approach zero as $n<br>\\rightarrow \\infty$ in the former (for clumped 1s), the<br>limit is evidently nonzero in the latter (for<br>separated 1s). Similar analysis is possible when both 0s<br>and 1s are clumped (bimultus), and when 0s are<br>clumped but 1s are separated (persolus). Our...","title_summary":" Variance of Longest Run Duration in a Random<br>Bitstring","x":-19.6282234192,"y":45.5485267639,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-19.6282234192,"tsne_y":45.5485267639,"subcluster":-1,"subcluster_description":-1,"shape":"p"},{"cord_uid":"ml83b433","source_x":"ArXiv","title":"Quantum computing with neutral atoms","doi":null,"abstract":"The manipulation of neutral atoms by light is at the heart of countless scientific discoveries in the field of quantum physics in the last three decades. The level of control that has been achieved at the single particle level within 2D and 3D arrays of optical traps, while preserving the fundamental properties of quantum matter (coherence, entanglement, superposition), makes these technologies prime candidates to implement disruptive computation paradigms. In this paper we discuss the technological strategy of Pasqal, a startup developing such quantum processors to tackle some of the world's most challenging problems. We present the full quantum stack, from atoms qubits to application interfaces, and propose a classification of a wide variety of tasks that can already be addressed in a computationally efficient manner in the Noisy Intermediate State Quantum era we are in. We illustrate how applications ranging from optimization challenges to simulation of quantum systems can be explored either at the digital level (programming gate-based circuits) or at the analog level (programming Hamiltonian sequences). We give evidence of the intrinsic scalability of Pasqal's technology in the 100-1,000 qubits range and introduce prospects for universal fault tolerant quantum computing and applications beyond quantum computing.","publish_time":1592784000000,"author_summary":" Henriet, Loic; Beguin, Lucas; Signoles,<br>Adrien; Lahaye, Thierry; Browaeys, Antoine; Reymond,<br>Georges-Olivier; Jurczak, Christophe","abstract_summary":" The manipulation of neutral atoms by light is at<br>the heart of countless scientific discoveries in<br>the field of quantum physics in the last three<br>decades. The level of control that has been achieved at<br>the single particle level within 2D and 3D arrays of<br>optical traps, while preserving the fundamental<br>properties of quantum matter (coherence, entanglement,<br>superposition), makes these technologies prime candidates to<br>implement disruptive computation paradigms. In this<br>paper we discuss the technological strategy of<br>Pasqal, a startup developing such quantum processors<br>to tackle some of the world's most challenging<br>problems. We present the full quantum stack, from...","title_summary":" Quantum computing with neutral atoms","x":-22.7668170929,"y":41.6718902588,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-22.7668170929,"tsne_y":41.6718902588,"subcluster":1,"subcluster_description":"Quantum Neural Networksa Annealing","shape":"p"},{"cord_uid":"pdf3i2tt","source_x":"Elsevier; Medline; PMC","title":"NetNCSP: Nonoverlapping closed sequential pattern mining","doi":"10.1016\/j.knosys.2020.105812","abstract":"Abstract Sequential pattern mining (SPM) has been applied in many fields. However, traditional SPM neglects the pattern repetition in sequence. To solve this problem, gap constraint SPM was proposed and can avoid finding too many useless patterns. Nonoverlapping SPM, as a branch of gap constraint SPM, means that any two occurrences cannot use the same sequence letter in the same position as the occurrences. Nonoverlapping SPM can make a balance between efficiency and completeness. The frequent patterns discovered by existing methods normally contain redundant patterns. To reduce redundant patterns and improve the mining performance, this paper adopts the closed pattern mining strategy and proposes a complete algorithm, named Nettree for Nonoverlapping Closed Sequential Pattern (NetNCSP) based on the Nettree structure. NetNCSP is equipped with two key steps, support calculation and closeness determination. A backtracking strategy is employed to calculate the nonoverlapping support of a pattern on the corresponding Nettree, which reduces the time complexity. This paper also proposes three kinds of pruning strategies, inheriting, predicting, and determining. These pruning strategies are able to find the redundant patterns effectively since the strategies can predict the frequency and closeness of the patterns before the generation of the candidate patterns. Experimental results show that NetNCSP is not only more efficient but can also discover more closed patterns with good compressibility. Furtherly, in biological experiments NetNCSP mines the closed patterns in SARS-CoV-2 and SARS viruses. The results show that the two viruses are of similar pattern composition with different combinations.","publish_time":1585612800000,"author_summary":" Wu, Youxi; Zhu, Changrui; Li, Yan; Guo, Lei; Wu,<br>Xindong","abstract_summary":" Abstract Sequential pattern mining (SPM) has<br>been applied in many fields. However, traditional<br>SPM neglects the pattern repetition in sequence.<br>To solve this problem, gap constraint SPM was<br>proposed and can avoid finding too many useless<br>patterns. Nonoverlapping SPM, as a branch of gap<br>constraint SPM, means that any two occurrences cannot use<br>the same sequence letter in the same position as the<br>occurrences. Nonoverlapping SPM can make a balance between<br>efficiency and completeness. The frequent patterns<br>discovered by existing methods normally contain<br>redundant patterns. To reduce redundant patterns and<br>improve the mining performance, this paper adopts the<br>closed pattern...","title_summary":" NetNCSP: Nonoverlapping closed sequential<br>pattern mining","x":-25.4313602448,"y":42.1132583618,"cluster":7,"cluster_name":"c8","cluster_description":"Attributed Graph Transformation Systems","tsne_x":-25.4313602448,"tsne_y":42.1132583618,"subcluster":-1,"subcluster_description":-1,"shape":"p"}]